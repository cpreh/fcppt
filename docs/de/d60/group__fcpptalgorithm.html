<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fcppt: fcppt.algorithm</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname"><span id="projectnumber">&#160;5.1.0</span>
   </div>
   <div id="projectbrief">Freundlich&#39;s C++ toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fcppt.algorithm <div class="ingroups"><a class="el" href="../../df/df4/group__fcpptmain.html">fcppt</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Description</h2>
<p>General-purpose algorithms. </p>
<p>C++'s standard algorithms use iterators both for function inputs and outputs. This makes functional programming hard in two ways: </p><ul>
<li>
A range is expressed as a pair of values instead of a single value which makes composing ranges impossible. </li>
<li>
Functions do not return results. Instead, they return their result through output iterator parameters. This makes composing function calls impossible. </li>
</ul>
<p>This module provides a collection of very common algorithms over ranges that fix both problems. Prominent examples are <a class="el" href="#ga2badaec70ff770f2b896935dfa1d750f" title="Folds a range into a value.">fcppt::algorithm::fold</a> and <a class="el" href="#gad9e6c46ebae6641e0d64e64cda0edb01" title="Transforms a range to another container by applying a function to every element.">fcppt::algorithm::map</a> . To get the most out of them, these can be used in conjunction with a range library (like <code>Boost.Range</code>). </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:fcppt_3A_3Aalgorithm_3A_3Aloop_5Fbreak_5Fimpl_3C_20Range_2C_20Enable_20_3E" id="r_fcppt_3A_3Aalgorithm_3A_3Aloop_5Fbreak_5Fimpl_3C_20Range_2C_20Enable_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd8/structfcppt_1_1algorithm_1_1loop__break__impl.html">fcppt::algorithm::loop_break_impl&lt; Range, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point for ranges.  <a href="../../de/dd8/structfcppt_1_1algorithm_1_1loop__break__impl.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae4ce0de10b9325cb541efbe130708189" id="r_gae4ce0de10b9325cb541efbe130708189"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae4ce0de10b9325cb541efbe130708189">fcppt::algorithm::update_action</a> : std::uint8_t { <a class="el" href="#ggae4ce0de10b9325cb541efbe130708189a18ccf61d533b600bbf5a963359223fe4">fcppt::algorithm::update_action::keep</a>
, <a class="el" href="#ggae4ce0de10b9325cb541efbe130708189a0f6969d7052da9261e31ddb6e88c136e">fcppt::algorithm::update_action::remove</a>
 }</td></tr>
<tr class="memdesc:gae4ce0de10b9325cb541efbe130708189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update action for container iteration.  <a href="#gae4ce0de10b9325cb541efbe130708189">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf8798c95f8f00af7a6c25a13ac832df8" id="r_gaf8798c95f8f00af7a6c25a13ac832df8"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename Pred&gt; </td></tr>
<tr class="memitem:gaf8798c95f8f00af7a6c25a13ac832df8 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf8798c95f8f00af7a6c25a13ac832df8">fcppt::algorithm::all_of</a> (Range const &amp;_range, Pred const &amp;_pred)</td></tr>
<tr class="memdesc:gaf8798c95f8f00af7a6c25a13ac832df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given predicate is true for all elements of a range.  <br /></td></tr>
<tr class="memitem:gabaa627161a23ec1c3273ccb892ae739b" id="r_gabaa627161a23ec1c3273ccb892ae739b"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename T&gt; <br />
requires (std::ranges::input_range&lt;std::remove_cvref_t&lt;Range&gt;&gt;)</td></tr>
<tr class="memitem:gabaa627161a23ec1c3273ccb892ae739b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../de/d7e/group__fcpptcontainer.html#ga4e1570828202ee7b5610c20d2910de0c">fcppt::container::to_iterator_type</a>&lt; std::remove_reference_t&lt; Range &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabaa627161a23ec1c3273ccb892ae739b">fcppt::algorithm::binary_search</a> (Range &amp;&amp;_range, T const &amp;_value)</td></tr>
<tr class="memdesc:gabaa627161a23ec1c3273ccb892ae739b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element by binary search.  <br /></td></tr>
<tr class="memitem:ga4620dd4ad01d1c7392f3a6b7cd780d4f" id="r_ga4620dd4ad01d1c7392f3a6b7cd780d4f"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename Pred&gt; </td></tr>
<tr class="memitem:ga4620dd4ad01d1c7392f3a6b7cd780d4f template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4620dd4ad01d1c7392f3a6b7cd780d4f">fcppt::algorithm::contains_if</a> (Range const &amp;_range, Pred const &amp;_pred)</td></tr>
<tr class="memdesc:ga4620dd4ad01d1c7392f3a6b7cd780d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given value is inside a range, using a predicate.  <br /></td></tr>
<tr class="memitem:ga19f9a99d15527507386e1a03ba6a9168" id="r_ga19f9a99d15527507386e1a03ba6a9168"><td class="memTemplParams" colspan="2">template&lt;typename Result, typename Range, typename Function&gt; </td></tr>
<tr class="memitem:ga19f9a99d15527507386e1a03ba6a9168 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; Result &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga19f9a99d15527507386e1a03ba6a9168">fcppt::algorithm::find_by_opt</a> (Range &amp;&amp;_range, Function const &amp;_function)</td></tr>
<tr class="memdesc:ga19f9a99d15527507386e1a03ba6a9168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally finds an element and transforms it.  <br /></td></tr>
<tr class="memitem:gaaf5758f53d164a78c4fed4dda8ac0de6" id="r_gaaf5758f53d164a78c4fed4dda8ac0de6"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename Comp&gt; <br />
requires (std::ranges::input_range&lt;std::remove_cvref_t&lt;Range&gt;&gt;)</td></tr>
<tr class="memitem:gaaf5758f53d164a78c4fed4dda8ac0de6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../de/d7e/group__fcpptcontainer.html#ga4e1570828202ee7b5610c20d2910de0c">fcppt::container::to_iterator_type</a>&lt; std::remove_reference_t&lt; Range &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf5758f53d164a78c4fed4dda8ac0de6">fcppt::algorithm::find_if_opt</a> (Range &amp;&amp;_range, Comp const &amp;_comp)</td></tr>
<tr class="memdesc:gaaf5758f53d164a78c4fed4dda8ac0de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>std::find_if</code> but returns an empty optional on failure.  <br /></td></tr>
<tr class="memitem:ga426acaa068bd86fabc500e48b2bbedef" id="r_ga426acaa068bd86fabc500e48b2bbedef"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename T&gt; <br />
requires (std::ranges::input_range&lt;Range&gt;)</td></tr>
<tr class="memitem:ga426acaa068bd86fabc500e48b2bbedef template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../de/d7e/group__fcpptcontainer.html#ga4e1570828202ee7b5610c20d2910de0c">fcppt::container::to_iterator_type</a>&lt; std::remove_reference_t&lt; Range &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga426acaa068bd86fabc500e48b2bbedef">fcppt::algorithm::find_opt</a> (Range &amp;&amp;_range, T const &amp;_value)</td></tr>
<tr class="memdesc:ga426acaa068bd86fabc500e48b2bbedef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>std::find</code> but returns an empty optional on failure.  <br /></td></tr>
<tr class="memitem:ga2badaec70ff770f2b896935dfa1d750f" id="r_ga2badaec70ff770f2b896935dfa1d750f"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename State, typename Function&gt; <br />
requires (std::movable&lt;State&gt;)</td></tr>
<tr class="memitem:ga2badaec70ff770f2b896935dfa1d750f template"><td class="memItemLeft" align="right" valign="top">State&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2badaec70ff770f2b896935dfa1d750f">fcppt::algorithm::fold</a> (Range &amp;&amp;_range, State _state, Function _function)</td></tr>
<tr class="memdesc:ga2badaec70ff770f2b896935dfa1d750f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds a range into a value.  <br /></td></tr>
<tr class="memitem:ga77e015f0fa10b04ce0bb9234f0579822" id="r_ga77e015f0fa10b04ce0bb9234f0579822"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename State, typename Function&gt; <br />
requires (std::movable&lt;State&gt;)</td></tr>
<tr class="memitem:ga77e015f0fa10b04ce0bb9234f0579822 template"><td class="memItemLeft" align="right" valign="top">State&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga77e015f0fa10b04ce0bb9234f0579822">fcppt::algorithm::fold_break</a> (Range &amp;&amp;_range, State _state, Function _function)</td></tr>
<tr class="memdesc:ga77e015f0fa10b04ce0bb9234f0579822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds a range into a value, can break out early.  <br /></td></tr>
<tr class="memitem:ga604a1ed2cd2771d1977297362647bce8" id="r_ga604a1ed2cd2771d1977297362647bce8"><td class="memTemplParams" colspan="2">template&lt;typename TargetContainer, typename Function&gt; </td></tr>
<tr class="memitem:ga604a1ed2cd2771d1977297362647bce8 template"><td class="memItemLeft" align="right" valign="top">TargetContainer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga604a1ed2cd2771d1977297362647bce8">fcppt::algorithm::generate_n</a> (std::size_t const _count, Function const &amp;_function)</td></tr>
<tr class="memdesc:ga604a1ed2cd2771d1977297362647bce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a container by calling a function a number of times.  <br /></td></tr>
<tr class="memitem:ga760531d7f4fd0b7f2da6760acff255eb" id="r_ga760531d7f4fd0b7f2da6760acff255eb"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename T&gt; </td></tr>
<tr class="memitem:ga760531d7f4fd0b7f2da6760acff255eb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; std::ranges::range_size_t&lt; Range &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga760531d7f4fd0b7f2da6760acff255eb">fcppt::algorithm::index_of</a> (Range const &amp;_range, T const &amp;_value)</td></tr>
<tr class="memdesc:ga760531d7f4fd0b7f2da6760acff255eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first element found in a sequence.  <br /></td></tr>
<tr class="memitem:ga46a69172eb846514cf067438e120d932" id="r_ga46a69172eb846514cf067438e120d932"><td class="memTemplParams" colspan="2">template&lt;typename Range&gt; <br />
requires (std::ranges::input_range&lt;Range&gt;)</td></tr>
<tr class="memitem:ga46a69172eb846514cf067438e120d932 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/df1/group__fcppttypetraits.html#ga2e84f11147fb74d6c7b1be3068339df9">fcppt::type_traits::value_type</a>&lt; Range &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga46a69172eb846514cf067438e120d932">fcppt::algorithm::join_strings</a> (Range const &amp;_range, <a class="el" href="../../d9/df1/group__fcppttypetraits.html#ga2e84f11147fb74d6c7b1be3068339df9">fcppt::type_traits::value_type</a>&lt; Range &gt; const &amp;_delim)</td></tr>
<tr class="memdesc:ga46a69172eb846514cf067438e120d932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins a range of strings, using a delimiter.  <br /></td></tr>
<tr class="memitem:gac4d8835ebd3bcae2e9324fe916f56783" id="r_gac4d8835ebd3bcae2e9324fe916f56783"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename Body&gt; </td></tr>
<tr class="memitem:gac4d8835ebd3bcae2e9324fe916f56783 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac4d8835ebd3bcae2e9324fe916f56783">fcppt::algorithm::loop</a> (Range &amp;&amp;_range, Body const &amp;_body)</td></tr>
<tr class="memdesc:gac4d8835ebd3bcae2e9324fe916f56783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through a range.  <br /></td></tr>
<tr class="memitem:gab739625b77f68e095de0691859f7cb22" id="r_gab739625b77f68e095de0691859f7cb22"><td class="memTemplParams" colspan="2">template&lt;typename Range, typename Body&gt; </td></tr>
<tr class="memitem:gab739625b77f68e095de0691859f7cb22 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab739625b77f68e095de0691859f7cb22">fcppt::algorithm::loop_break</a> (Range &amp;&amp;_range, Body const &amp;_body)</td></tr>
<tr class="memdesc:gab739625b77f68e095de0691859f7cb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through a range with the ability to break out of the loop.  <br /></td></tr>
<tr class="memitem:gad9e6c46ebae6641e0d64e64cda0edb01" id="r_gad9e6c46ebae6641e0d64e64cda0edb01"><td class="memTemplParams" colspan="2">template&lt;typename TargetContainer, typename SourceRange, typename Function&gt; </td></tr>
<tr class="memitem:gad9e6c46ebae6641e0d64e64cda0edb01 template"><td class="memItemLeft" align="right" valign="top">TargetContainer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad9e6c46ebae6641e0d64e64cda0edb01">fcppt::algorithm::map</a> (SourceRange &amp;&amp;_source, Function const &amp;_function)</td></tr>
<tr class="memdesc:gad9e6c46ebae6641e0d64e64cda0edb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a range to another container by applying a function to every element.  <br /></td></tr>
<tr class="memitem:ga8522c5f8fdf6f7c2cd2e10b950a57ffe" id="r_ga8522c5f8fdf6f7c2cd2e10b950a57ffe"><td class="memTemplParams" colspan="2">template&lt;typename TargetContainer, typename Range, typename Function&gt; </td></tr>
<tr class="memitem:ga8522c5f8fdf6f7c2cd2e10b950a57ffe template"><td class="memItemLeft" align="right" valign="top">TargetContainer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8522c5f8fdf6f7c2cd2e10b950a57ffe">fcppt::algorithm::map_concat</a> (Range &amp;&amp;_range, Function const &amp;_function)</td></tr>
<tr class="memdesc:ga8522c5f8fdf6f7c2cd2e10b950a57ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a range to other sequences and joins them.  <br /></td></tr>
<tr class="memitem:ga50ee50af2fe99dc1ce55f179978fa571" id="r_ga50ee50af2fe99dc1ce55f179978fa571"><td class="memTemplParams" colspan="2">template&lt;typename Map, typename UpdateAction&gt; </td></tr>
<tr class="memitem:ga50ee50af2fe99dc1ce55f179978fa571 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50ee50af2fe99dc1ce55f179978fa571">fcppt::algorithm::map_iteration</a> (Map &amp;_map, UpdateAction const &amp;_update_action)</td></tr>
<tr class="memdesc:ga50ee50af2fe99dc1ce55f179978fa571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over a map with the possibility of erasing elements.  <br /></td></tr>
<tr class="memitem:ga317a9558819b170deea3458196445ee5" id="r_ga317a9558819b170deea3458196445ee5"><td class="memTemplParams" colspan="2">template&lt;typename Map, typename UpdateAction&gt; </td></tr>
<tr class="memitem:ga317a9558819b170deea3458196445ee5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga317a9558819b170deea3458196445ee5">fcppt::algorithm::map_iteration_second</a> (Map &amp;_map, UpdateAction const &amp;_update_action)</td></tr>
<tr class="memdesc:ga317a9558819b170deea3458196445ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over a map with the possibility of erasing elements, passing second.  <br /></td></tr>
<tr class="memitem:gaf18146a01a1a7c2a57e1e086795ba1d3" id="r_gaf18146a01a1a7c2a57e1e086795ba1d3"><td class="memTemplParams" colspan="2">template&lt;typename TargetContainer, typename Source, typename Function&gt; </td></tr>
<tr class="memitem:gaf18146a01a1a7c2a57e1e086795ba1d3 template"><td class="memItemLeft" align="right" valign="top">TargetContainer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf18146a01a1a7c2a57e1e086795ba1d3">fcppt::algorithm::map_optional</a> (Source &amp;&amp;_source, Function const &amp;_function)</td></tr>
<tr class="memdesc:gaf18146a01a1a7c2a57e1e086795ba1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a range to another container by applying a function to every element, only inserting the results that are not empty optionals.  <br /></td></tr>
<tr class="memitem:gae9ae40e09391576605ac4478a9b5148f" id="r_gae9ae40e09391576605ac4478a9b5148f"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:gae9ae40e09391576605ac4478a9b5148f template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9ae40e09391576605ac4478a9b5148f">fcppt::algorithm::remove</a> (Container &amp;_container, typename Container::const_reference _element)</td></tr>
<tr class="memdesc:gae9ae40e09391576605ac4478a9b5148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all occurrences of a value from a container.  <br /></td></tr>
<tr class="memitem:ga2f7666858dc827c1d5e139c57e2a041f" id="r_ga2f7666858dc827c1d5e139c57e2a041f"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Predicate&gt; </td></tr>
<tr class="memitem:ga2f7666858dc827c1d5e139c57e2a041f template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f7666858dc827c1d5e139c57e2a041f">fcppt::algorithm::remove_if</a> (Container &amp;_container, Predicate const &amp;_predicate)</td></tr>
<tr class="memdesc:ga2f7666858dc827c1d5e139c57e2a041f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from a container matching a predicate.  <br /></td></tr>
<tr class="memitem:ga0779216dccd1d302287767fa95a9c004" id="r_ga0779216dccd1d302287767fa95a9c004"><td class="memTemplParams" colspan="2">template&lt;typename String&gt; <br />
requires (<a class="el" href="../../d8/d2a/structfcppt_1_1type__traits_1_1is__string.html">fcppt::type_traits::is_string</a>&lt;String&gt;::value)</td></tr>
<tr class="memitem:ga0779216dccd1d302287767fa95a9c004 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; String &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0779216dccd1d302287767fa95a9c004">fcppt::algorithm::remove_suffix</a> (String const &amp;_string, <a class="el" href="../../d9/df1/group__fcppttypetraits.html#ga3135bdd67a067948fb87d76f1130ec7b">fcppt::type_traits::size_type</a>&lt; String &gt; const _length)</td></tr>
<tr class="memdesc:ga0779216dccd1d302287767fa95a9c004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a suffix of a string.  <br /></td></tr>
<tr class="memitem:ga8b3f2a87ab492d24136ac36b9a6ce21c" id="r_ga8b3f2a87ab492d24136ac36b9a6ce21c"><td class="memTemplParams" colspan="2">template&lt;typename Count, typename Function&gt; </td></tr>
<tr class="memitem:ga8b3f2a87ab492d24136ac36b9a6ce21c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b3f2a87ab492d24136ac36b9a6ce21c">fcppt::algorithm::repeat</a> (Count const _count, Function const &amp;_function)</td></tr>
<tr class="memdesc:ga8b3f2a87ab492d24136ac36b9a6ce21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function a number of times.  <br /></td></tr>
<tr class="memitem:gaeade55885acd3b7c7bbb7787d473f95e" id="r_gaeade55885acd3b7c7bbb7787d473f95e"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:gaeade55885acd3b7c7bbb7787d473f95e template"><td class="memItemLeft" align="right" valign="top">std::remove_cvref_t&lt; Container &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeade55885acd3b7c7bbb7787d473f95e">fcppt::algorithm::reverse</a> (Container &amp;&amp;_container)</td></tr>
<tr class="memdesc:gaeade55885acd3b7c7bbb7787d473f95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a container.  <br /></td></tr>
<tr class="memitem:ga8986dd750e21b92cdd489a4b1233b742" id="r_ga8986dd750e21b92cdd489a4b1233b742"><td class="memTemplParams" colspan="2">template&lt;typename Sequence, typename UpdateAction&gt; </td></tr>
<tr class="memitem:ga8986dd750e21b92cdd489a4b1233b742 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8986dd750e21b92cdd489a4b1233b742">fcppt::algorithm::sequence_iteration</a> (Sequence &amp;_sequence, UpdateAction const &amp;_update_action)</td></tr>
<tr class="memdesc:ga8986dd750e21b92cdd489a4b1233b742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over a sequence with the possibility of erasing elements.  <br /></td></tr>
<tr class="memitem:gac5f2499f640a5fc48e2dc414c58df03e" id="r_gac5f2499f640a5fc48e2dc414c58df03e"><td class="memTemplParams" colspan="2">template&lt;typename String&gt; </td></tr>
<tr class="memitem:gac5f2499f640a5fc48e2dc414c58df03e template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; String &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5f2499f640a5fc48e2dc414c58df03e">fcppt::algorithm::split_string</a> (String const &amp;_string, <a class="el" href="../../d9/df1/group__fcppttypetraits.html#ga2e84f11147fb74d6c7b1be3068339df9">fcppt::type_traits::value_type</a>&lt; String &gt; const _delim)</td></tr>
<tr class="memdesc:gac5f2499f640a5fc48e2dc414c58df03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string, using a delimiter.  <br /></td></tr>
<tr class="memitem:ga6d5d765bf4a8c94e6cf0423285fcf5a8" id="r_ga6d5d765bf4a8c94e6cf0423285fcf5a8"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:ga6d5d765bf4a8c94e6cf0423285fcf5a8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6d5d765bf4a8c94e6cf0423285fcf5a8">fcppt::algorithm::unique</a> (Container &amp;_container)</td></tr>
<tr class="memdesc:ga6d5d765bf4a8c94e6cf0423285fcf5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate elements from a container.  <br /></td></tr>
<tr class="memitem:gabbf00262155ebd08ace46e194cf83894" id="r_gabbf00262155ebd08ace46e194cf83894"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename BinaryPredicate&gt; </td></tr>
<tr class="memitem:gabbf00262155ebd08ace46e194cf83894 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabbf00262155ebd08ace46e194cf83894">fcppt::algorithm::unique_if</a> (Container &amp;_container, BinaryPredicate const &amp;_predicate)</td></tr>
<tr class="memdesc:gabbf00262155ebd08ace46e194cf83894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate elements from a container. Compares using a predicate.  <br /></td></tr>
</table>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="gae4ce0de10b9325cb541efbe130708189" name="gae4ce0de10b9325cb541efbe130708189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ce0de10b9325cb541efbe130708189">&#9670;&#160;</a></span>update_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#gae4ce0de10b9325cb541efbe130708189">fcppt::algorithm::update_action</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update action for container iteration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae4ce0de10b9325cb541efbe130708189a18ccf61d533b600bbf5a963359223fe4" name="ggae4ce0de10b9325cb541efbe130708189a18ccf61d533b600bbf5a963359223fe4"></a>keep&#160;</td><td class="fielddoc"><p>Keep the element. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4ce0de10b9325cb541efbe130708189a0f6969d7052da9261e31ddb6e88c136e" name="ggae4ce0de10b9325cb541efbe130708189a0f6969d7052da9261e31ddb6e88c136e"></a>remove&#160;</td><td class="fielddoc"><p>Remove the element. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gaf8798c95f8f00af7a6c25a13ac832df8" name="gaf8798c95f8f00af7a6c25a13ac832df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8798c95f8f00af7a6c25a13ac832df8">&#9670;&#160;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Pred&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::algorithm::all_of </td>
          <td>(</td>
          <td class="paramtype">Range const &amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred const &amp;</td>          <td class="paramname"><span class="paramname"><em>_pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given predicate is true for all elements of a range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pred</td><td>A function callable as <code>bool (T)</code> for every type <code>T</code> in the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabaa627161a23ec1c3273ccb892ae739b" name="gabaa627161a23ec1c3273ccb892ae739b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa627161a23ec1c3273ccb892ae739b">&#9670;&#160;</a></span>binary_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename T&gt; <br />
requires (std::ranges::input_range&lt;std::remove_cvref_t&lt;Range&gt;&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../de/d7e/group__fcpptcontainer.html#ga4e1570828202ee7b5610c20d2910de0c">fcppt::container::to_iterator_type</a>&lt; std::remove_reference_t&lt; Range &gt; &gt; &gt; fcppt::algorithm::binary_search </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element by binary search. </p>
<p>If there is exactly one element that is uncomparable to <em class="arg">_value</em>, returns an iterator to that element. Otherwise, returns the empty optional.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be less-than comparable to the range's value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4620dd4ad01d1c7392f3a6b7cd780d4f" name="ga4620dd4ad01d1c7392f3a6b7cd780d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4620dd4ad01d1c7392f3a6b7cd780d4f">&#9670;&#160;</a></span>contains_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Pred&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::algorithm::contains_if </td>
          <td>(</td>
          <td class="paramtype">Range const &amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred const &amp;</td>          <td class="paramname"><span class="paramname"><em>_pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given value is inside a range, using a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pred</td><td>A function callable as <code>bool (T)</code> for all types T that appear in <em class="arg">Range</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19f9a99d15527507386e1a03ba6a9168" name="ga19f9a99d15527507386e1a03ba6a9168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19f9a99d15527507386e1a03ba6a9168">&#9670;&#160;</a></span>find_by_opt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result, typename Range, typename Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; Result &gt; fcppt::algorithm::find_by_opt </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function const &amp;</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optionally finds an element and transforms it. </p>
<p>Returns the first element in <em class="arg">_range</em> for which <em class="arg">_function</em> does not return an empty optional, if there is any. Otherwise, returns the empty optional.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>A function callable as <code><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::object&lt;Result&gt;</a>
(T)</code> for every type <code>T</code> in <em class="arg">Range</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf5758f53d164a78c4fed4dda8ac0de6" name="gaaf5758f53d164a78c4fed4dda8ac0de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf5758f53d164a78c4fed4dda8ac0de6">&#9670;&#160;</a></span>find_if_opt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Comp&gt; <br />
requires (std::ranges::input_range&lt;std::remove_cvref_t&lt;Range&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../de/d7e/group__fcpptcontainer.html#ga4e1570828202ee7b5610c20d2910de0c">fcppt::container::to_iterator_type</a>&lt; std::remove_reference_t&lt; Range &gt; &gt; &gt; fcppt::algorithm::find_if_opt </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp const &amp;</td>          <td class="paramname"><span class="paramname"><em>_comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <code>std::find_if</code> but returns an empty optional on failure. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Comp</td><td>Must be a function callable as <code>bool (Range::value_type)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga426acaa068bd86fabc500e48b2bbedef" name="ga426acaa068bd86fabc500e48b2bbedef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga426acaa068bd86fabc500e48b2bbedef">&#9670;&#160;</a></span>find_opt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename T&gt; <br />
requires (std::ranges::input_range&lt;Range&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../de/d7e/group__fcpptcontainer.html#ga4e1570828202ee7b5610c20d2910de0c">fcppt::container::to_iterator_type</a>&lt; std::remove_reference_t&lt; Range &gt; &gt; &gt; fcppt::algorithm::find_opt </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>std::find</code> but returns an empty optional on failure. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be equality-comparable to <code>Range::value_type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2badaec70ff770f2b896935dfa1d750f" name="ga2badaec70ff770f2b896935dfa1d750f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2badaec70ff770f2b896935dfa1d750f">&#9670;&#160;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename State, typename Function&gt; <br />
requires (std::movable&lt;State&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State fcppt::algorithm::fold </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">State</td>          <td class="paramname"><span class="paramname"><em>_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds a range into a value. </p>
<p>Like <code>fold_left</code> in a functional programming language, this function starts with <em class="arg">_state</em> as <code>cur_state</code>, and calls <code> cur_state =
_function(element, cur_state)</code> for every element of <em class="arg">_range</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>Must be callable as <code>State (T,State)</code> for every type <code>T</code> in <em class="arg">Range</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77e015f0fa10b04ce0bb9234f0579822" name="ga77e015f0fa10b04ce0bb9234f0579822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77e015f0fa10b04ce0bb9234f0579822">&#9670;&#160;</a></span>fold_break()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename State, typename Function&gt; <br />
requires (std::movable&lt;State&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State fcppt::algorithm::fold_break </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">State</td>          <td class="paramname"><span class="paramname"><em>_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds a range into a value, can break out early. </p>
<p>Let <code> [e_1,...,e_n] </code> be the input range and <code>s_0 = _state</code>.</p>
<p>This function calls <code>(l_i, s_i) = <em>function(e_i,s</em>{i-1})</code> for <code>i = 1,...,x</code> where <code>x &lt;= n</code> is the largest number such that <code>l_j = <a class="el" href="../../d7/d50/group__fcpptvarious.html#ggad862c66baf3fe8aa882a155299887504a5b4404524e842940120cc65b3214d40b">loop::continue_</a></code> for all <code>1 &lt;= j &lt; x</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>Must be callable as <code>std::pair&lt;fcppt::loop, State&gt;
(T,State)</code> for every type <code>T</code> in <em class="arg">Range</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga604a1ed2cd2771d1977297362647bce8" name="ga604a1ed2cd2771d1977297362647bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga604a1ed2cd2771d1977297362647bce8">&#9670;&#160;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetContainer, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TargetContainer fcppt::algorithm::generate_n </td>
          <td>(</td>
          <td class="paramtype">std::size_t const</td>          <td class="paramname"><span class="paramname"><em>_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function const &amp;</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a container by calling a function a number of times. </p>
<p>Calls <em class="arg">_function</em> <em class="arg">_count</em> times and collects the results into a container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>A function callable as <code>TargetContainer::value_type()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga760531d7f4fd0b7f2da6760acff255eb" name="ga760531d7f4fd0b7f2da6760acff255eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760531d7f4fd0b7f2da6760acff255eb">&#9670;&#160;</a></span>index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; std::ranges::range_size_t&lt; Range &gt; &gt; fcppt::algorithm::index_of </td>
          <td>(</td>
          <td class="paramtype">Range const &amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first element found in a sequence. </p>
<p>Searches for <em class="arg">_value</em> in <em class="arg">_range</em> and returns the index of the first occurrence if there is any, otherwise returns the empty optional.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A random access range.</td></tr>
    <tr><td class="paramname">T</td><td>A type equality-comparable to the ranges's value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46a69172eb846514cf067438e120d932" name="ga46a69172eb846514cf067438e120d932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46a69172eb846514cf067438e120d932">&#9670;&#160;</a></span>join_strings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range&gt; <br />
requires (std::ranges::input_range&lt;Range&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/df1/group__fcppttypetraits.html#ga2e84f11147fb74d6c7b1be3068339df9">fcppt::type_traits::value_type</a>&lt; Range &gt; fcppt::algorithm::join_strings </td>
          <td>(</td>
          <td class="paramtype">Range const &amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/df1/group__fcppttypetraits.html#ga2e84f11147fb74d6c7b1be3068339df9">fcppt::type_traits::value_type</a>&lt; Range &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>_delim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins a range of strings, using a delimiter. </p>
<p>Joins <em class="arg">_range</em>, inserting <em class="arg">_delim</em> between every pair of consecutive elements.</p>
<p>Example:</p>
<div class="fragment"><div class="line">    std::vector&lt;std::string&gt; <span class="keyword">const</span> strings{<span class="stringliteral">&quot;ab&quot;</span>, <span class="stringliteral">&quot;cd&quot;</span>, <span class="stringliteral">&quot;efg&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    std::string <span class="keyword">const</span> <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a>{<a class="code hl_function" href="#ga46a69172eb846514cf067438e120d932" title="Joins a range of strings, using a delimiter.">fcppt::algorithm::join_strings</a>(strings, <span class="stringliteral">&quot;,&quot;</span>)};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Outputs &quot;ab,cd,efg&quot;</span></div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>A range of strings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4d8835ebd3bcae2e9324fe916f56783" name="gac4d8835ebd3bcae2e9324fe916f56783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4d8835ebd3bcae2e9324fe916f56783">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Body&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::algorithm::loop </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Body const &amp;</td>          <td class="paramname"><span class="paramname"><em>_body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates through a range. </p>
<p>Iterates through <em class="arg">_range</em>, calling <em class="arg">_body</em> for every element of the range. The implementation for a specific range type is handled by <a class="el" href="../../de/dd8/structfcppt_1_1algorithm_1_1loop__break__impl.html" title="Customization point for ranges.">fcppt::algorithm::loop_break_impl</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Body</td><td>A function callable as <code>void (T)</code> for every type <code>T</code> in <em class="arg">Range</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab739625b77f68e095de0691859f7cb22" name="gab739625b77f68e095de0691859f7cb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab739625b77f68e095de0691859f7cb22">&#9670;&#160;</a></span>loop_break()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Body&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::algorithm::loop_break </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Body const &amp;</td>          <td class="paramname"><span class="paramname"><em>_body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates through a range with the ability to break out of the loop. </p>
<p>Iterates through <em class="arg">_range</em>, calling <em class="arg">_body</em> for every element of the range as long as <em class="arg">_function</em> returns <a class="el" href="../../d7/d50/group__fcpptvarious.html#ggad862c66baf3fe8aa882a155299887504a5b4404524e842940120cc65b3214d40b">fcppt::loop::continue_</a>. The implementation for a specific range type is handled by <a class="el" href="../../de/dd8/structfcppt_1_1algorithm_1_1loop__break__impl.html" title="Customization point for ranges.">fcppt::algorithm::loop_break_impl</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Body</td><td>A function callable as <code><a class="el" href="../../d7/d50/group__fcpptvarious.html#gad862c66baf3fe8aa882a155299887504" title="Denotes a loop control statement.">fcppt::loop</a> (T)</code> for every type <code>T</code> in <em class="arg">Range</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9e6c46ebae6641e0d64e64cda0edb01" name="gad9e6c46ebae6641e0d64e64cda0edb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9e6c46ebae6641e0d64e64cda0edb01">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetContainer, typename SourceRange, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TargetContainer fcppt::algorithm::map </td>
          <td>(</td>
          <td class="paramtype">SourceRange &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function const &amp;</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a range to another container by applying a function to every element. </p>
<p>For every element <em>e</em> in <em class="arg">_source</em>, <code>_function(e)</code> is inserted into the result container.</p>
<dl class="section note"><dt>Note</dt><dd>As an optimization the result container has its capacity set to the source range's size at the start, if possible. For this to work, the result container needs a <code>reserve</code> function, and the source range needs a <code>size</code> function or must be a random-access range.</dd></dl>
<p>The actual implementation of the algorithm is provided by <a class="el" href="../../d6/de2/structfcppt_1_1algorithm_1_1map__impl.html">fcppt::algorithm::map_impl</a> which by default uses <a class="el" href="#gac4d8835ebd3bcae2e9324fe916f56783" title="Iterates through a range.">fcppt::algorithm::loop</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>Let <code>T_1,...,T_n</code> be the types of <em class="arg">SourceRange</em> and <code>U_1,...,U_n</code> the types of <em class="arg">TargetContainer</em>. Then the function must be callable as <code>U_i(T_i)</code> for every <code>1 &lt;= i &lt;= n</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8522c5f8fdf6f7c2cd2e10b950a57ffe" name="ga8522c5f8fdf6f7c2cd2e10b950a57ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8522c5f8fdf6f7c2cd2e10b950a57ffe">&#9670;&#160;</a></span>map_concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetContainer, typename Range, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TargetContainer fcppt::algorithm::map_concat </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function const &amp;</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a range to other sequences and joins them. </p>
<p>For every element in <em class="arg">_range</em> <code>(a_1, ..., a_n)</code>, <code>_function(a_1), ..., _function(a_n)</code> is called, yielding <code>(r_1, ..., r_n)</code>. The result is <code>join(r_1, r_2, ...,
r_n)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>A function callable as <code>TargetContainer
(Range::value_type)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50ee50af2fe99dc1ce55f179978fa571" name="ga50ee50af2fe99dc1ce55f179978fa571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50ee50af2fe99dc1ce55f179978fa571">&#9670;&#160;</a></span>map_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Map, typename UpdateAction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::algorithm::map_iteration </td>
          <td>(</td>
          <td class="paramtype">Map &amp;</td>          <td class="paramname"><span class="paramname"><em>_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateAction const &amp;</td>          <td class="paramname"><span class="paramname"><em>_update_action</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over a map with the possibility of erasing elements. </p>
<p>Iterates over <em class="arg">_map</em>, applying <em class="arg">_update_action</em> to each element. If <em class="arg">_update_action</em> returns <a class="el" href="#ggae4ce0de10b9325cb541efbe130708189a0f6969d7052da9261e31ddb6e88c136e" title="Remove the element.">fcppt::algorithm::update_action::remove</a>, the element is deleted from the map.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Map</td><td>A map-like container.</td></tr>
    <tr><td class="paramname">UpdateAction</td><td>A function callable as <code><a class="el" href="#gae4ce0de10b9325cb541efbe130708189" title="Update action for container iteration.">fcppt::algorithm::update_action</a> (Map::value_type)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga317a9558819b170deea3458196445ee5" name="ga317a9558819b170deea3458196445ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga317a9558819b170deea3458196445ee5">&#9670;&#160;</a></span>map_iteration_second()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Map, typename UpdateAction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::algorithm::map_iteration_second </td>
          <td>(</td>
          <td class="paramtype">Map &amp;</td>          <td class="paramname"><span class="paramname"><em>_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateAction const &amp;</td>          <td class="paramname"><span class="paramname"><em>_update_action</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over a map with the possibility of erasing elements, passing second. </p>
<p>Iterates over <em class="arg">_map</em>, applying <em class="arg">_update_action</em> to the mapped object of each element. If <em class="arg">_update_action</em> returns <a class="el" href="#ggae4ce0de10b9325cb541efbe130708189a0f6969d7052da9261e31ddb6e88c136e" title="Remove the element.">fcppt::algorithm::update_action::remove</a>, the element is removed from the map.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Map</td><td>A map-like container.</td></tr>
    <tr><td class="paramname">UpdateAction</td><td>A function callable as <code><a class="el" href="#gae4ce0de10b9325cb541efbe130708189" title="Update action for container iteration.">fcppt::algorithm::update_action</a> (Map::mapped_type)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf18146a01a1a7c2a57e1e086795ba1d3" name="gaf18146a01a1a7c2a57e1e086795ba1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf18146a01a1a7c2a57e1e086795ba1d3">&#9670;&#160;</a></span>map_optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetContainer, typename Source, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TargetContainer fcppt::algorithm::map_optional </td>
          <td>(</td>
          <td class="paramtype">Source &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function const &amp;</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a range to another container by applying a function to every element, only inserting the results that are not empty optionals. </p>
<p>For every element <em>e</em> in <em class="arg">_source</em>, <code>_function(e)</code> is called. If the result is not an empty optional, it is inserted into the result container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>Let <code>T_1,...,T_n</code> be the types of <em class="arg">SourceRange</em> and U the value type of <em class="arg">TargetContainer</em>. Then the function must be callable as <code>fcppt::optional::object&lt;U&gt;(T_i)</code> for every <code>1 &lt;= i &lt;= n</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>TODO(philipp): concepts </p>

</div>
</div>
<a id="gae9ae40e09391576605ac4478a9b5148f" name="gae9ae40e09391576605ac4478a9b5148f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ae40e09391576605ac4478a9b5148f">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::algorithm::remove </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>_container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Container::const_reference</td>          <td class="paramname"><span class="paramname"><em>_element</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all occurrences of a value from a container. </p>
<p>Removes all elements from a <code class="param">_container</code> equal to <code class="param">_element</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if something has been removed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga2f7666858dc827c1d5e139c57e2a041f" name="ga2f7666858dc827c1d5e139c57e2a041f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7666858dc827c1d5e139c57e2a041f">&#9670;&#160;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Predicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::algorithm::remove_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>_container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate const &amp;</td>          <td class="paramname"><span class="paramname"><em>_predicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from a container matching a predicate. </p>
<p>Removes all elements from <code class="param">_container</code> matching <code class="param">_predicate</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>A function callable as <code>bool (Container::value_type)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if something has been removed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga0779216dccd1d302287767fa95a9c004" name="ga0779216dccd1d302287767fa95a9c004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0779216dccd1d302287767fa95a9c004">&#9670;&#160;</a></span>remove_suffix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename String&gt; <br />
requires (<a class="el" href="../../d8/d2a/structfcppt_1_1type__traits_1_1is__string.html">fcppt::type_traits::is_string</a>&lt;String&gt;::value)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; String &gt; fcppt::algorithm::remove_suffix </td>
          <td>(</td>
          <td class="paramtype">String const &amp;</td>          <td class="paramname"><span class="paramname"><em>_string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/df1/group__fcppttypetraits.html#ga3135bdd67a067948fb87d76f1130ec7b">fcppt::type_traits::size_type</a>&lt; String &gt; const</td>          <td class="paramname"><span class="paramname"><em>_length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a suffix of a string. </p>
<p>If the input string <em class="arg">_string</em> has at least <em class="arg">_length</em> characters, then the suffix of size <em class="arg">_length</em> is removed. Otherwise, the empty optional is returned. </p>

</div>
</div>
<a id="ga8b3f2a87ab492d24136ac36b9a6ce21c" name="ga8b3f2a87ab492d24136ac36b9a6ce21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b3f2a87ab492d24136ac36b9a6ce21c">&#9670;&#160;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Count, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::algorithm::repeat </td>
          <td>(</td>
          <td class="paramtype">Count const</td>          <td class="paramname"><span class="paramname"><em>_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function const &amp;</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a function a number of times. </p>
<p>Calls <em class="arg">_function</em> <em class="arg">_count</em> times.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Count</td><td>An integer type</td></tr>
    <tr><td class="paramname">Function</td><td>A function callable as <code>void ()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeade55885acd3b7c7bbb7787d473f95e" name="gaeade55885acd3b7c7bbb7787d473f95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeade55885acd3b7c7bbb7787d473f95e">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; Container &gt; fcppt::algorithm::reverse </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_container</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses a container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Must be a bidirectional container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8986dd750e21b92cdd489a4b1233b742" name="ga8986dd750e21b92cdd489a4b1233b742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8986dd750e21b92cdd489a4b1233b742">&#9670;&#160;</a></span>sequence_iteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sequence, typename UpdateAction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::algorithm::sequence_iteration </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;</td>          <td class="paramname"><span class="paramname"><em>_sequence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpdateAction const &amp;</td>          <td class="paramname"><span class="paramname"><em>_update_action</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over a sequence with the possibility of erasing elements. </p>
<p>Iterates over <em class="arg">_sequence</em>, applying <em class="arg">_update_action</em> to each element. If <em class="arg">_update_action</em> returns <a class="el" href="#ggae4ce0de10b9325cb541efbe130708189a0f6969d7052da9261e31ddb6e88c136e" title="Remove the element.">fcppt::algorithm::update_action::remove</a>, the element is removed from the sequence.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UpdateAction</td><td>A function callable as <code><a class="el" href="#gae4ce0de10b9325cb541efbe130708189" title="Update action for container iteration.">fcppt::algorithm::update_action</a> (Sequence::value_type)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5f2499f640a5fc48e2dc414c58df03e" name="gac5f2499f640a5fc48e2dc414c58df03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5f2499f640a5fc48e2dc414c58df03e">&#9670;&#160;</a></span>split_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename String&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; String &gt; fcppt::algorithm::split_string </td>
          <td>(</td>
          <td class="paramtype">String const &amp;</td>          <td class="paramname"><span class="paramname"><em>_string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/df1/group__fcppttypetraits.html#ga2e84f11147fb74d6c7b1be3068339df9">fcppt::type_traits::value_type</a>&lt; String &gt; const</td>          <td class="paramname"><span class="paramname"><em>_delim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string, using a delimiter. </p>
<p>Let <picture><source srcset="../../form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \mathrm{\_string} = (c_1, \dots , c_n)$" src="../../form_0.png"/></picture>, where <picture><source srcset="../../form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ n \ge 0 $" src="../../form_1.png"/></picture> and <picture><source srcset="../../form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ p_1 &lt; \dots &lt; p_m $" src="../../form_2.png"/></picture>, where <picture><source srcset="../../form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ m \ge 0 $" src="../../form_3.png"/></picture>, be the positions of <em class="arg">_string</em> with value <em class="arg">_delim</em>. Also, let <picture><source srcset="../../form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ p_{m+1} = \mathrm{\_string.size()}$" src="../../form_4.png"/></picture>. The result is   </p><p class="formulaDsp">
<picture><source srcset="../../form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\&zwj;[ (\mathrm{\_string}[0,p_1-1], \mathrm{\_string}[p_1+1,p_2-1], \dots,
\mathrm{\_string}[p_m+1,p_{m+1}-1). \&zwj;]" src="../../form_5.png"/></picture>
</p>
<p> Note that in case m is 0, the string itself is returned as a single element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">String</td><td>Must be a container, constructible with a pair of iterators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d5d765bf4a8c94e6cf0423285fcf5a8" name="ga6d5d765bf4a8c94e6cf0423285fcf5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d5d765bf4a8c94e6cf0423285fcf5a8">&#9670;&#160;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::algorithm::unique </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>_container</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes duplicate elements from a container. </p>
<p>Removes duplicate elements from <code class="param">_container</code>. </p>

</div>
</div>
<a id="gabbf00262155ebd08ace46e194cf83894" name="gabbf00262155ebd08ace46e194cf83894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbf00262155ebd08ace46e194cf83894">&#9670;&#160;</a></span>unique_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename BinaryPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::algorithm::unique_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>_container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate const &amp;</td>          <td class="paramname"><span class="paramname"><em>_predicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes duplicate elements from a container. Compares using a predicate. </p>
<p>Removes duplicate elements from <code class="param">_container</code>. Elements are compared using <code class="param">_predicate</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryPredicate</td><td>A function callable as <code>bool (Container::value_type,
Container::value_type)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for fcppt by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</body>
</html>
