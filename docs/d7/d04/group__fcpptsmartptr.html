<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fcppt: fcppt.smart_pointers</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname"><span id="projectnumber">&#160;5.0.0</span>
   </div>
   <div id="projectbrief">Freundlich&#39;s C++ toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fcppt.smart_pointers <div class="ingroups"><a class="el" href="../../df/df4/group__fcpptmain.html">fcppt</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Description</h2>
<p>unique_ptr, shared_ptr and weak_ptr without default constructors. </p>
<table id="toc">
<tr>
<td><p class="starttd"></p>
<ul>
<li>
<a class="el" href="#smartptr_introduction">Introduction</a> </li>
<li>
<a class="el" href="#smartptr_types">Smart pointer types</a> </li>
<li>
<a class="el" href="#smartptr_shared_ptr">Shared Pointers</a> <ul>
<li>
<a class="el" href="#smartptr_shared_ptr_make_shared">Using make_shared</a> </li>
<li>
<a class="el" href="#smartptr_shared_ptr_weak_ptr">Weak Pointers</a> </li>
<li>
<a class="el" href="#smartptr_shared_ptr_casts">Casting Shared Pointers</a> </li>
</ul>
</li>
<li>
<a class="el" href="#smartptr_unique_ptr">Unique Pointers</a> <ul>
<li>
<a class="el" href="#smartptr_unique_ptr_usage">Using Unique Pointers</a> </li>
<li>
<a class="el" href="#smartptr_unique_ptr_move">Moving Unique Pointers</a> </li>
<li>
<a class="el" href="#smartptr_unique_ptr_convert">Converting Unique Pointers</a> </li>
<li>
<a class="el" href="#smartptr_unique_ptr_const">Const Unique Pointers</a> </li>
<li>
<a class="el" href="#smartptr_unique_ptr_pimpl">Unique Pointers and Pimpl</a> </li>
</ul>
</li>
<li>
<a class="el" href="#smartptr_deleter">Custom Deleters</a> <ul>
<li>
<a class="el" href="#smartptr_deleter_predef">fcppt's Deleters</a> </li>
<li>
<a class="el" href="#smartptr_deleter_example">Deleter example</a> </li>
</ul>
</li>
<li>
<a class="el" href="#smartptr_headers">Header files</a> </li>
</ul>
<p class="endtd"></p>
</td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="smartptr_introduction"></a>
Introduction</h1>
<p>A smart pointer is a class that takes ownership over a pointer, freeing the object pointed to when the smart pointer is destroyed. Such a smart pointer resides on the stack, so freeing is done automatically.</p>
<p>fcppt provides all smart pointers that are also in C++11 with the following changes: </p><ul>
<li>
fcppt's smart pointers do not have a default constructor and are not meant to be used as null pointers. Instead, <a class="el" href="../../d9/dbf/namespacefcppt_1_1optional.html">fcppt::optional</a> should be used. </li>
<li>
Deleters are template parameters for all smart pointers. This is a trade-off and removes some of the dynamic behaviour, switching it for a statically type-safe one. </li>
<li>
Deleters do not use template parameters of their own. If a smart pointer is convertible to another smart pointer solely depends on the pointer type. </li>
</ul>
<h1 class="doxsection"><a class="anchor" id="smartptr_types"></a>
Smart pointer types</h1>
<p>fcppt provides three smart pointer classes, each with their own trade-offs.</p>
<table class="doxtable">
<tr>
<th>Class name</th><th>Description</th></tr>
<tr>
<td><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr</a></td><td>A move-only smart pointer that is the unique owner of an object. This should be the default choice of smart pointer.</td></tr>
<tr>
<td><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a></td><td>Manages objects using a shared count. Every shared ptr pointing to the same object increases the shared count by one. The object will only be destroyed when all shared ptrs have been destroyed.</td></tr>
<tr>
<td><a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html" title="A weak reference to an object owned by a shared pointer.">fcppt::weak_ptr</a></td><td>A weak reference to an object managed by shared ptrs. This smart pointer doesn't contribute to the shared count and can be used to observe if shared ptrs are still alive.</td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="smartptr_shared_ptr"></a>
Shared Pointers</h1>
<p>Multiple <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> that point to the same object share ownership by internally managing a shared count that counts how many shared ptrs are left. This shared count will be increased whenever a shared ptr is copied and decreased when one is destroyed.</p>
<p>For most use cases, unique ptrs should be preferred over shared ptrs.</p>
<p>The general traits of a shared ptr are as follows:</p>
<ul>
<li>
<p class="startli">Copying, destroying and assigning of shared ptrs is thread-safe. This usually means that these atomic operations are involved, making the operations a lot less cheap than they might seem.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Although the shared ptr gets its deleter as a template parameter, it does type erasure on it. This implies that the owned object does not have to be complete unless the shared ptr is constructed or dereferenced.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Because not only the shared count but also the owned object must be dynamically allocated, it is possible to put them both into the same memory block if the deleter is the default one that uses <code>delete</code>. This is done by <a class="el" href="#gac667bc480ba61c36621e1a85e8502028" title="Like std::make_shared but for fcppt::shared_ptr.">fcppt::make_shared_ptr</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An <a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html" title="A weak reference to an object owned by a shared pointer.">fcppt::weak_ptr</a> can be used to keep track of the shared ptrs to one object without contributing to the shared count. This way it is possible to observe if shared ptrs are still alive.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Casting shared pointers must be done through special functions, so that the shared count between them is preserved.</p>
<p class="endli"></p>
</li>
</ul>
<p>Here is a simple example using shared pointers.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>int_ptr = <a class="code hl_class" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr&lt;int&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Objects of this class should share ownership of int_ptrs</span></div>
<div class="line"><span class="keyword">class </span>owner</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> owner(int_ptr _ptr) : ptr_{std::move(_ptr)} {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  int_ptr ptr_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> shared_ptr_example()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Creates a shared_ptr</span></div>
<div class="line">  int_ptr <span class="keyword">const</span> ptr{<span class="keyword">new</span> int(42)};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Copies the ownership to owner1, increasing the shared count to 2</span></div>
<div class="line">  owner <span class="keyword">const</span> owner1{ptr};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Copies from owner1 to owner2, increasing the shared count to 3</span></div>
<div class="line">  owner <span class="keyword">const</span> owner2{<span class="comment">// NOLINT(performance-unnecessary-copy-initialization)</span></div>
<div class="line">               owner1};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The destruction of owner2, owner1 and ptr will free the int</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="smartptr_shared_ptr_make_shared"></a>
Using make_shared</h2>
<p><a class="el" href="#gac667bc480ba61c36621e1a85e8502028" title="Like std::make_shared but for fcppt::shared_ptr.">fcppt::make_shared_ptr</a> can be used to place an object allocated via new into the same memory block as the shared count managed by the shared ptrs. Another reason to use this function is to avoid memory leaks, that can happen due to C++'s unspecified order of evaluation, if you are not careful.</p>
<p>Here is an example of how not using <a class="el" href="#gac667bc480ba61c36621e1a85e8502028" title="Like std::make_shared but for fcppt::shared_ptr.">fcppt::make_shared_ptr</a> can lead to a memory leak.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// Create a function that takes ownership of an int_ptr, but also takes another</span></div>
<div class="line"><span class="comment">// argument.</span></div>
<div class="line"><span class="keywordtype">void</span> take_pointer(int_ptr &amp;&amp;, <span class="keywordtype">bool</span>) <span class="comment">// NOLINT(cppcoreguidelines-rvalue-reference-param-not-moved)</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function will be used to provide a bool value for take_pointer, but it</span></div>
<div class="line"><span class="comment">// throws when executed.</span></div>
<div class="line">[[noreturn]] <span class="keywordtype">bool</span> throw_something() { <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;test&quot;</span>); }</div>
<div class="line"> </div>
<div class="line">[[noreturn]] <span class="keywordtype">void</span> wrong()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// The order in which function arguments and their sub-expressions are</span></div>
<div class="line">  <span class="comment">// evaluated is unspecified. So it might be possible that they are</span></div>
<div class="line">  <span class="comment">// evaluated as follows:</span></div>
<div class="line">  <span class="comment">// a) new int(1)</span></div>
<div class="line">  <span class="comment">// b) throw_something()</span></div>
<div class="line">  <span class="comment">// c) int_ptr(...) is never reached and we have a leak</span></div>
<div class="line">  take_pointer(int_ptr(<span class="keyword">new</span> <span class="keywordtype">int</span>(1)), throw_something());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using <a class="el" href="#gac667bc480ba61c36621e1a85e8502028" title="Like std::make_shared but for fcppt::shared_ptr.">fcppt::make_shared_ptr</a> eliminates this problem and also makes the dynamic memory management of the shared ptrs more efficient.</p>
<div class="fragment"><div class="line">[[noreturn]] <span class="keywordtype">void</span> <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#gaa905a38e748c1bb7111960bf92f2cb86" title="The right result type of a sum parser.">right</a>() { take_pointer(<a class="code hl_function" href="#gac667bc480ba61c36621e1a85e8502028" title="Like std::make_shared but for fcppt::shared_ptr.">fcppt::make_shared_ptr&lt;int&gt;</a>(1), throw_something()); }</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="smartptr_shared_ptr_weak_ptr"></a>
Weak Pointers</h2>
<p>A weak pointer can be used to keep track of the shared ptrs to one object without contributing to the shared count. We can then observe if a shared ptr is still alive. This can also be used to break cycles.</p>
<p>A weak ptr can be used as follows:</p>
<div class="fragment"><div class="line">  <span class="keyword">using </span>weak_int_ptr = <a class="code hl_class" href="../../df/d4b/classfcppt_1_1weak__ptr.html" title="A weak reference to an object owned by a shared pointer.">fcppt::weak_ptr&lt;int&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span>shared_int_ptr = <a class="code hl_class" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr&lt;int&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  weak_int_ptr weak_p{};</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    shared_int_ptr <span class="keyword">const</span> int_ptr(<a class="code hl_function" href="#gac667bc480ba61c36621e1a85e8502028" title="Like std::make_shared but for fcppt::shared_ptr.">fcppt::make_shared_ptr&lt;int&gt;</a>(1));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a weak_ptr to the shared_ptr</span></div>
<div class="line">    weak_p = weak_int_ptr{int_ptr};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (weak_p.lock().has_value())</div>
<div class="line">    {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;A shared ptr is still alive.\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Observe if a shared_ptr is still alive. At this point, no</span></div>
<div class="line">  <span class="comment">// shared_ptr is alive.</span></div>
<div class="line">  <span class="keywordflow">if</span> (!weak_p.lock().has_value())</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;No shared ptrs are alive.\n&quot;</span>;</div>
<div class="line">  }</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="smartptr_shared_ptr_casts"></a>
Casting Shared Pointers</h2>
<p>When casting shared ptrs, using <code>static_cast</code>, <code>dynamic_cast</code> or <code>const_cast</code> directly will not work, because the shared count will not be preserved. Instead, we have to use one of the special functions <a class="el" href="#gabf98d5596107ea82f7f5ea259eb56946" title="Casts an fcppt::shared_ptr using static_cast">fcppt::static_pointer_cast</a>, <a class="el" href="#gaa1a524dc8266348fe76731e79bb07cc8" title="Casts an fcppt::shared_ptr using dynamic_cast">fcppt::dynamic_pointer_cast</a> or <a class="el" href="#gacb0b5a104286010972acb57f61f1bf64" title="Casts an fcppt::shared_ptr using const_cast">fcppt::const_pointer_cast</a>.</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(base);</div>
<div class="line"> </div>
<div class="line">  base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> ~base() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived);</div>
<div class="line"> </div>
<div class="line">  derived() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> cast()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>base_ptr = <a class="code hl_class" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr&lt;base&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  base_ptr <span class="keyword">const</span> ptr{<span class="keyword">new</span> derived()};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span>derived_ptr = <a class="code hl_class" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr&lt;derived&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::object&lt;derived_ptr&gt;</a> <span class="keyword">const</span> dptr{<a class="code hl_function" href="#gaa1a524dc8266348fe76731e79bb07cc8" title="Casts an fcppt::shared_ptr using dynamic_cast">fcppt::dynamic_pointer_cast&lt;derived&gt;</a>(ptr)};</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (dptr.<a class="code hl_function" href="../../da/d72/classfcppt_1_1optional_1_1object.html#ac670dc7c39fb7a7fb40281de35f1760e" title="Returns whether the optional holds a value.">has_value</a>())</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ptr points to a derived.\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="smartptr_unique_ptr"></a>
Unique Pointers</h1>
<p>In contrast to a shared ptr, a unique ptr always is the sole owner of an object.</p>
<p>The general traits of a unique ptr are as follows:</p>
<ul>
<li>
<p class="startli">Unique ptrs cannot be copied or assigned. Instead, they must be <em>moved</em>, which takes the ownership away from the original owner. This also means that the moved-from object will become the null pointer, so it should not be dereferenced.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Unique ptrs don't use type erasure for their deleter. This means that when constructing, copying, assigning, destroying or dereferencing unique ptrs, the type of the pointed to object must usually be complete (this depends on the deleter used).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">fcppt::make_unique_ptr</a> should be used to construct unique ptrs. It is similar to <a class="el" href="#gac667bc480ba61c36621e1a85e8502028" title="Like std::make_shared but for fcppt::shared_ptr.">fcppt::make_shared_ptr</a> in the sense that it helps to avoid memory leaks, but it is not more efficient than normal construction of unique ptrs, because there is no shared count to keep track of.</p>
<p class="endli"></p>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="smartptr_unique_ptr_usage"></a>
Using Unique Pointers</h2>
<p>The first thing to note is that unique ptrs are an excellent candidate for factory functions. They don't impose overly strict ownership requirements like shared ptr does. However, unique ptrs can be converted into shared ptrs as desired. The following example shows how such a factory can be created.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>unique_int_ptr = <a class="code hl_class" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr&lt;int&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a unique_ptr factory</span></div>
<div class="line">unique_int_ptr int_ptr_factory()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// make_unique_ptr is a factory function to make a unique_ptr An</span></div>
<div class="line">  <span class="comment">// rvalue is returned here, so no moving is necessary.</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">fcppt::make_unique_ptr&lt;int&gt;</a>(1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The return of <code>make_unique_ptr</code> doesn't require a move, because it returns an rvalue.</p>
<p>The factory can be used as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// NOLINTNEXTLINE(cppcoreguidelines-rvalue-reference-param-not-moved)</span></div>
<div class="line"><span class="keywordtype">void</span> int_ptr_arg(unique_int_ptr &amp;&amp;ptr) { std::cout &lt;&lt; *ptr &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="../../d9/dc7/group__fcpptbit.html#ga41f7fc23cce7a254fe1b15ce727e30d8" title="Tests a value against a bit mask.">test</a>() { int_ptr_arg(int_ptr_factory()); }</div>
</div><!-- fragment --><p>Again, there is no move required because the factory also returns an rvalue.</p>
<h2 class="doxsection"><a class="anchor" id="smartptr_unique_ptr_move"></a>
Moving Unique Pointers</h2>
<p>The next example shows when a move is required. This is generally true when an lvalue is involved (which means a named object here). The reason for this is to ensure that a unique ptr doesn't accidentally get its object disowned.</p>
<div class="fragment"><div class="line">unique_int_ptr test2()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ptr is a named object</span></div>
<div class="line">  unique_int_ptr ptr(<a class="code hl_function" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">fcppt::make_unique_ptr&lt;int&gt;</a>(1));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ptr must be moved here to take ownership away from it</span></div>
<div class="line">  <span class="keywordflow">return</span> ptr;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Consider the following example where an implicit move would be very dangerous:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test3()</div>
<div class="line">{</div>
<div class="line">  unique_int_ptr ptr(<a class="code hl_function" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">fcppt::make_unique_ptr&lt;int&gt;</a>(1));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Implicit move is not allowed</span></div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  int_ptr_arg(ptr       );</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Make the move explicit</span></div>
<div class="line">  int_ptr_arg(std::move(ptr));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ptr is now the null pointer</span></div>
<div class="line">  std::cout &lt;&lt; ptr.get_pointer() <span class="comment">// NOLINT(bugprone-use-after-move,hicpp-invalid-access-moved)</span></div>
<div class="line">            &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="smartptr_unique_ptr_convert"></a>
Converting Unique Pointers</h2>
<p>Unique pointers are not implicitly convertible to any other unique pointers. To convert a unique pointer to a unique pointer to base, use <a class="el" href="#ga2e60789ea0976586c051646157534baa" title="Casts a unique_ptr to a base class.">fcppt::unique_ptr_to_base</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(base);</div>
<div class="line"> </div>
<div class="line">  base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> ~base() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived);</div>
<div class="line"> </div>
<div class="line">  derived() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test4()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>base_ptr = <a class="code hl_class" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr&lt;base&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  base_ptr <span class="keyword">const</span> foo{<a class="code hl_function" href="#ga2e60789ea0976586c051646157534baa" title="Casts a unique_ptr to a base class.">fcppt::unique_ptr_to_base&lt;base&gt;</a>(<a class="code hl_function" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">fcppt::make_unique_ptr&lt;derived&gt;</a>())};</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similarly, <a class="el" href="#ga45f26ea548d8ffbe7a832342108260d4" title="Casts a unique_ptr to a const unique_ptr.">fcppt::unique_ptr_to_const</a> must be used to obtain a unique pointer to a const object.</p>
<div class="fragment"><div class="line">  <span class="keyword">using </span>const_int_ptr = <a class="code hl_class" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr&lt;int const&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  const_int_ptr <span class="keyword">const</span> foo{<a class="code hl_function" href="#ga45f26ea548d8ffbe7a832342108260d4" title="Casts a unique_ptr to a const unique_ptr.">fcppt::unique_ptr_to_const</a>(<a class="code hl_function" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">fcppt::make_unique_ptr&lt;int&gt;</a>(1))};</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="smartptr_unique_ptr_const"></a>
Const Unique Pointers</h2>
<p>fcppt used to provide a scoped_ptr class similar to <code>boost::scoped_ptr</code> that additionally took a deleter. This class has been removed in favor of const unique ptrs.</p>
<div class="fragment"><div class="line">  <span class="keyword">using </span>scoped_int_ptr = <a class="code hl_class" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr&lt;int const&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  scoped_int_ptr <span class="keyword">const</span> ptr(<a class="code hl_function" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">fcppt::make_unique_ptr&lt;int const&gt;</a>(1));</div>
</div><!-- fragment --><p>A unique ptr that has been declared const cannot be copied nor moved. Additionally, it can also not be swapped.</p>
<h2 class="doxsection"><a class="anchor" id="smartptr_unique_ptr_pimpl"></a>
Unique Pointers and Pimpl</h2>
<p>A unique ptr can also be used to implement the pimpl idiom. When a unique ptr object is defined, the pointed to object doesn't need to be complete. It only has to be complete when the destructor of the unique ptr is instantiated. Therefore, an implementation can be hidden by using unique ptrs as shown in the following example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>foo_impl;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>foo</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Explicitly disable copying and moving</span></div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(foo);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  foo();</div>
<div class="line"> </div>
<div class="line">  ~foo();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)</span></div>
<div class="line">  fcppt::unique_ptr&lt;foo_impl&gt; <span class="keyword">const</span> impl_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Because <code>foo</code> has an explicitly declared destructor, the destruction of the implementation can be hidden in a source file.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>foo_impl</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Something here</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">foo::foo() : impl_(<a class="code hl_namespace" href="../../dc/dfd/namespacefcppt.html" title="The top level namespace.">fcppt</a>::<a class="code hl_function" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">make_unique_ptr</a>&lt;foo_impl&gt;()) {}</div>
<div class="line"> </div>
<div class="line">foo::~foo() = <span class="keywordflow">default</span>;</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="smartptr_deleter"></a>
Custom Deleters</h1>
<p>As previously mentioned, fcppt's smart pointers all take the deleter as a template parameter in order to ensure maximum type safety. Such a deleter must have the following properties:</p>
<p>For some smart pointer over type <code>Type</code> the deleter must be callable with an expression of type <code>Type *</code>. The deleter must ensure to destroy the object if it is not a null pointer.</p>
<h2 class="doxsection"><a class="anchor" id="smartptr_deleter_predef"></a>
fcppt's Deleters</h2>
<p>fcppt predefines several deleters:</p>
<p>For some invented variable name <code>ptr</code> of type <code>Type *</code> their semantics are as follows:</p>
<table class="doxtable">
<tr>
<td><a class="el" href="../../d5/d68/structfcppt_1_1default__deleter.html" title="A deleter that uses delete to destroy an object.">fcppt::default_deleter</a> </td><td><code>delete ptr;</code> </td></tr>
<tr>
<td><a class="el" href="../../df/db6/structfcppt_1_1c__deleter.html" title="A deleter that uses std::free to destroy an object.">fcppt::c_deleter</a> </td><td><code>std::free(ptr);</code> </td></tr>
<tr>
<td><a class="el" href="../../d5/dc3/structfcppt_1_1com__deleter.html" title="A deleter that uses the Release member function to destroy an object.">fcppt::com_deleter</a> </td><td><code>if(ptr) ptr-&gt;Release();</code> </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="smartptr_deleter_example"></a>
Deleter example</h2>
<p>The following example shows how <a class="el" href="../../df/db6/structfcppt_1_1c__deleter.html" title="A deleter that uses std::free to destroy an object.">fcppt::c_deleter</a> can be used to free memory allocated via <code>std::malloc</code></p>
<div class="fragment"><div class="line">  <span class="keyword">using </span>void_c_ptr = <a class="code hl_class" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr&lt;void, fcppt::c_deleter&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  void_c_ptr <span class="keyword">const</span> ptr{ <span class="comment">// NOLINT(clang-analyzer-unix.Malloc)</span></div>
<div class="line">      <span class="comment">// NOLINTNEXTLINE(cppcoreguidelines-no-malloc,hicpp-no-malloc)</span></div>
<div class="line">      std::malloc(100)};</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="smartptr_headers"></a>
Header files</h1>
<table class="doxtable">
<tr>
<th>Header file</th><th>Description</th></tr>
<tr>
<td><code>c_deleter.hpp</code></td><td>Contains <a class="el" href="../../df/db6/structfcppt_1_1c__deleter.html" title="A deleter that uses std::free to destroy an object.">fcppt::c_deleter</a>.</td></tr>
<tr>
<td><code>com_deleter.hpp</code></td><td>Contains <a class="el" href="../../d5/dc3/structfcppt_1_1com__deleter.html" title="A deleter that uses the Release member function to destroy an object.">fcppt::com_deleter</a>.</td></tr>
<tr>
<td><code>const_pointer_cast.hpp</code></td><td>Contains <a class="el" href="#gacb0b5a104286010972acb57f61f1bf64" title="Casts an fcppt::shared_ptr using const_cast">fcppt::const_pointer_cast</a>.</td></tr>
<tr>
<td><code>default_deleter.hpp</code></td><td>Contains <a class="el" href="../../d5/d68/structfcppt_1_1default__deleter.html" title="A deleter that uses delete to destroy an object.">fcppt::default_deleter</a>.</td></tr>
<tr>
<td><code>dynamic_pointer_cast.hpp</code></td><td>Contains <a class="el" href="#gaa1a524dc8266348fe76731e79bb07cc8" title="Casts an fcppt::shared_ptr using dynamic_cast">fcppt::dynamic_pointer_cast</a>.</td></tr>
<tr>
<td><code>make_shared_ptr.hpp</code></td><td>Contains <a class="el" href="#gac667bc480ba61c36621e1a85e8502028" title="Like std::make_shared but for fcppt::shared_ptr.">fcppt::make_shared_ptr</a>.</td></tr>
<tr>
<td><code>make_unique_ptr.hpp</code></td><td>Contains <a class="el" href="#ga7a10d5eaec71ed11987ae3c4b6f84610" title="Like std::make_unique for fcppt::unique_ptr.">fcppt::make_unique_ptr</a>.</td></tr>
<tr>
<td><code>shared_ptr_fwd.hpp</code></td><td>Contains <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a>'s declaration.</td></tr>
<tr>
<td><code>shared_ptr_decl.hpp</code></td><td>Contains <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a>'s definition.</td></tr>
<tr>
<td><code>shared_ptr_impl.hpp</code></td><td>Contains the definition of <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a>'s member functions.</td></tr>
<tr>
<td><code>shared_ptr.hpp</code></td><td>The same as <code>shared_ptr_impl.hpp</code></td></tr>
<tr>
<td><code>static_pointer_cast.hpp</code></td><td>Contains <a class="el" href="#gabf98d5596107ea82f7f5ea259eb56946" title="Casts an fcppt::shared_ptr using static_cast">fcppt::static_pointer_cast</a></td></tr>
<tr>
<td><code>unique_ptr_fwd.hpp</code></td><td>Contains <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr</a>'s declaration.</td></tr>
<tr>
<td><code>unique_ptr_decl.hpp</code></td><td>Contains <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr</a>'s definition.</td></tr>
<tr>
<td><code>unique_ptr_impl.hpp</code></td><td>Contains the definition of <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr</a>'s member functions.</td></tr>
<tr>
<td><code>unique_ptr.hpp</code></td><td>The same as <code>unique_ptr_impl.hpp</code></td></tr>
<tr>
<td><code>unique_ptr_to_base.hpp</code></td><td>Contains <a class="el" href="#ga2e60789ea0976586c051646157534baa" title="Casts a unique_ptr to a base class.">fcppt::unique_ptr_to_base</a>.</td></tr>
<tr>
<td><code>unique_ptr_to_const.hpp</code></td><td>Contains <a class="el" href="#ga45f26ea548d8ffbe7a832342108260d4" title="Casts a unique_ptr to a const unique_ptr.">fcppt::unique_ptr_to_const</a>.</td></tr>
<tr>
<td><code>weak_ptr_fwd.hpp</code></td><td>Contains <a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html" title="A weak reference to an object owned by a shared pointer.">fcppt::weak_ptr</a>'s declaration.</td></tr>
<tr>
<td><code>weak_ptr_decl.hpp</code></td><td>Contains <a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html" title="A weak reference to an object owned by a shared pointer.">fcppt::weak_ptr</a>'s definition.</td></tr>
<tr>
<td><code>weak_ptr_impl.hpp</code></td><td>Contains the definition of <a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html" title="A weak reference to an object owned by a shared pointer.">fcppt::weak_ptr</a>'s member functions.</td></tr>
<tr>
<td><code>weak_ptr.hpp</code></td><td>The same as <code>weak_ptr_impl.hpp</code></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:fcppt_3A_3Ac_5Fdeleter" id="r_fcppt_3A_3Ac_5Fdeleter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db6/structfcppt_1_1c__deleter.html">fcppt::c_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter that uses <code>std::free</code> to destroy an object.  <a href="../../df/db6/structfcppt_1_1c__deleter.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Acom_5Fdeleter" id="r_fcppt_3A_3Acom_5Fdeleter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc3/structfcppt_1_1com__deleter.html">fcppt::com_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter that uses the <code>Release</code> member function to destroy an object.  <a href="../../d5/dc3/structfcppt_1_1com__deleter.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Adefault_5Fdeleter" id="r_fcppt_3A_3Adefault_5Fdeleter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d68/structfcppt_1_1default__deleter.html">fcppt::default_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter that uses <code>delete</code> to destroy an object.  <a href="../../d5/d68/structfcppt_1_1default__deleter.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Aenable_5Fshared_5Ffrom_5Fthis_3C_20Type_20_3E" id="r_fcppt_3A_3Aenable_5Fshared_5Ffrom_5Fthis_3C_20Type_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5a/classfcppt_1_1enable__shared__from__this.html">fcppt::enable_shared_from_this&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows an object to obtain a shared ptr to itself.  <a href="../../d0/d5a/classfcppt_1_1enable__shared__from__this.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Ais_5Funique_5Fptr_3C_20Type_20_3E" id="r_fcppt_3A_3Ais_5Funique_5Fptr_3C_20Type_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d80/structfcppt_1_1is__unique__ptr.html">fcppt::is_unique_ptr&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a type is an <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr</a>.  <a href="../../db/d80/structfcppt_1_1is__unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Ashared_5Fptr_3C_20Type_2C_20Deleter_20_3E" id="r_fcppt_3A_3Ashared_5Fptr_3C_20Type_2C_20Deleter_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr&lt; Type, Deleter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shared pointer class that gets the deleter as a template parameter.  <a href="../../d2/d6b/classfcppt_1_1shared__ptr.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Ashared_5Fptr_5Fhash_3C_20fcppt_3A_3Ashared_5Fptr_3C_20Type_20_3E_20_3E" id="r_fcppt_3A_3Ashared_5Fptr_5Fhash_3C_20fcppt_3A_3Ashared_5Fptr_3C_20Type_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d88/structfcppt_1_1shared__ptr__hash_3_01fcppt_1_1shared__ptr_3_01Type_01_4_01_4.html">fcppt::shared_ptr_hash&lt; fcppt::shared_ptr&lt; Type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash for <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> that hashes pointers.  <a href="../../d5/d88/structfcppt_1_1shared__ptr__hash_3_01fcppt_1_1shared__ptr_3_01Type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Aunique_5Fptr_3C_20Type_2C_20Deleter_20_3E" id="r_fcppt_3A_3Aunique_5Fptr_3C_20Type_2C_20Deleter_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr&lt; Type, Deleter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simpler <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a> that shouldn't be used as a null pointer.  <a href="../../d3/dc8/classfcppt_1_1unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Aweak_5Fptr_3C_20Type_2C_20Deleter_20_3E" id="r_fcppt_3A_3Aweak_5Fptr_3C_20Type_2C_20Deleter_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr&lt; Type, Deleter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A weak reference to an object owned by a shared pointer.  <a href="../../df/d4b/classfcppt_1_1weak__ptr.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacb0b5a104286010972acb57f61f1bf64" id="r_gacb0b5a104286010972acb57f61f1bf64"><td class="memTemplParams" colspan="2">template&lt;typename Dest, typename Source&gt; </td></tr>
<tr class="memitem:gacb0b5a104286010972acb57f61f1bf64 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Dest &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb0b5a104286010972acb57f61f1bf64">fcppt::const_pointer_cast</a> (<a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Source const &gt; const &amp;_ptr)</td></tr>
<tr class="memdesc:gacb0b5a104286010972acb57f61f1bf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> using <code>const_cast</code>  <br /></td></tr>
<tr class="memitem:gaa1a524dc8266348fe76731e79bb07cc8" id="r_gaa1a524dc8266348fe76731e79bb07cc8"><td class="memTemplParams" colspan="2">template&lt;typename Dest, typename Source&gt; </td></tr>
<tr class="memitem:gaa1a524dc8266348fe76731e79bb07cc8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Dest &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1a524dc8266348fe76731e79bb07cc8">fcppt::dynamic_pointer_cast</a> (<a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Source &gt; const &amp;_ptr)</td></tr>
<tr class="memdesc:gaa1a524dc8266348fe76731e79bb07cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> using <code>dynamic_cast</code>  <br /></td></tr>
<tr class="memitem:gac667bc480ba61c36621e1a85e8502028" id="r_gac667bc480ba61c36621e1a85e8502028"><td class="memTemplParams" colspan="2">template&lt;typename Res, typename... Args&gt; </td></tr>
<tr class="memitem:gac667bc480ba61c36621e1a85e8502028 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Res &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac667bc480ba61c36621e1a85e8502028">fcppt::make_shared_ptr</a> (Args &amp;&amp;..._args)</td></tr>
<tr class="memdesc:gac667bc480ba61c36621e1a85e8502028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>std::make_shared</code> but for <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a>.  <br /></td></tr>
<tr class="memitem:ga7a10d5eaec71ed11987ae3c4b6f84610" id="r_ga7a10d5eaec71ed11987ae3c4b6f84610"><td class="memTemplParams" colspan="2">template&lt;typename Res, typename... Args&gt; </td></tr>
<tr class="memitem:ga7a10d5eaec71ed11987ae3c4b6f84610 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Res &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a10d5eaec71ed11987ae3c4b6f84610">fcppt::make_unique_ptr</a> (Args &amp;&amp;..._args)</td></tr>
<tr class="memdesc:ga7a10d5eaec71ed11987ae3c4b6f84610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>std::make_unique</code> for <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr</a>.  <br /></td></tr>
<tr class="memitem:gac90e50479c7f446a59d5ea66c519a91a" id="r_gac90e50479c7f446a59d5ea66c519a91a"><td class="memTemplParams" colspan="2">template&lt;typename Type1, typename Type2, typename Deleter&gt; </td></tr>
<tr class="memitem:gac90e50479c7f446a59d5ea66c519a91a template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac90e50479c7f446a59d5ea66c519a91a">fcppt::operator==</a> (<a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type1, Deleter &gt; const &amp;left, <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type2, Deleter &gt; const &amp;right)</td></tr>
<tr class="memdesc:gac90e50479c7f446a59d5ea66c519a91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two shared ptrs for equality.  <br /></td></tr>
<tr class="memitem:ga051de193e35d6f2ea6d96d68d6e3784b" id="r_ga051de193e35d6f2ea6d96d68d6e3784b"><td class="memTemplParams" colspan="2">template&lt;typename Type1, typename Type2, typename Deleter&gt; </td></tr>
<tr class="memitem:ga051de193e35d6f2ea6d96d68d6e3784b template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga051de193e35d6f2ea6d96d68d6e3784b">fcppt::operator!=</a> (<a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type1, Deleter &gt; const &amp;left, <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type2, Deleter &gt; const &amp;right)</td></tr>
<tr class="memdesc:ga051de193e35d6f2ea6d96d68d6e3784b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two shared ptrs for inequality.  <br /></td></tr>
<tr class="memitem:gade748a6ed6a29a811e8fa48e5a5d7fab" id="r_gade748a6ed6a29a811e8fa48e5a5d7fab"><td class="memTemplParams" colspan="2">template&lt;typename Type1, typename Type2, typename Deleter&gt; </td></tr>
<tr class="memitem:gade748a6ed6a29a811e8fa48e5a5d7fab template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gade748a6ed6a29a811e8fa48e5a5d7fab">fcppt::operator&lt;</a> (<a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type1, Deleter &gt; const &amp;left, <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type2, Deleter &gt; const &amp;right)</td></tr>
<tr class="memdesc:gade748a6ed6a29a811e8fa48e5a5d7fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if one shared ptr is less than the other.  <br /></td></tr>
<tr class="memitem:gafddbbe7e22121dcbb241104e40d82c9c" id="r_gafddbbe7e22121dcbb241104e40d82c9c"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Deleter&gt; </td></tr>
<tr class="memitem:gafddbbe7e22121dcbb241104e40d82c9c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafddbbe7e22121dcbb241104e40d82c9c">fcppt::swap</a> (<a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type, Deleter &gt; &amp;left, <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type, Deleter &gt; &amp;right) noexcept</td></tr>
<tr class="memdesc:gafddbbe7e22121dcbb241104e40d82c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two shared pointers.  <br /></td></tr>
<tr class="memitem:ga26297bebd30953a54adb50bdd9874090" id="r_ga26297bebd30953a54adb50bdd9874090"><td class="memTemplParams" colspan="2">template&lt;typename Ch, typename Traits, typename Type, typename Deleter&gt; </td></tr>
<tr class="memitem:ga26297bebd30953a54adb50bdd9874090 template"><td class="memItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Traits &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26297bebd30953a54adb50bdd9874090">fcppt::operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Traits &gt; &amp;_stream, <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type, Deleter &gt; const &amp;_ptr)</td></tr>
<tr class="memdesc:ga26297bebd30953a54adb50bdd9874090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a shared pointer.  <br /></td></tr>
<tr class="memitem:gabf98d5596107ea82f7f5ea259eb56946" id="r_gabf98d5596107ea82f7f5ea259eb56946"><td class="memTemplParams" colspan="2">template&lt;typename Dest, typename Source&gt; </td></tr>
<tr class="memitem:gabf98d5596107ea82f7f5ea259eb56946 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Dest &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabf98d5596107ea82f7f5ea259eb56946">fcppt::static_pointer_cast</a> (<a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Source &gt; const &amp;_ptr)</td></tr>
<tr class="memdesc:gabf98d5596107ea82f7f5ea259eb56946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> using <code>static_cast</code>  <br /></td></tr>
<tr class="memitem:gafd3241c0a06e5e4ee2d093e530b3093a" id="r_gafd3241c0a06e5e4ee2d093e530b3093a"><td class="memTemplParams" colspan="2">template&lt;typename Cast, typename Derived, typename Base, typename Deleter&gt; </td></tr>
<tr class="memitem:gafd3241c0a06e5e4ee2d093e530b3093a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d29/classfcppt_1_1variant_1_1object.html">fcppt::variant::object</a>&lt; <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Derived, Deleter &gt;, <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Base, Deleter &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafd3241c0a06e5e4ee2d093e530b3093a">fcppt::unique_ptr_dynamic_cast</a> (<a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Base, Deleter &gt; &amp;&amp;_other) noexcept</td></tr>
<tr class="memdesc:gafd3241c0a06e5e4ee2d093e530b3093a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a> to a derived class.  <br /></td></tr>
<tr class="memitem:gaede6b8cff4628fe96023b414e25a75a3" id="r_gaede6b8cff4628fe96023b414e25a75a3"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:gaede6b8cff4628fe96023b414e25a75a3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaede6b8cff4628fe96023b414e25a75a3">fcppt::unique_ptr_from_std</a> (std::unique_ptr&lt; Type &gt; &amp;&amp;_ptr)</td></tr>
<tr class="memdesc:gaede6b8cff4628fe96023b414e25a75a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code>std::unique_ptr</code> to an fcppt unique ptr.  <br /></td></tr>
<tr class="memitem:ga2e60789ea0976586c051646157534baa" id="r_ga2e60789ea0976586c051646157534baa"><td class="memTemplParams" colspan="2">template&lt;typename Base, typename Derived, typename Deleter&gt; </td></tr>
<tr class="memitem:ga2e60789ea0976586c051646157534baa template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Base, Deleter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e60789ea0976586c051646157534baa">fcppt::unique_ptr_to_base</a> (<a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Derived, Deleter &gt; &amp;&amp;_other) noexcept</td></tr>
<tr class="memdesc:ga2e60789ea0976586c051646157534baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a> to a base class.  <br /></td></tr>
<tr class="memitem:ga45f26ea548d8ffbe7a832342108260d4" id="r_ga45f26ea548d8ffbe7a832342108260d4"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Deleter&gt; </td></tr>
<tr class="memitem:ga45f26ea548d8ffbe7a832342108260d4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Type const, Deleter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga45f26ea548d8ffbe7a832342108260d4">fcppt::unique_ptr_to_const</a> (<a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Type, Deleter &gt; &amp;&amp;_other) noexcept</td></tr>
<tr class="memdesc:ga45f26ea548d8ffbe7a832342108260d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a> to a const <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a>.  <br /></td></tr>
<tr class="memitem:ga028c62d863085f63486ed22da547b2c2" id="r_ga028c62d863085f63486ed22da547b2c2"><td class="memTemplParams" colspan="2">template&lt;typename Type1, typename Type2, typename Deleter&gt; </td></tr>
<tr class="memitem:ga028c62d863085f63486ed22da547b2c2 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga028c62d863085f63486ed22da547b2c2">fcppt::operator&lt;</a> (<a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr</a>&lt; Type1, Deleter &gt; const &amp;left, <a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr</a>&lt; Type2, Deleter &gt; const &amp;right) noexcept</td></tr>
<tr class="memdesc:ga028c62d863085f63486ed22da547b2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if one weak ptr is less than the other.  <br /></td></tr>
<tr class="memitem:gadaf1bdfa9e61d4448607c0c1d4f41304" id="r_gadaf1bdfa9e61d4448607c0c1d4f41304"><td class="memTemplParams" colspan="2">template&lt;typename Type, typename Deleter&gt; </td></tr>
<tr class="memitem:gadaf1bdfa9e61d4448607c0c1d4f41304 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadaf1bdfa9e61d4448607c0c1d4f41304">fcppt::swap</a> (<a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr</a>&lt; Type, Deleter &gt; &amp;left, <a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr</a>&lt; Type, Deleter &gt; &amp;right) noexcept</td></tr>
<tr class="memdesc:gadaf1bdfa9e61d4448607c0c1d4f41304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two weak pointers.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gacb0b5a104286010972acb57f61f1bf64" name="gacb0b5a104286010972acb57f61f1bf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb0b5a104286010972acb57f61f1bf64">&#9670;&#160;</a></span>const_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest, typename Source&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Dest &gt; fcppt::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Source const &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts an <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> using <code>const_cast</code> </p>
<p>Casts the pointer stored in <em class="arg">_ptr</em> to type <code>U *</code> using <code>const_cast</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dest</td><td>The type of the destination <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></td></tr>
    <tr><td class="paramname">Source</td><td>The type of the source <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ptr</td><td>The source <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a> </dd></dl>

</div>
</div>
<a id="gaa1a524dc8266348fe76731e79bb07cc8" name="gaa1a524dc8266348fe76731e79bb07cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a524dc8266348fe76731e79bb07cc8">&#9670;&#160;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest, typename Source&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Dest &gt; &gt; fcppt::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Source &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts an <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> using <code>dynamic_cast</code> </p>
<p>Casts the pointer stored in <em class="arg">_ptr</em> to type <code>U *</code> using <code>dynamic_cast</code>. This means that <code>T *</code> and <code>U
 </code> must be members of the same class hierarchy. If the cast succeeds, the resulting <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a> will share ownership with the source.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dest</td><td>The type of the destination <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></td></tr>
    <tr><td class="paramname">Source</td><td>The type of the source <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ptr</td><td>The source <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac667bc480ba61c36621e1a85e8502028" name="gac667bc480ba61c36621e1a85e8502028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac667bc480ba61c36621e1a85e8502028">&#9670;&#160;</a></span>make_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Res, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Res &gt; fcppt::make_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>_args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <code>std::make_shared</code> but for <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a>. </p>

</div>
</div>
<a id="ga7a10d5eaec71ed11987ae3c4b6f84610" name="ga7a10d5eaec71ed11987ae3c4b6f84610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a10d5eaec71ed11987ae3c4b6f84610">&#9670;&#160;</a></span>make_unique_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Res, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Res &gt; fcppt::make_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>_args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <code>std::make_unique</code> for <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr</a>. </p>

</div>
</div>
<a id="ga051de193e35d6f2ea6d96d68d6e3784b" name="ga051de193e35d6f2ea6d96d68d6e3784b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga051de193e35d6f2ea6d96d68d6e3784b">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type1, typename Type2, typename Deleter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type1, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type2, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two shared ptrs for inequality. </p>
<p>Compares <em class="arg">left</em> and <em class="arg">right</em> for inequality, comparing their pointers. Pointers to <em class="arg">Type1</em> and to <em class="arg">Type2</em> must be inequality comparable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left argument</td></tr>
    <tr><td class="paramname">right</td><td>The right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade748a6ed6a29a811e8fa48e5a5d7fab" name="gade748a6ed6a29a811e8fa48e5a5d7fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade748a6ed6a29a811e8fa48e5a5d7fab">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type1, typename Type2, typename Deleter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type1, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type2, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if one shared ptr is less than the other. </p>
<p>Checks if <em class="arg">left</em> is less than <em class="arg">right</em>, comparing their pointers with <code>std::less</code>.</p>
<p>Pointers to <em class="arg">Type1</em> and to <em class="arg">Type2</em> must be comparable using <code>std::less</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left argument</td></tr>
    <tr><td class="paramname">right</td><td>The right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga028c62d863085f63486ed22da547b2c2" name="ga028c62d863085f63486ed22da547b2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga028c62d863085f63486ed22da547b2c2">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type1, typename Type2, typename Deleter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr</a>&lt; Type1, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr</a>&lt; Type2, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if one weak ptr is less than the other. </p>
<p>Checks if <em class="arg">left</em> is less than <em class="arg">right</em>, comparing their pointers with <code>std::less</code>.</p>
<p>Pointers to <em class="arg">Type1</em> and to <em class="arg">Type2</em> must be comparable using <code>std::less</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left argument</td></tr>
    <tr><td class="paramname">right</td><td>The right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26297bebd30953a54adb50bdd9874090" name="ga26297bebd30953a54adb50bdd9874090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26297bebd30953a54adb50bdd9874090">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ch, typename Traits, typename Type, typename Deleter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Traits &gt; &amp; fcppt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Traits &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs a shared pointer. </p>
<p>Outputs <em class="arg">_ptr</em> to <em class="arg">_stream</em>.</p>
<dl class="section return"><dt>Returns</dt><dd><em class="arg">stream</em> </dd></dl>

</div>
</div>
<a id="gac90e50479c7f446a59d5ea66c519a91a" name="gac90e50479c7f446a59d5ea66c519a91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac90e50479c7f446a59d5ea66c519a91a">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type1, typename Type2, typename Deleter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type1, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type2, Deleter &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two shared ptrs for equality. </p>
<p>Compares <em class="arg">left</em> and <em class="arg">right</em> for equality, comparing their pointers. Pointers to <em class="arg">Type1</em> and to <em class="arg">Type2</em> must be equality comparable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left argument</td></tr>
    <tr><td class="paramname">right</td><td>The right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf98d5596107ea82f7f5ea259eb56946" name="gabf98d5596107ea82f7f5ea259eb56946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf98d5596107ea82f7f5ea259eb56946">&#9670;&#160;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest, typename Source&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Dest &gt; fcppt::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Source &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts an <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> using <code>static_cast</code> </p>
<p>Casts the pointer stored in <em class="arg">_ptr</em> to type <code>U *</code> using <code>static_cast</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dest</td><td>The type of the destination <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></td></tr>
    <tr><td class="paramname">Source</td><td>The type of the source <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ptr</td><td>The source <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">shared_ptr</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour is undefined if the <code>static_cast</code> is not well formed. </dd></dl>

</div>
</div>
<a id="gafddbbe7e22121dcbb241104e40d82c9c" name="gafddbbe7e22121dcbb241104e40d82c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafddbbe7e22121dcbb241104e40d82c9c">&#9670;&#160;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Deleter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type, Deleter &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html">fcppt::shared_ptr</a>&lt; Type, Deleter &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two shared pointers. </p>
<p>Swaps <em class="arg">left</em> and <em class="arg">right</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left argument</td></tr>
    <tr><td class="paramname">right</td><td>The right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadaf1bdfa9e61d4448607c0c1d4f41304" name="gadaf1bdfa9e61d4448607c0c1d4f41304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaf1bdfa9e61d4448607c0c1d4f41304">&#9670;&#160;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Deleter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr</a>&lt; Type, Deleter &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d4b/classfcppt_1_1weak__ptr.html">fcppt::weak_ptr</a>&lt; Type, Deleter &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two weak pointers. </p>
<p>Swaps <em class="arg">left</em> and <em class="arg">right</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left argument</td></tr>
    <tr><td class="paramname">right</td><td>The right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd3241c0a06e5e4ee2d093e530b3093a" name="gafd3241c0a06e5e4ee2d093e530b3093a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd3241c0a06e5e4ee2d093e530b3093a">&#9670;&#160;</a></span>unique_ptr_dynamic_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Cast, typename Derived, typename Base, typename Deleter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d29/classfcppt_1_1variant_1_1object.html">fcppt::variant::object</a>&lt; <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Derived, Deleter &gt;, <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Base, Deleter &gt; &gt; fcppt::unique_ptr_dynamic_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Base, Deleter &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a> to a derived class. </p>
<p>Tries to cast the given unique ptr to <em class="arg">Derived</em> using the cast function <em class="arg">Cast</em>. The result is either a <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a> of type <em class="arg">Derived</em>, or (if the cast fails) of type <em class="arg">Base</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Cast</td><td>A cast function from <a class="el" href="../../d6/dff/group__fcpptcasts.html">fcppt.casts</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaede6b8cff4628fe96023b414e25a75a3" name="gaede6b8cff4628fe96023b414e25a75a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaede6b8cff4628fe96023b414e25a75a3">&#9670;&#160;</a></span>unique_ptr_from_std()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Type &gt; &gt; fcppt::unique_ptr_from_std </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Type &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <code>std::unique_ptr</code> to an fcppt unique ptr. </p>

</div>
</div>
<a id="ga2e60789ea0976586c051646157534baa" name="ga2e60789ea0976586c051646157534baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e60789ea0976586c051646157534baa">&#9670;&#160;</a></span>unique_ptr_to_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base, typename Derived, typename Deleter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Base, Deleter &gt; fcppt::unique_ptr_to_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Derived, Deleter &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a> to a base class. </p>

</div>
</div>
<a id="ga45f26ea548d8ffbe7a832342108260d4" name="ga45f26ea548d8ffbe7a832342108260d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45f26ea548d8ffbe7a832342108260d4">&#9670;&#160;</a></span>unique_ptr_to_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, typename Deleter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Type const, Deleter &gt; fcppt::unique_ptr_to_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html">fcppt::unique_ptr</a>&lt; Type, Deleter &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a> to a const <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">unique_ptr</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for fcppt by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</body>
</html>
