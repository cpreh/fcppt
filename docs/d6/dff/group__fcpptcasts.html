<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fcppt: fcppt.casts</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname"><span id="projectnumber">&#160;4.6.0</span>
   </div>
   <div id="projectbrief">Freundlich&#39;s C++ toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fcppt.casts<div class="ingroups"><a class="el" href="../../df/df4/group__fcpptmain.html">fcppt</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Cast helpers which provide more type information or do additional checks. </p>
<table id="toc">
<tr>
<td><p class="starttd"></p>
<ul>
<li>
<a class="el" href="#fcpptcasts_motivation">Motivation</a> </li>
<li>
<a class="el" href="#fcpptcasts_special">Special Casts</a> </li>
<li>
<a class="el" href="#fcpptcasts_safe">Safe conversions</a> </li>
<li>
<a class="el" href="#fcpptcasts_truncation_check">Checking truncation</a> </li>
<li>
<a class="el" href="#fcpptcasts_dynamic_casting">Dynamic casting</a> </li>
<li>
<a class="el" href="#fcpptcasts_structure_cast">Casting user-defined types</a> </li>
</ul>
<p class="endtd"></p>
</td></tr>
</table>
<h1><a class="anchor" id="fcpptcasts_motivation"></a>
Motivation</h1>
<p>C++ offers four different casts: <code>static_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code> and <code>dynamic_cast</code> which cover a wide area of explicit conversions. Some conversions can only be done by casts, e.g. <code>dynamic_cast</code> to cast in a polymorphic class hierarchy or <code>reinterpret_cast</code> to access the bytes of an object. <code>static_cast</code> can be used to reverse implicit conversions or make implicit conversions explicit. Therefore, <code>static_cast</code> does too many things at once, often hiding the intent of the programmer. Also, <code>static_cast</code> involves no checking which can be undesirable.</p>
<p>In order to fix these shortcomings, this module provides special casts, which highlight the intent of the programmer, and casts that check for truncation at compile time or at runtime.</p>
<h1><a class="anchor" id="fcpptcasts_special"></a>
Special Casts</h1>
<p>Special casts are used to replace <code>static_cast</code> and <code>reinterpret_cast</code> where possible:</p>
<table class="doxtable">
<tr>
<td>Casting between signed and unsigned integers  </td><td><a class="el" href="#gae951f348f14dcfdd9a2428a2f4288a10" title="Converts an unsigned int to its signed type.">fcppt::cast::to_signed</a>, <a class="el" href="#gafe136208d4b863f30faa0205345eff25" title="Converts a signed int to its unsigned type.">fcppt::cast::to_unsigned</a>   </td></tr>
<tr>
<td>Casting between types of the same signedness but different sizes  </td><td><a class="el" href="#ga8a106c80787343bee1a5eb55f7f0480e" title="Converts a type to a similar type of different size.">fcppt::cast::size</a>   </td></tr>
<tr>
<td>Casting between floats and integers  </td><td><a class="el" href="#gaa4e787ec2701f802ee1704279bab9e72" title="Converts an int to a float.">fcppt::cast::int_to_float</a>, <a class="el" href="#gaec2d6205b80901752312cb6cdbddc087" title="Converts a float to a signed int.">fcppt::cast::float_to_int</a>   </td></tr>
<tr>
<td>Casting between enums and integers  </td><td><a class="el" href="#ga53e15def99e2232e4370c43a5e0faed9" title="Converts an int to an enum.">fcppt::cast::int_to_enum</a>, <a class="el" href="#gac6d046303c81a118bb0f663965ea5e7b" title="Converts an enum to an int.">fcppt::cast::enum_to_int</a>, <a class="el" href="#ga845df078ee1cd481ffa6cb852cd22934" title="Converts an enum to its underlying type.">fcppt::cast::enum_to_underlying</a>   </td></tr>
<tr>
<td>Casting between objects in a class hierarchy  </td><td><a class="el" href="#ga69c5f65039ecc1ecf1dad8362063f2f0" title="Statically converts a reference to a base class to a reference to a derived class.">fcppt::cast::static_downcast</a>, <a class="el" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic</a>   </td></tr>
<tr>
<td>Casting between unrelated types  </td><td><a class="el" href="#ga9d76e228fd0cefe8be9708ef853dada7" title="Tries a dynamic_cast on unrelated types, returning an empty optional on failure.">fcppt::cast::dynamic_cross</a>   </td></tr>
<tr>
<td>Casting from pointers to void  </td><td><a class="el" href="#gaf5161623b449a113d19178e2a2f57b99" title="Converts a void pointer to a different pointer.">fcppt::cast::from_void_ptr</a>   </td></tr>
<tr>
<td>Casting to a byte array  </td><td><a class="el" href="#gaf23591c0003ddc8ec8477bb54108f5c9" title="Converts a pointer to a pointer to characters.">fcppt::cast::to_char_ptr</a>   </td></tr>
</table>
<p>Here is a small example:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">float</span> <span class="keyword">const</span> f{3.5F};</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> <span class="keyword">const</span> i{<a class="code hl_function" href="#gaec2d6205b80901752312cb6cdbddc087" title="Converts a float to a signed int.">fcppt::cast::float_to_int&lt;int&gt;</a>(f)};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// prints 3</span></div>
<div class="line">  std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><p>An important thing to note is that these casts can't be used with the wrong types on accident:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="../../d9/dc7/group__fcpptbit.html#ga41f7fc23cce7a254fe1b15ce727e30d8" title="Tests a value against a bit mask.">test</a>(T <span class="keyword">const</span> _t)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <a class="code hl_function" href="#gafe136208d4b863f30faa0205345eff25" title="Converts a signed int to its unsigned type.">fcppt::cast::to_unsigned</a>(_t) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> g()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="../../d9/dc7/group__fcpptbit.html#ga41f7fc23cce7a254fe1b15ce727e30d8" title="Tests a value against a bit mask.">test</a>(4);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// error:</span></div>
<div class="line">  <span class="comment">// test(4u);</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="fcpptcasts_safe"></a>
Safe conversions</h1>
<p><a class="el" href="#gacb563f826921db8ab969322489f282a2" title="Safe numeric cast is a safer static_cast that forbids lossy conversions.">fcppt::cast::safe_numeric</a> is a cast that doesn't do any runtime checking (as opposed to <a class="el" href="#ga3356a49a81c20c6daec4b92dffc8614e" title="Cast between integral types, checking for truncation.">fcppt::cast::truncation_check</a>). Instead, it checks at compile time which conversions between arithmetic types are safe. See <a class="el" href="#gacb563f826921db8ab969322489f282a2" title="Safe numeric cast is a safer static_cast that forbids lossy conversions.">fcppt::cast::safe_numeric</a> for a detailed description on which conditions must hold in order for the cast to compile.</p>
<p>The following example shows how a class's constructor can be strengthened by <a class="el" href="#gacb563f826921db8ab969322489f282a2" title="Safe numeric cast is a safer static_cast that forbids lossy conversions.">fcppt::cast::safe_numeric</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_class</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>int_type = <span class="keywordtype">unsigned</span> long; <span class="comment">// NOLINT(google-runtime-int)</span></div>
<div class="line">  <span class="comment">// The constructor would normally be declared like this:</span></div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  explicit</span></div>
<div class="line"><span class="comment">  my_class(int_type);</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use a templated constructor here so no implicit conversions take</span></div>
<div class="line">  <span class="comment">// place when calling the constructor. The implicit conversions will be</span></div>
<div class="line">  <span class="comment">// done by safe_numeric instead, and the unsafe ones will be</span></div>
<div class="line">  <span class="comment">// forbidden.</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Other&gt;</div>
<div class="line">  <span class="keyword">explicit</span> my_class(Other <span class="keyword">const</span> &amp;_other) : inner_(<a class="code hl_namespace" href="../../dc/dfd/namespacefcppt.html" title="The top level namespace.">fcppt</a>::cast::<a class="code hl_function" href="#gacb563f826921db8ab969322489f282a2" title="Safe numeric cast is a safer static_cast that forbids lossy conversions.">safe_numeric</a>&lt;int_type&gt;(_other))</div>
<div class="line">  {</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  int_type inner_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Here are some examples of how the constructor can and can't be called:</p>
<div class="fragment"><div class="line">  <span class="comment">// Ok, because an unsigned int can be converted to an unsigned long</span></div>
<div class="line">  my_class <span class="keyword">const</span> test1(1U);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Doesn&#39;t compile, because the signedness is different, although it</span></div>
<div class="line">  <span class="comment">// would work at runtime. The value could as well be negative.</span></div>
<div class="line">  <span class="comment">// my_class const test2(1);</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Dito.</span></div>
<div class="line">  <span class="comment">// my_class const test3(-1);</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Conversions from floats don&#39;t work either.</span></div>
<div class="line">  <span class="comment">// my_class const test4(3.f);</span></div>
</div><!-- fragment --><h1><a class="anchor" id="fcpptcasts_truncation_check"></a>
Checking truncation</h1>
<p><a class="el" href="#ga3356a49a81c20c6daec4b92dffc8614e" title="Cast between integral types, checking for truncation.">fcppt::cast::truncation_check</a> complements <a class="el" href="#gacb563f826921db8ab969322489f282a2" title="Safe numeric cast is a safer static_cast that forbids lossy conversions.">fcppt::cast::safe_numeric</a> by checking at runtime if a conversion truncates.</p>
<p>In the following example, it is tested if the biggest <code>unsigned long</code> value fits into an <code>unsigned int</code>. This might be true, depending on the architecture.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> check_int_long()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Try to cast the greatest unsigned long value into an unsigned int.</span></div>
<div class="line">  <span class="comment">// This might fail or it might not fail depending on the</span></div>
<div class="line">  <span class="comment">// implementation.</span></div>
<div class="line">  <span class="comment">// An empty optional will be returned on failure.</span></div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a>(<a class="code hl_function" href="#ga3356a49a81c20c6daec4b92dffc8614e" title="Cast between integral types, checking for truncation.">fcppt::cast::truncation_check&lt;unsigned&gt;</a>(</div>
<div class="line">      std::numeric_limits&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="comment">// NOLINT(google-runtime-int)</span></div>
<div class="line">                          &gt;::max()));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The casted value is &quot;</span> &lt;&lt; <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Truncating conversions of negative values are also detected.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> negative_conversion()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// -1 cannot be represented as an unsigned. This will return nothing.</span></div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a>(<a class="code hl_function" href="#ga3356a49a81c20c6daec4b92dffc8614e" title="Cast between integral types, checking for truncation.">fcppt::cast::truncation_check&lt;unsigned&gt;</a>(-1));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The casted value is &quot;</span> &lt;&lt; <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="fcpptcasts_dynamic_casting"></a>
Dynamic casting</h1>
<p><code>dynamic_cast</code> can cast between pointers or references to objects in a class hierarchy. The cast can fail at runtime in which case the null pointer is returned for pointers and <code>bad_cast</code> is thrown for references. <a class="el" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic</a> returns an empty optional on failure instead:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(base);</div>
<div class="line"> </div>
<div class="line">  base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> ~base() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived1 : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived1);</div>
<div class="line"> </div>
<div class="line">  derived1() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived1() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived2 : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived2);</div>
<div class="line"> </div>
<div class="line">  derived2() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived2() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<a class="code hl_class" href="../../db/d57/classfcppt_1_1reference.html" title="A simple reference wrapper that supports incomplete types.">fcppt::reference&lt;base&gt;</a> <span class="keyword">const</span> _base)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::reference&lt;derived2&gt;</a> <span class="keyword">const</span> to_d2{<a class="code hl_function" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic&lt;derived2&gt;</a>(_base.<a class="code hl_function" href="../../db/d57/classfcppt_1_1reference.html#ac2d99f3561a5fd9b6db7ef703790aaf2">get</a>())};</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::reference&lt;derived1&gt;</a> <span class="keyword">const</span> to_d1{<a class="code hl_function" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic&lt;derived1&gt;</a>(_base.<a class="code hl_function" href="../../db/d57/classfcppt_1_1reference.html#ac2d99f3561a5fd9b6db7ef703790aaf2">get</a>())};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; to_d2.<a class="code hl_function" href="../../da/d72/classfcppt_1_1optional_1_1object.html#ac670dc7c39fb7a7fb40281de35f1760e" title="Returns whether the optional holds a value.">has_value</a>() &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; to_d1.has_value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To catch more mistakes, <a class="el" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic</a> only works on related types: The type to cast to must inherit from the source type. In case you need to cast between unrelated types, <a class="el" href="#ga9d76e228fd0cefe8be9708ef853dada7" title="Tries a dynamic_cast on unrelated types, returning an empty optional on failure.">fcppt::cast::dynamic_cross</a> can be used:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(base);</div>
<div class="line"> </div>
<div class="line">  base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> ~base() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived1 : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived1);</div>
<div class="line"> </div>
<div class="line">  derived1() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived1() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived2 : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived2);</div>
<div class="line"> </div>
<div class="line">  derived2() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived2() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<a class="code hl_class" href="../../db/d57/classfcppt_1_1reference.html" title="A simple reference wrapper that supports incomplete types.">fcppt::reference&lt;derived1&gt;</a> <span class="keyword">const</span> _d1)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::reference&lt;derived2&gt;</a> <span class="keyword">const</span> to_d2{<a class="code hl_function" href="#ga9d76e228fd0cefe8be9708ef853dada7" title="Tries a dynamic_cast on unrelated types, returning an empty optional on failure.">fcppt::cast::dynamic_cross&lt;derived2&gt;</a>(_d1.<a class="code hl_function" href="../../db/d57/classfcppt_1_1reference.html#ac2d99f3561a5fd9b6db7ef703790aaf2">get</a>())};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; to_d2.<a class="code hl_function" href="../../da/d72/classfcppt_1_1optional_1_1object.html#ac670dc7c39fb7a7fb40281de35f1760e" title="Returns whether the optional holds a value.">has_value</a>() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="fcpptcasts_structure_cast"></a>
Casting user-defined types</h1>
<p>For user-defined types static_cast and all of the casts from <a class="el" href="../../db/de3/namespacefcppt_1_1cast.html" title="Cast helpers which provide more type information or do additional checks.">fcppt::cast</a> can't be used directly. Instead, custom cast functions have to be defined. For example, <a class="el" href="../../db/df0/namespacefcppt_1_1math.html" title="Everything math-related goes in here.">fcppt.math</a> defines functions called structure_cast to cast between vectors, dims and matrices. To incorporate cast functions from <a class="el" href="../../db/de3/namespacefcppt_1_1cast.html" title="Cast helpers which provide more type information or do additional checks.">fcppt::cast</a>, an additional template argument has to be added to the function's signature which then will be used to cast each element of the user-defined structure. For this purpose, this module defines several function objects suffixed with _fun, for example <a class="el" href="../../d0/d94/structfcppt_1_1cast_1_1float__to__int__fun.html" title="Function object of fcppt::cast::float_to_int.">fcppt::cast::float_to_int_fun</a>.</p>
<div class="fragment"><div class="line">  <span class="keyword">using </span>vec_2f = <a class="code hl_class" href="../../d8/d10/classfcppt_1_1math_1_1vector_1_1object.html" title="A class representing static n-dimensional vectors.">fcppt::math::vector::static_&lt;float, 2&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span>vec_2i = <a class="code hl_class" href="../../d8/d10/classfcppt_1_1math_1_1vector_1_1object.html" title="A class representing static n-dimensional vectors.">fcppt::math::vector::static_&lt;int, 2&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> res(</div>
<div class="line">      <a class="code hl_function" href="../../d9/dfd/group__fcpptmathvector.html#ga91f20f71fe76b2fe97ce056a15025b73" title="Converts a vector into a different vector of the same dimension.">fcppt::math::vector::structure_cast&lt;vec_2i, fcppt::cast::float_to_int_fun&gt;</a>(vec_2f(1.F, 2.F)));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; res &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d1c/structfcppt_1_1cast_1_1dynamic__any__fun.html">fcppt::cast::dynamic_any_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that uses <a class="el" href="#gaaa2685ce9bbde3066c0d1417fd7e143f" title="Converts between references using dynamic_cast, returning an empty optional on failure.">fcppt::cast::dynamic_any</a>.  <a href="../../d6/d1c/structfcppt_1_1cast_1_1dynamic__any__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dec/structfcppt_1_1cast_1_1dynamic__cross__fun.html">fcppt::cast::dynamic_cross_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that uses <a class="el" href="#ga9d76e228fd0cefe8be9708ef853dada7" title="Tries a dynamic_cast on unrelated types, returning an empty optional on failure.">fcppt::cast::dynamic_cross</a>.  <a href="../../d7/dec/structfcppt_1_1cast_1_1dynamic__cross__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d09/structfcppt_1_1cast_1_1dynamic__fun.html">fcppt::cast::dynamic_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that uses <a class="el" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic</a>.  <a href="../../d6/d09/structfcppt_1_1cast_1_1dynamic__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d94/structfcppt_1_1cast_1_1float__to__int__fun.html">fcppt::cast::float_to_int_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object of <a class="el" href="#gaec2d6205b80901752312cb6cdbddc087" title="Converts a float to a signed int.">fcppt::cast::float_to_int</a>.  <a href="../../d0/d94/structfcppt_1_1cast_1_1float__to__int__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d44/structfcppt_1_1cast_1_1int__to__enum__fun.html">fcppt::cast::int_to_enum_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object of <a class="el" href="#ga53e15def99e2232e4370c43a5e0faed9" title="Converts an int to an enum.">fcppt::cast::int_to_enum</a>.  <a href="../../db/d44/structfcppt_1_1cast_1_1int__to__enum__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d69/structfcppt_1_1cast_1_1int__to__float__fun.html">fcppt::cast::int_to_float_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object of <a class="el" href="#gaa4e787ec2701f802ee1704279bab9e72" title="Converts an int to a float.">fcppt::cast::int_to_float</a>.  <a href="../../d0/d69/structfcppt_1_1cast_1_1int__to__float__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dde/structfcppt_1_1cast_1_1size__fun.html">fcppt::cast::size_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object of <a class="el" href="#ga8a106c80787343bee1a5eb55f7f0480e" title="Converts a type to a similar type of different size.">fcppt::cast::size</a>.  <a href="../../da/dde/structfcppt_1_1cast_1_1size__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d39/structfcppt_1_1cast_1_1static__cast__fun.html">fcppt::cast::static_cast_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object that does a static_cast.  <a href="../../d1/d39/structfcppt_1_1cast_1_1static__cast__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1f/structfcppt_1_1cast_1_1to__signed__fun.html">fcppt::cast::to_signed_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object of <a class="el" href="#gae951f348f14dcfdd9a2428a2f4288a10" title="Converts an unsigned int to its signed type.">fcppt::cast::to_signed</a>.  <a href="../../dd/d1f/structfcppt_1_1cast_1_1to__signed__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dec/structfcppt_1_1cast_1_1to__unsigned__fun.html">fcppt::cast::to_unsigned_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object of <a class="el" href="#gafe136208d4b863f30faa0205345eff25" title="Converts a signed int to its unsigned type.">fcppt::cast::to_unsigned</a>.  <a href="../../d5/dec/structfcppt_1_1cast_1_1to__unsigned__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadfc7de1386ac035735fb252e8272012c" id="r_gadfc7de1386ac035735fb252e8272012c"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gadfc7de1386ac035735fb252e8272012c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadfc7de1386ac035735fb252e8272012c">fcppt::cast::promote_int_type</a> = typename fcppt::cast::detail::promote_int_type&lt;Type&gt;::type</td></tr>
<tr class="memdesc:gadfc7de1386ac035735fb252e8272012c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The promoted type of an integral type.  <br /></td></tr>
<tr class="separator:gadfc7de1386ac035735fb252e8272012c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3d8392aa75c33ffa84c397e317b590c5" id="r_ga3d8392aa75c33ffa84c397e317b590c5"><td class="memTemplParams" colspan="2">template&lt;typename Fun , typename Res , typename Src &gt; </td></tr>
<tr class="memitem:ga3d8392aa75c33ffa84c397e317b590c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3d8392aa75c33ffa84c397e317b590c5">fcppt::cast::apply</a> (Src &amp;&amp;_src)</td></tr>
<tr class="memdesc:ga3d8392aa75c33ffa84c397e317b590c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a cast to a source.  <br /></td></tr>
<tr class="separator:ga3d8392aa75c33ffa84c397e317b590c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212a392d1e9e58d471d740f60dd86acb" id="r_ga212a392d1e9e58d471d740f60dd86acb"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Base &gt; <br />
requires (<a class="el" href="../../d3/d0e/structfcppt_1_1type__traits_1_1is__base__of.html">fcppt::type_traits::is_base_of</a>&lt;std::remove_cv_t&lt;Base&gt;, std::remove_cv_t&lt;Derived&gt;&gt;::value)</td></tr>
<tr class="memitem:ga212a392d1e9e58d471d740f60dd86acb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d65/group__fcpptoptional.html#ga365798ba3e5a9e4663b601b2ddf3c3e6">fcppt::optional::reference</a>&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga212a392d1e9e58d471d740f60dd86acb">fcppt::cast::dynamic</a> (Base &amp;_base) noexcept</td></tr>
<tr class="memdesc:ga212a392d1e9e58d471d740f60dd86acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts between references of related types using <code>dynamic_cast</code>, returning an empty optional on failure.  <br /></td></tr>
<tr class="separator:ga212a392d1e9e58d471d740f60dd86acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2685ce9bbde3066c0d1417fd7e143f" id="r_gaaa2685ce9bbde3066c0d1417fd7e143f"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Base &gt; </td></tr>
<tr class="memitem:gaaa2685ce9bbde3066c0d1417fd7e143f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d65/group__fcpptoptional.html#ga365798ba3e5a9e4663b601b2ddf3c3e6">fcppt::optional::reference</a>&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaaa2685ce9bbde3066c0d1417fd7e143f">fcppt::cast::dynamic_any</a> (Base &amp;_base) noexcept</td></tr>
<tr class="memdesc:gaaa2685ce9bbde3066c0d1417fd7e143f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts between references using <code>dynamic_cast</code>, returning an empty optional on failure.  <br /></td></tr>
<tr class="separator:gaaa2685ce9bbde3066c0d1417fd7e143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d76e228fd0cefe8be9708ef853dada7" id="r_ga9d76e228fd0cefe8be9708ef853dada7"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Src &gt; </td></tr>
<tr class="memitem:ga9d76e228fd0cefe8be9708ef853dada7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d65/group__fcpptoptional.html#ga365798ba3e5a9e4663b601b2ddf3c3e6">fcppt::optional::reference</a>&lt; Dest &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9d76e228fd0cefe8be9708ef853dada7">fcppt::cast::dynamic_cross</a> (Src &amp;_src) noexcept</td></tr>
<tr class="memdesc:ga9d76e228fd0cefe8be9708ef853dada7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries a <code>dynamic_cast</code> on unrelated types, returning an empty optional on failure.  <br /></td></tr>
<tr class="separator:ga9d76e228fd0cefe8be9708ef853dada7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d046303c81a118bb0f663965ea5e7b" id="r_gac6d046303c81a118bb0f663965ea5e7b"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Enum &gt; <br />
requires (std::is_integral_v&lt;Dest&gt; &amp;&amp; std::is_enum_v&lt;Enum&gt;)</td></tr>
<tr class="memitem:gac6d046303c81a118bb0f663965ea5e7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr Dest&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac6d046303c81a118bb0f663965ea5e7b">fcppt::cast::enum_to_int</a> (Enum const _enum) noexcept</td></tr>
<tr class="memdesc:gac6d046303c81a118bb0f663965ea5e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an enum to an int.  <br /></td></tr>
<tr class="separator:gac6d046303c81a118bb0f663965ea5e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845df078ee1cd481ffa6cb852cd22934" id="r_ga845df078ee1cd481ffa6cb852cd22934"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; <br />
requires std::is_enum_v&lt;Enum&gt;</td></tr>
<tr class="memitem:ga845df078ee1cd481ffa6cb852cd22934"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::underlying_type_t&lt; Enum &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga845df078ee1cd481ffa6cb852cd22934">fcppt::cast::enum_to_underlying</a> (Enum const _enum) noexcept</td></tr>
<tr class="memdesc:ga845df078ee1cd481ffa6cb852cd22934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an enum to its underlying type.  <br /></td></tr>
<tr class="separator:ga845df078ee1cd481ffa6cb852cd22934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2d6205b80901752312cb6cdbddc087" id="r_gaec2d6205b80901752312cb6cdbddc087"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Source &gt; <br />
requires (std::is_floating_point_v&lt;Source&gt; &amp;&amp; std::is_signed_v&lt;Dest&gt;)</td></tr>
<tr class="memitem:gaec2d6205b80901752312cb6cdbddc087"><td class="memTemplItemLeft" align="right" valign="top">constexpr Dest&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaec2d6205b80901752312cb6cdbddc087">fcppt::cast::float_to_int</a> (Source const _source) noexcept</td></tr>
<tr class="memdesc:gaec2d6205b80901752312cb6cdbddc087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a float to a signed int.  <br /></td></tr>
<tr class="separator:gaec2d6205b80901752312cb6cdbddc087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5161623b449a113d19178e2a2f57b99" id="r_gaf5161623b449a113d19178e2a2f57b99"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Source &gt; </td></tr>
<tr class="memitem:gaf5161623b449a113d19178e2a2f57b99"><td class="memTemplItemLeft" align="right" valign="top">Dest&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf5161623b449a113d19178e2a2f57b99">fcppt::cast::from_void_ptr</a> (Source *const _ptr) noexcept</td></tr>
<tr class="memdesc:gaf5161623b449a113d19178e2a2f57b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a void pointer to a different pointer.  <br /></td></tr>
<tr class="separator:gaf5161623b449a113d19178e2a2f57b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e15def99e2232e4370c43a5e0faed9" id="r_ga53e15def99e2232e4370c43a5e0faed9"><td class="memTemplParams" colspan="2">template&lt;typename Enum , typename Source &gt; <br />
requires (std::is_enum_v&lt;Enum&gt; &amp;&amp; std::is_integral_v&lt;Source&gt;)</td></tr>
<tr class="memitem:ga53e15def99e2232e4370c43a5e0faed9"><td class="memTemplItemLeft" align="right" valign="top">constexpr Enum&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga53e15def99e2232e4370c43a5e0faed9">fcppt::cast::int_to_enum</a> (Source const _source) noexcept</td></tr>
<tr class="memdesc:ga53e15def99e2232e4370c43a5e0faed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an int to an enum.  <br /></td></tr>
<tr class="separator:ga53e15def99e2232e4370c43a5e0faed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e787ec2701f802ee1704279bab9e72" id="r_gaa4e787ec2701f802ee1704279bab9e72"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Source &gt; <br />
requires (std::is_integral_v&lt;Source&gt; &amp;&amp; std::is_floating_point_v&lt;Dest&gt;)</td></tr>
<tr class="memitem:gaa4e787ec2701f802ee1704279bab9e72"><td class="memTemplItemLeft" align="right" valign="top">constexpr Dest&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa4e787ec2701f802ee1704279bab9e72">fcppt::cast::int_to_float</a> (Source const _source) noexcept</td></tr>
<tr class="memdesc:gaa4e787ec2701f802ee1704279bab9e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an int to a float.  <br /></td></tr>
<tr class="separator:gaa4e787ec2701f802ee1704279bab9e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe6b1c65e7f04d0f15ea156812006bb" id="r_gaabe6b1c65e7f04d0f15ea156812006bb"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gaabe6b1c65e7f04d0f15ea156812006bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#gadfc7de1386ac035735fb252e8272012c">fcppt::cast::promote_int_type</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaabe6b1c65e7f04d0f15ea156812006bb">fcppt::cast::promote_int</a> (Type const &amp;_value)</td></tr>
<tr class="memdesc:gaabe6b1c65e7f04d0f15ea156812006bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes an integral type to int or unsigned int.  <br /></td></tr>
<tr class="separator:gaabe6b1c65e7f04d0f15ea156812006bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb563f826921db8ab969322489f282a2" id="r_gacb563f826921db8ab969322489f282a2"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Source &gt; <br />
requires ( sizeof(Dest) &gt;= sizeof(Source) &amp;&amp; (std::is_same_v&lt;Dest, Source&gt; || (std::is_floating_point_v&lt;Dest&gt; &amp;&amp; std::is_floating_point_v&lt;Source&gt;) || (std::is_integral_v&lt;Dest&gt; &amp;&amp; std::is_integral_v&lt;Source&gt; &amp;&amp; std::is_signed_v&lt;Dest&gt; == std::is_signed_v&lt;Source&gt;)))</td></tr>
<tr class="memitem:gacb563f826921db8ab969322489f282a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr Dest&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacb563f826921db8ab969322489f282a2">fcppt::cast::safe_numeric</a> (Source const &amp;_source) noexcept</td></tr>
<tr class="memdesc:gacb563f826921db8ab969322489f282a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe numeric cast is a safer <code>static_cast</code> that forbids lossy conversions.  <br /></td></tr>
<tr class="separator:gacb563f826921db8ab969322489f282a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a106c80787343bee1a5eb55f7f0480e" id="r_ga8a106c80787343bee1a5eb55f7f0480e"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Source &gt; <br />
requires ( std::is_floating_point_v&lt;Dest&gt; == std::is_floating_point_v&lt;Source&gt; || std::is_signed_v&lt;Dest&gt; == std::is_signed_v&lt;Source&gt; || std::is_unsigned_v&lt;Dest&gt; == std::is_unsigned_v&lt;Source&gt;)</td></tr>
<tr class="memitem:ga8a106c80787343bee1a5eb55f7f0480e"><td class="memTemplItemLeft" align="right" valign="top">constexpr Dest&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8a106c80787343bee1a5eb55f7f0480e">fcppt::cast::size</a> (Source const _source) noexcept</td></tr>
<tr class="memdesc:ga8a106c80787343bee1a5eb55f7f0480e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a type to a similar type of different size.  <br /></td></tr>
<tr class="separator:ga8a106c80787343bee1a5eb55f7f0480e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c5f65039ecc1ecf1dad8362063f2f0" id="r_ga69c5f65039ecc1ecf1dad8362063f2f0"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Base &gt; <br />
requires ( std::is_reference_v&lt;Derived&gt; &amp;&amp; <a class="el" href="../../d3/d0e/structfcppt_1_1type__traits_1_1is__base__of.html">fcppt::type_traits::is_base_of</a>&lt;std::remove_cv_t&lt;Base&gt;, std::remove_cvref_t&lt;Derived&gt;&gt;::value)</td></tr>
<tr class="memitem:ga69c5f65039ecc1ecf1dad8362063f2f0"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga69c5f65039ecc1ecf1dad8362063f2f0">fcppt::cast::static_downcast</a> (Base &amp;_source) noexcept</td></tr>
<tr class="memdesc:ga69c5f65039ecc1ecf1dad8362063f2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically converts a reference to a base class to a reference to a derived class.  <br /></td></tr>
<tr class="separator:ga69c5f65039ecc1ecf1dad8362063f2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf23591c0003ddc8ec8477bb54108f5c9" id="r_gaf23591c0003ddc8ec8477bb54108f5c9"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Source &gt; </td></tr>
<tr class="memitem:gaf23591c0003ddc8ec8477bb54108f5c9"><td class="memTemplItemLeft" align="right" valign="top">Dest&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf23591c0003ddc8ec8477bb54108f5c9">fcppt::cast::to_char_ptr</a> (Source *const _source) noexcept</td></tr>
<tr class="memdesc:gaf23591c0003ddc8ec8477bb54108f5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer to a pointer to characters.  <br /></td></tr>
<tr class="separator:gaf23591c0003ddc8ec8477bb54108f5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae951f348f14dcfdd9a2428a2f4288a10" id="r_gae951f348f14dcfdd9a2428a2f4288a10"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; <br />
requires std::is_unsigned_v&lt;Type&gt;</td></tr>
<tr class="memitem:gae951f348f14dcfdd9a2428a2f4288a10"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::make_signed_t&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae951f348f14dcfdd9a2428a2f4288a10">fcppt::cast::to_signed</a> (Type const _value) noexcept</td></tr>
<tr class="memdesc:gae951f348f14dcfdd9a2428a2f4288a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned int to its signed type.  <br /></td></tr>
<tr class="separator:gae951f348f14dcfdd9a2428a2f4288a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e3f4167a0afebe647d2c4a787984ce" id="r_gaf9e3f4167a0afebe647d2c4a787984ce"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:gaf9e3f4167a0afebe647d2c4a787984ce"><td class="memTemplItemLeft" align="right" valign="top">std::uintptr_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf9e3f4167a0afebe647d2c4a787984ce">fcppt::cast::to_uint_ptr</a> (Source *const _ptr) noexcept</td></tr>
<tr class="memdesc:gaf9e3f4167a0afebe647d2c4a787984ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer to a <code>std::uintptr_t</code>.  <br /></td></tr>
<tr class="separator:gaf9e3f4167a0afebe647d2c4a787984ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe136208d4b863f30faa0205345eff25" id="r_gafe136208d4b863f30faa0205345eff25"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; <br />
requires std::is_signed_v&lt;Type&gt;</td></tr>
<tr class="memitem:gafe136208d4b863f30faa0205345eff25"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::make_unsigned_t&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafe136208d4b863f30faa0205345eff25">fcppt::cast::to_unsigned</a> (Type const _value) noexcept</td></tr>
<tr class="memdesc:gafe136208d4b863f30faa0205345eff25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a signed int to its unsigned type.  <br /></td></tr>
<tr class="separator:gafe136208d4b863f30faa0205345eff25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0344507522ab03feffdff1ae5b605550" id="r_ga0344507522ab03feffdff1ae5b605550"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga0344507522ab03feffdff1ae5b605550"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0344507522ab03feffdff1ae5b605550">fcppt::cast::to_void</a> (Type const &amp;_value) noexcept</td></tr>
<tr class="memdesc:ga0344507522ab03feffdff1ae5b605550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an expression to void.  <br /></td></tr>
<tr class="separator:ga0344507522ab03feffdff1ae5b605550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb8ff2d84fa52a598224533e71ff6ed" id="r_ga9cb8ff2d84fa52a598224533e71ff6ed"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:ga9cb8ff2d84fa52a598224533e71ff6ed"><td class="memTemplItemLeft" align="right" valign="top">void const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9cb8ff2d84fa52a598224533e71ff6ed">fcppt::cast::to_void_ptr</a> (Source const *const _ptr) noexcept</td></tr>
<tr class="memdesc:ga9cb8ff2d84fa52a598224533e71ff6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer to const to a pointer to const void.  <br /></td></tr>
<tr class="separator:ga9cb8ff2d84fa52a598224533e71ff6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4906da28a01732af5dd1aac123f56457" id="r_ga4906da28a01732af5dd1aac123f56457"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:ga4906da28a01732af5dd1aac123f56457"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4906da28a01732af5dd1aac123f56457">fcppt::cast::to_void_ptr</a> (Source *const _ptr) noexcept</td></tr>
<tr class="memdesc:ga4906da28a01732af5dd1aac123f56457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer to a pointer to void.  <br /></td></tr>
<tr class="separator:ga4906da28a01732af5dd1aac123f56457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3356a49a81c20c6daec4b92dffc8614e" id="r_ga3356a49a81c20c6daec4b92dffc8614e"><td class="memTemplParams" colspan="2">template&lt;typename Dest , typename Source &gt; <br />
requires (std::conjunction_v&lt;std::is_integral&lt;Source&gt;, std::is_integral&lt;Dest&gt;&gt;)</td></tr>
<tr class="memitem:ga3356a49a81c20c6daec4b92dffc8614e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; Dest &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3356a49a81c20c6daec4b92dffc8614e">fcppt::cast::truncation_check</a> (Source const _source)</td></tr>
<tr class="memdesc:ga3356a49a81c20c6daec4b92dffc8614e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast between integral types, checking for truncation.  <br /></td></tr>
<tr class="separator:ga3356a49a81c20c6daec4b92dffc8614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gadfc7de1386ac035735fb252e8272012c" name="gadfc7de1386ac035735fb252e8272012c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfc7de1386ac035735fb252e8272012c">&#9670;&#160;</a></span>promote_int_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gadfc7de1386ac035735fb252e8272012c">fcppt::cast::promote_int_type</a> = typename fcppt::cast::detail::promote_int_type&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The promoted type of an integral type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Must be an integral type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3d8392aa75c33ffa84c397e317b590c5" name="ga3d8392aa75c33ffa84c397e317b590c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d8392aa75c33ffa84c397e317b590c5">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fun , typename Res , typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) fcppt::cast::apply </td>
          <td>(</td>
          <td class="paramtype">Src &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a cast to a source. </p>

</div>
</div>
<a id="ga212a392d1e9e58d471d740f60dd86acb" name="ga212a392d1e9e58d471d740f60dd86acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212a392d1e9e58d471d740f60dd86acb">&#9670;&#160;</a></span>dynamic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Base &gt; <br />
requires (<a class="el" href="../../d3/d0e/structfcppt_1_1type__traits_1_1is__base__of.html">fcppt::type_traits::is_base_of</a>&lt;std::remove_cv_t&lt;Base&gt;, std::remove_cv_t&lt;Derived&gt;&gt;::value)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d65/group__fcpptoptional.html#ga365798ba3e5a9e4663b601b2ddf3c3e6">fcppt::optional::reference</a>&lt; Derived &gt; fcppt::cast::dynamic </td>
          <td>(</td>
          <td class="paramtype">Base &amp;</td>          <td class="paramname"><span class="paramname"><em>_base</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts between references of related types using <code>dynamic_cast</code>, returning an empty optional on failure. </p>
<p>Tries to cast <em>_src</em> to <em>Dest</em> using <code>dynamic_cast</code>. On failure, an empty optional is returned. To catch more mistakes, <em>Base</em> must be a base class of <em>Derived</em>. In case you need a cross cast, use <a class="el" href="#ga9d76e228fd0cefe8be9708ef853dada7" title="Tries a dynamic_cast on unrelated types, returning an empty optional on failure.">fcppt::cast::dynamic_cross</a>.</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(base);</div>
<div class="line"> </div>
<div class="line">  base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> ~base() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived1 : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived1);</div>
<div class="line"> </div>
<div class="line">  derived1() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived1() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived2 : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived2);</div>
<div class="line"> </div>
<div class="line">  derived2() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived2() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<a class="code hl_class" href="../../db/d57/classfcppt_1_1reference.html" title="A simple reference wrapper that supports incomplete types.">fcppt::reference&lt;base&gt;</a> <span class="keyword">const</span> _base)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::reference&lt;derived2&gt;</a> <span class="keyword">const</span> to_d2{<a class="code hl_function" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic&lt;derived2&gt;</a>(_base.<a class="code hl_function" href="../../db/d57/classfcppt_1_1reference.html#ac2d99f3561a5fd9b6db7ef703790aaf2">get</a>())};</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::reference&lt;derived1&gt;</a> <span class="keyword">const</span> to_d1{<a class="code hl_function" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic&lt;derived1&gt;</a>(_base.<a class="code hl_function" href="../../db/d57/classfcppt_1_1reference.html#ac2d99f3561a5fd9b6db7ef703790aaf2">get</a>())};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; to_d2.<a class="code hl_function" href="../../da/d72/classfcppt_1_1optional_1_1object.html#ac670dc7c39fb7a7fb40281de35f1760e" title="Returns whether the optional holds a value.">has_value</a>() &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; to_d1.has_value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The type to cast to. Can be cv-qualified. Must inherit from <em>Base</em>.</td></tr>
    <tr><td class="paramname">Base</td><td>A cv-qualified non-reference type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga9d76e228fd0cefe8be9708ef853dada7" title="Tries a dynamic_cast on unrelated types, returning an empty optional on failure.">fcppt::cast::dynamic_cross</a> </dd></dl>

</div>
</div>
<a id="gaaa2685ce9bbde3066c0d1417fd7e143f" name="gaaa2685ce9bbde3066c0d1417fd7e143f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa2685ce9bbde3066c0d1417fd7e143f">&#9670;&#160;</a></span>dynamic_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d65/group__fcpptoptional.html#ga365798ba3e5a9e4663b601b2ddf3c3e6">fcppt::optional::reference</a>&lt; Derived &gt; fcppt::cast::dynamic_any </td>
          <td>(</td>
          <td class="paramtype">Base &amp;</td>          <td class="paramname"><span class="paramname"><em>_base</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts between references using <code>dynamic_cast</code>, returning an empty optional on failure. </p>
<p>Tries to cast <em>_src</em> to <em>Dest</em> using <code>dynamic_cast</code>. On failure, an empty optional is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The type to cast to. Can be cv-qualified.</td></tr>
    <tr><td class="paramname">Base</td><td>A cv-qualified non-reference type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d76e228fd0cefe8be9708ef853dada7" name="ga9d76e228fd0cefe8be9708ef853dada7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d76e228fd0cefe8be9708ef853dada7">&#9670;&#160;</a></span>dynamic_cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d65/group__fcpptoptional.html#ga365798ba3e5a9e4663b601b2ddf3c3e6">fcppt::optional::reference</a>&lt; Dest &gt; fcppt::cast::dynamic_cross </td>
          <td>(</td>
          <td class="paramtype">Src &amp;</td>          <td class="paramname"><span class="paramname"><em>_src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries a <code>dynamic_cast</code> on unrelated types, returning an empty optional on failure. </p>
<p>This cast is the same as <a class="el" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic</a> but only works on unrelated types.</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(base);</div>
<div class="line"> </div>
<div class="line">  base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> ~base() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived1 : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived1);</div>
<div class="line"> </div>
<div class="line">  derived1() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived1() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>derived2 : base</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="../../d7/d50/group__fcpptvarious.html#ga3cf4512342d53ec78c5dec73f3062a62" title="Makes a class nonmovable.">FCPPT_NONMOVABLE</a>(derived2);</div>
<div class="line"> </div>
<div class="line">  derived2() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  ~derived2() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<a class="code hl_class" href="../../db/d57/classfcppt_1_1reference.html" title="A simple reference wrapper that supports incomplete types.">fcppt::reference&lt;derived1&gt;</a> <span class="keyword">const</span> _d1)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::reference&lt;derived2&gt;</a> <span class="keyword">const</span> to_d2{<a class="code hl_function" href="#ga9d76e228fd0cefe8be9708ef853dada7" title="Tries a dynamic_cast on unrelated types, returning an empty optional on failure.">fcppt::cast::dynamic_cross&lt;derived2&gt;</a>(_d1.<a class="code hl_function" href="../../db/d57/classfcppt_1_1reference.html#ac2d99f3561a5fd9b6db7ef703790aaf2">get</a>())};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; to_d2.<a class="code hl_function" href="../../da/d72/classfcppt_1_1optional_1_1object.html#ac670dc7c39fb7a7fb40281de35f1760e" title="Returns whether the optional holds a value.">has_value</a>() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dest</td><td>The type to cast to. Can be cv-qualified. Must not inherit from <em>Base</em>.</td></tr>
    <tr><td class="paramname">Src</td><td>A cv-qualified non-reference type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic</a> </dd></dl>

</div>
</div>
<a id="gac6d046303c81a118bb0f663965ea5e7b" name="gac6d046303c81a118bb0f663965ea5e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6d046303c81a118bb0f663965ea5e7b">&#9670;&#160;</a></span>enum_to_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Enum &gt; <br />
requires (std::is_integral_v&lt;Dest&gt; &amp;&amp; std::is_enum_v&lt;Enum&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dest fcppt::cast::enum_to_int </td>
          <td>(</td>
          <td class="paramtype">Enum const</td>          <td class="paramname"><span class="paramname"><em>_enum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an enum to an int. </p>
<p>Converts <em>_enum</em> to the integer type specified by <em>Dest</em>. This cast is unsafe and should only be used if the enum value can be converted to the destination type. Consider <a class="el" href="#ga845df078ee1cd481ffa6cb852cd22934" title="Converts an enum to its underlying type.">fcppt::cast::enum_to_underlying</a> instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dest</td><td>Must be an integral type</td></tr>
    <tr><td class="paramname">Enum</td><td>Must be an enumeration type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga845df078ee1cd481ffa6cb852cd22934" name="ga845df078ee1cd481ffa6cb852cd22934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga845df078ee1cd481ffa6cb852cd22934">&#9670;&#160;</a></span>enum_to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; <br />
requires std::is_enum_v&lt;Enum&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::underlying_type_t&lt; Enum &gt; fcppt::cast::enum_to_underlying </td>
          <td>(</td>
          <td class="paramtype">Enum const</td>          <td class="paramname"><span class="paramname"><em>_enum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an enum to its underlying type. </p>
<p>Converts <em>_enum</em> to its underlying integer type. This cast is safe.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Enum</td><td>Must be an enumeration type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec2d6205b80901752312cb6cdbddc087" name="gaec2d6205b80901752312cb6cdbddc087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec2d6205b80901752312cb6cdbddc087">&#9670;&#160;</a></span>float_to_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Source &gt; <br />
requires (std::is_floating_point_v&lt;Source&gt; &amp;&amp; std::is_signed_v&lt;Dest&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dest fcppt::cast::float_to_int </td>
          <td>(</td>
          <td class="paramtype">Source const</td>          <td class="paramname"><span class="paramname"><em>_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a float to a signed int. </p>
<p>Converts <em>_source</em> to an integer. The function ensures that only signed integers can be used as destination types. If you need to cast to unsigned integers, use <a class="el" href="#gafe136208d4b863f30faa0205345eff25" title="Converts a signed int to its unsigned type.">fcppt::cast::to_unsigned</a> in addition. This cast is unsafe and should be used with care.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>Must be a floating point type</td></tr>
    <tr><td class="paramname">Dest</td><td>Must be a signed integer type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf5161623b449a113d19178e2a2f57b99" name="gaf5161623b449a113d19178e2a2f57b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5161623b449a113d19178e2a2f57b99">&#9670;&#160;</a></span>from_void_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dest fcppt::cast::from_void_ptr </td>
          <td>(</td>
          <td class="paramtype">Source *const</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a void pointer to a different pointer. </p>
<p>Converts the void pointer <em>_ptr</em> to the pointer type specified by <em>Dest</em>. This cast is unsafe.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>Must be a pointer type to (cv) void</td></tr>
    <tr><td class="paramname">Dest</td><td>Must be a pointer type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53e15def99e2232e4370c43a5e0faed9" name="ga53e15def99e2232e4370c43a5e0faed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53e15def99e2232e4370c43a5e0faed9">&#9670;&#160;</a></span>int_to_enum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum , typename Source &gt; <br />
requires (std::is_enum_v&lt;Enum&gt; &amp;&amp; std::is_integral_v&lt;Source&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Enum fcppt::cast::int_to_enum </td>
          <td>(</td>
          <td class="paramtype">Source const</td>          <td class="paramname"><span class="paramname"><em>_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an int to an enum. </p>
<p>Converts the integer <em>_source</em> to the enum type specified by <em>Enum</em>. This cast is unsafe and should only be used if the enum can actually hold the integer value. Consider using fcppt::cast_to_enum instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>Must be an integral type</td></tr>
    <tr><td class="paramname">Enum</td><td>Must be an enumeration type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4e787ec2701f802ee1704279bab9e72" name="gaa4e787ec2701f802ee1704279bab9e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e787ec2701f802ee1704279bab9e72">&#9670;&#160;</a></span>int_to_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Source &gt; <br />
requires (std::is_integral_v&lt;Source&gt; &amp;&amp; std::is_floating_point_v&lt;Dest&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dest fcppt::cast::int_to_float </td>
          <td>(</td>
          <td class="paramtype">Source const</td>          <td class="paramname"><span class="paramname"><em>_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an int to a float. </p>
<p>Converts the integer <em>_source</em> to the float type specified by <em>Dest</em> by truncating like <code>static_cast</code>. This cast is unsafe and should be used with care.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>Must be an integral type</td></tr>
    <tr><td class="paramname">Dest</td><td>Must be a floating point type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabe6b1c65e7f04d0f15ea156812006bb" name="gaabe6b1c65e7f04d0f15ea156812006bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabe6b1c65e7f04d0f15ea156812006bb">&#9670;&#160;</a></span>promote_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gadfc7de1386ac035735fb252e8272012c">fcppt::cast::promote_int_type</a>&lt; Type &gt; fcppt::cast::promote_int </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promotes an integral type to int or unsigned int. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Must be an integral type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb563f826921db8ab969322489f282a2" name="gacb563f826921db8ab969322489f282a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb563f826921db8ab969322489f282a2">&#9670;&#160;</a></span>safe_numeric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Source &gt; <br />
requires ( sizeof(Dest) &gt;= sizeof(Source) &amp;&amp; (std::is_same_v&lt;Dest, Source&gt; || (std::is_floating_point_v&lt;Dest&gt; &amp;&amp; std::is_floating_point_v&lt;Source&gt;) || (std::is_integral_v&lt;Dest&gt; &amp;&amp; std::is_integral_v&lt;Source&gt; &amp;&amp; std::is_signed_v&lt;Dest&gt; == std::is_signed_v&lt;Source&gt;)))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dest fcppt::cast::safe_numeric </td>
          <td>(</td>
          <td class="paramtype">Source const &amp;</td>          <td class="paramname"><span class="paramname"><em>_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe numeric cast is a safer <code>static_cast</code> that forbids lossy conversions. </p>
<p>This cast converts one arithmetic type to another, where the size of the destination type must be at least the size of the source type.</p>
<p>Furthermore, the conversion is only allowed if and only if one of the following cases hold true:</p>
<ul>
<li>
<p class="startli">Both types are the same type</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Both types are integer types and both have the same signedness</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Both types are floating point types</p>
<p class="endli"></p>
</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dest</td><td>The destination type of the conversion</td></tr>
    <tr><td class="paramname">Source</td><td>The source type of the conversion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a106c80787343bee1a5eb55f7f0480e" name="ga8a106c80787343bee1a5eb55f7f0480e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a106c80787343bee1a5eb55f7f0480e">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Source &gt; <br />
requires ( std::is_floating_point_v&lt;Dest&gt; == std::is_floating_point_v&lt;Source&gt; || std::is_signed_v&lt;Dest&gt; == std::is_signed_v&lt;Source&gt; || std::is_unsigned_v&lt;Dest&gt; == std::is_unsigned_v&lt;Source&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dest fcppt::cast::size </td>
          <td>(</td>
          <td class="paramtype">Source const</td>          <td class="paramname"><span class="paramname"><em>_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a type to a similar type of different size. </p>
<p>Converts <em>_source</em> to the type specified by <em>Dest</em>. Exactly one of the following cases must hold:</p>
<ul>
<li>
<p class="startli">Both types are signed integer types.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Both types are unsigned integer types.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Both types are floating point types.</p>
<p class="endli"></p>
</li>
</ul>

</div>
</div>
<a id="ga69c5f65039ecc1ecf1dad8362063f2f0" name="ga69c5f65039ecc1ecf1dad8362063f2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69c5f65039ecc1ecf1dad8362063f2f0">&#9670;&#160;</a></span>static_downcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Base &gt; <br />
requires ( std::is_reference_v&lt;Derived&gt; &amp;&amp; <a class="el" href="../../d3/d0e/structfcppt_1_1type__traits_1_1is__base__of.html">fcppt::type_traits::is_base_of</a>&lt;std::remove_cv_t&lt;Base&gt;, std::remove_cvref_t&lt;Derived&gt;&gt;::value)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived fcppt::cast::static_downcast </td>
          <td>(</td>
          <td class="paramtype">Base &amp;</td>          <td class="paramname"><span class="paramname"><em>_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Statically converts a reference to a base class to a reference to a derived class. </p>
<p>Converts <em>_source</em> to the reference type specified by <em>Derived</em>. This cast is unsafe and should only be used if the <em>_source</em> has a dynamic type which is a subtype of <em>Derived</em>. Consider using <a class="el" href="#ga212a392d1e9e58d471d740f60dd86acb" title="Converts between references of related types using dynamic_cast, returning an empty optional on failu...">fcppt::cast::dynamic</a> instead.</p>
<p>Derived must be a reference to a class type derived from Base.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The type to cast to. Must be a reference type. Must inherit from <em>Base</em>.</td></tr>
    <tr><td class="paramname">Base</td><td>A cv-qualified non-reference type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf23591c0003ddc8ec8477bb54108f5c9" name="gaf23591c0003ddc8ec8477bb54108f5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf23591c0003ddc8ec8477bb54108f5c9">&#9670;&#160;</a></span>to_char_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dest fcppt::cast::to_char_ptr </td>
          <td>(</td>
          <td class="paramtype">Source *const</td>          <td class="paramname"><span class="paramname"><em>_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer to a pointer to characters. </p>
<p>Converts <em>_source</em> to the pointer to character type specified by <em>Dest</em>. This cast can be used to access the byte representation of an object, e.g. for serialization, and largely replaces <code>reinterpret_cast</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dest</td><td>Must be a pointer to (cv) unsigned char </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae951f348f14dcfdd9a2428a2f4288a10" name="gae951f348f14dcfdd9a2428a2f4288a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae951f348f14dcfdd9a2428a2f4288a10">&#9670;&#160;</a></span>to_signed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; <br />
requires std::is_unsigned_v&lt;Type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::make_signed_t&lt; Type &gt; fcppt::cast::to_signed </td>
          <td>(</td>
          <td class="paramtype">Type const</td>          <td class="paramname"><span class="paramname"><em>_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an unsigned int to its signed type. </p>
<p>Converts <em>_value</em> to its signed type. This cast is unsafe and should only be used if <em>_value</em> fits into the result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Must be an unsigned type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9e3f4167a0afebe647d2c4a787984ce" name="gaf9e3f4167a0afebe647d2c4a787984ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e3f4167a0afebe647d2c4a787984ce">&#9670;&#160;</a></span>to_uint_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uintptr_t fcppt::cast::to_uint_ptr </td>
          <td>(</td>
          <td class="paramtype">Source *const</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer to a <code>std::uintptr_t</code>. </p>

</div>
</div>
<a id="gafe136208d4b863f30faa0205345eff25" name="gafe136208d4b863f30faa0205345eff25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe136208d4b863f30faa0205345eff25">&#9670;&#160;</a></span>to_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; <br />
requires std::is_signed_v&lt;Type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::make_unsigned_t&lt; Type &gt; fcppt::cast::to_unsigned </td>
          <td>(</td>
          <td class="paramtype">Type const</td>          <td class="paramname"><span class="paramname"><em>_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a signed int to its unsigned type. </p>
<p>Converts <em>_value</em> to its unsigned type. This cast is unsafe and should only be used if <em>_value</em> is positive.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Must be a signed type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0344507522ab03feffdff1ae5b605550" name="ga0344507522ab03feffdff1ae5b605550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0344507522ab03feffdff1ae5b605550">&#9670;&#160;</a></span>to_void()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::cast::to_void </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts an expression to void. </p>
<p>Casts <em>_value</em> to void, ignoring the expression. This is useful if you want to avoid using an expression, for example if an expression is used to do static type checking (e.g. for completeness).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Can be any object type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_value</td><td>The value to cast to void </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4906da28a01732af5dd1aac123f56457" name="ga4906da28a01732af5dd1aac123f56457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4906da28a01732af5dd1aac123f56457">&#9670;&#160;</a></span>to_void_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * fcppt::cast::to_void_ptr </td>
          <td>(</td>
          <td class="paramtype">Source *const</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer to a pointer to void. </p>

</div>
</div>
<a id="ga9cb8ff2d84fa52a598224533e71ff6ed" name="ga9cb8ff2d84fa52a598224533e71ff6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb8ff2d84fa52a598224533e71ff6ed">&#9670;&#160;</a></span>to_void_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void const  * fcppt::cast::to_void_ptr </td>
          <td>(</td>
          <td class="paramtype">Source const *const</td>          <td class="paramname"><span class="paramname"><em>_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer to const to a pointer to const void. </p>

</div>
</div>
<a id="ga3356a49a81c20c6daec4b92dffc8614e" name="ga3356a49a81c20c6daec4b92dffc8614e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3356a49a81c20c6daec4b92dffc8614e">&#9670;&#160;</a></span>truncation_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dest , typename Source &gt; <br />
requires (std::conjunction_v&lt;std::is_integral&lt;Source&gt;, std::is_integral&lt;Dest&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html">fcppt::optional::object</a>&lt; Dest &gt; fcppt::cast::truncation_check </td>
          <td>(</td>
          <td class="paramtype">Source const</td>          <td class="paramname"><span class="paramname"><em>_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast between integral types, checking for truncation. </p>
<p>Casts <em>_source</em> of type <em>Source</em> to the type <em>Dest</em>. It returns the converted value iff the conversion results in no truncation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dest</td><td>Must be an integral type</td></tr>
    <tr><td class="paramname">Source</td><td>Must be an integral type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 21 2024 15:14:46 for fcppt by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</body>
</html>
