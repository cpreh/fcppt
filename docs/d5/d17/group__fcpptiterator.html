<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fcppt: fcppt.iterator</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname"><span id="projectnumber">&#160;5.0.0</span>
   </div>
   <div id="projectbrief">Freundlich&#39;s C++ toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">fcppt.iterator <div class="ingroups"><a class="el" href="../../df/df4/group__fcpptmain.html">fcppt</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Description</h2>
<p>Iterator adaptors and utilities. </p>
<h1 class="doxsection"><a class="anchor" id="fcpptiterator_implementation"></a>
Implementing iterators</h1>
<p>There are five iterator categories. Each one dictates which operations an iterator needs to provide and what these operations mean: </p><ul>
<li>
<em>Input iterator</em>: Defines a single-pass range that can only be read from. </li>
<li>
<em>Output itereator</em>: Defines a single-pass range that can only be written to. </li>
<li>
<em>Forward iterator</em>: Defines a range that consists of real objects, i.e. dereferencing an iterator yields a reference. Such an iterator can only be incremented. A forward iterator is also in input iterator. </li>
<li>
<em>Bidirectional iterator</em>: A forward iterator that can also be decremented. </li>
<li>
<em>Random access iterator</em>: A bidirectional iterator that supports random access. </li>
</ul>
<p>Forward, bidirectional and random access iterators are also output iterators if they are not const iterators.</p>
<p>The standard library provides a tag type for each iterator category. <code>std::random_access_iterator_tag</code> derives from <code>std::bidirectional_iterator_tag</code>, which derives from <code>std::forward_iterator_tag</code>, which derives from <code>std::input_iterator_tag</code>. In this hierarchy, <code>std::output_iterator_tag</code> is not used, meaning that this tag only comes into play when an iterator is an output iterator only.</p>
<p>For each category, a multitude of operations need to be implemented, a lot of which can be implemented from other operations, which commonly leads to a lot of boiler-plate code. For example, <code>operator!=</code> can be implemented from <code>operator==</code>, and <code>operator&lt;</code> (and <code>&lt;=</code>,<code>&gt;</code> and <code>&gt;=</code>) can be implemented from <code>operator-</code> that calculates the distance of two random access iterators. However, you might want to provide fundamentally different implementations for all of these (for performance reasons), but this is very rare. To make implementing iterators easier, <a class="el" href="../../db/dee/classfcppt_1_1iterator_1_1base.html" title="A template for implementing iterators.">fcppt::iterator::base</a> provides most operations using a default implementation, which the actual iterator type derives from. This class gets an <a class="el" href="../../d5/ddc/structfcppt_1_1iterator_1_1types.html" title="The types passed to fcppt::iterator::base.">fcppt::iterator::types</a> as its template parameter, which consists of: </p><ul>
<li>
The actual iterator type, which is the type deriving from <a class="el" href="../../db/dee/classfcppt_1_1iterator_1_1base.html" title="A template for implementing iterators.">fcppt::iterator::base</a>. </li>
<li>
The <code>reference</code> type of the iterator, which is what <code>operator*</code> returns. </li>
<li>
The <code>value_type</code>, which is what users of the iterator can use to store a copy of a dereferenced object. </li>
<li>
The <code>difference_type</code>, which is used to calculate distances between two iterators. This is only significant for random access iterator. Usually, this is <code>std::ptrdiff_t</code>. </li>
<li>
The <code>iterator_category</code>. </li>
</ul>
<p>Deriving from <a class="el" href="../../db/dee/classfcppt_1_1iterator_1_1base.html" title="A template for implementing iterators.">fcppt::iterator::base</a> also inherits all of these typedefs. In addition, <code>pointer</code> is also defined which is always <code>std::remove_reference&lt;reference&gt;::type *</code>, i.e. for forward iterators it is <code>T *</code> if <code>reference</code> is <code>T &amp;</code> and <code>T const *</code> if <code>reference</code> is <code>T const &amp;</code> for some type <code>T</code>.</p>
<p>Let <code>It</code> be the type of the iterator we are going to implement, i.e. the type deriving from <a class="el" href="../../db/dee/classfcppt_1_1iterator_1_1base.html" title="A template for implementing iterators.">fcppt::iterator::base</a>. The following operations need to be implemented by the derived class as <em>public</em> member functions:</p>
<ul>
<li>
For Input iterator and output iterators: <table class="doxtable">
<tr>
<td><code>reference operator*() const</code> </td><td>Returns the object at the current position. </td></tr>
<tr>
<td><code>bool equal(It it) const</code> </td><td>Returns <code>true</code> if <code>*this</code> and <code>it</code> point to the same position. For input and output iterators, this is only used to tell if they reached their end. </td></tr>
<tr>
<td><code>void increment()</code> </td><td>Moves the iterator to the next position. </td></tr>
</table>
</li>
<li>
Forward iterators must provide the same operations as input iterators. In addition, they must have a default constructor and <code>reference</code> must be an actual reference type.  </li>
<li>
Bidirectional iterators must provide the same operations as forward iterators. In addition, they must also provide: <table class="doxtable">
<tr>
<td><code>void decrement()</code> </td><td>Moves the iterator to the previous position. This operation is the inverse to <code>void increment()</code>. </td></tr>
</table>
</li>
<li>
Random access iterators must provide the same operations as bidirectional iterators. In addition, they must also provide: <table class="doxtable">
<tr>
<td><code>void advance(difference_type d)</code> </td><td>Moves the iterator forwards (backwards if <code>d</code> is negative) by <code>d</code> positions. This must be equal to <code>d</code> increment operations (<code>-d</code> decrement operations if <code>d</code> is negative). </td></tr>
<tr>
<td><code>difference_type distance_to(It it) const</code> </td><td>The distance <code>d</code> of <code>*this</code> to <code>it</code>, meaning that if <code>*this</code> is moved forwards by <code>d</code> positions, then <code>*this</code> and <code>it</code> are equal. </td></tr>
</table>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For random access iterators, we could define <code>void increment()</code> in terms of <code>advance(1)</code>, <code>void decrement()</code> in terms of <code>advance(-1)</code> and <code>bool equal_to(It it) const</code> as <code>distance_to(it) == 0</code>. For the time being, this is not done so that the sets of operations to implement are consistent with the order of iterator categories.</dd></dl>
<p>Here is an example of how to implement a random access iterator which is also an output iterator. For simplicity, we implement a simple iterator using pointers over <code>int</code>. First, we declare the types we are going to use:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_iterator;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>iterator_types = <a class="code hl_struct" href="../../d5/ddc/structfcppt_1_1iterator_1_1types.html" title="The types passed to fcppt::iterator::base.">fcppt::iterator::types</a>&lt;</div>
<div class="line">    my_iterator, <span class="comment">// The derived type</span></div>
<div class="line">    int, <span class="comment">// The value type</span></div>
<div class="line">    <span class="keywordtype">int</span> &amp;, <span class="comment">// The reference type, which is non const so the iterator is also an output iterator</span></div>
<div class="line">    std::ptrdiff_t, <span class="comment">// The difference type for pointers</span></div>
<div class="line">    std::random_access_iterator_tag <span class="comment">// The iterator category</span></div>
<div class="line">    &gt;;</div>
</div><!-- fragment --><p>Next, we derive from <a class="el" href="../../db/dee/classfcppt_1_1iterator_1_1base.html" title="A template for implementing iterators.">fcppt::iterator::base</a> and implement all operations required for random access iterators:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_iterator : <span class="keyword">public</span> <a class="code hl_class" href="../../db/dee/classfcppt_1_1iterator_1_1base.html" title="A template for implementing iterators.">fcppt::iterator::base</a>&lt;iterator_types&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Random access iterators require a default constructor.</span></div>
<div class="line">  my_iterator() : ptr_{nullptr} {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">explicit</span> my_iterator(pointer <span class="keyword">const</span> _ptr) : ptr_{_ptr} {}</div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <a class="code hl_typedef" href="../../da/d65/group__fcpptoptional.html#ga365798ba3e5a9e4663b601b2ddf3c3e6" title="Optional of a reference.">reference</a> <a class="code hl_function" href="../../db/dee/classfcppt_1_1iterator_1_1base.html#a89b06fd0a3d00aefccd757e73c59df4b">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *ptr_; }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> increment() { ++ptr_; } <span class="comment">// NOLINT(cppcoreguidelines-pro-bounds-pointer-arithmetic)</span></div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <span class="keywordtype">bool</span> <a class="code hl_typedef" href="../../d2/d83/group__fcpptmpl.html#ga2a8b4a0040e97a4dd995b50adb28a1ec" title="Checks if two maps are equal.">equal</a>(my_iterator <span class="keyword">const</span> &amp;_other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ptr_ == _other.ptr_; }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> decrement() { --ptr_; } <span class="comment">// NOLINT(cppcoreguidelines-pro-bounds-pointer-arithmetic)</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> advance(difference_type <span class="keyword">const</span> _distance) { ptr_ += _distance; } <span class="comment">// NOLINT(cppcoreguidelines-pro-bounds-pointer-arithmetic)</span></div>
<div class="line"> </div>
<div class="line">  [[nodiscard]] <a class="code hl_typedef" href="../../dc/d53/group__fcpptmath.html#ga1896951ceed894793124aef2d9bfbfcc" title="The difference type used for structure sizes.">difference_type</a> distance_to(my_iterator <span class="keyword">const</span> &amp;_other)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> _other.ptr_ - ptr_;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  pointer ptr_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Here is an example showing how our iterator can be used:</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="../../db/d7f/classfcppt_1_1array_1_1object.html">fcppt::array::object&lt;int, 3&gt;</a> <a class="code hl_typedef" href="../../d9/de5/group__fcpptcontainerbitfield.html#gaa7070687fc690b5043e8bed361597e38" title="Meta function to retrieve the internal storage type used by fcppt::container::bitfield::object.">array</a>{1, 2, 3};</div>
<div class="line"> </div>
<div class="line">  my_iterator <span class="keyword">const</span> start(&amp;*<a class="code hl_typedef" href="../../d9/de5/group__fcpptcontainerbitfield.html#gaa7070687fc690b5043e8bed361597e38" title="Meta function to retrieve the internal storage type used by fcppt::container::bitfield::object.">array</a>.begin());</div>
<div class="line"> </div>
<div class="line">  my_iterator it{start};</div>
<div class="line"> </div>
<div class="line">  ++it;</div>
<div class="line"> </div>
<div class="line">  *it = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Array is now {1,5,3}</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Prints 5</span></div>
<div class="line">  std::cout &lt;&lt; fcppt::array::get&lt;1U&gt;(array) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Prints 1</span></div>
<div class="line">  std::cout &lt;&lt; (it - start) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:fcppt_3A_3Aiterator_3A_3Abase_3C_20Types_20_3E" id="r_fcppt_3A_3Aiterator_3A_3Abase_3C_20Types_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dee/classfcppt_1_1iterator_1_1base.html">fcppt::iterator::base&lt; Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for implementing iterators.  <a href="../../db/dee/classfcppt_1_1iterator_1_1base.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Aiterator_3A_3Atypes_3C_20Derived_2C_20ValueType_2C_20Reference_2C_20DifferenceType_2C_20IteratorCategory_20_3E" id="r_fcppt_3A_3Aiterator_3A_3Atypes_3C_20Derived_2C_20ValueType_2C_20Reference_2C_20DifferenceType_2C_20IteratorCategory_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddc/structfcppt_1_1iterator_1_1types.html">fcppt::iterator::types&lt; Derived, ValueType, Reference, DifferenceType, IteratorCategory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The types passed to <a class="el" href="../../db/dee/classfcppt_1_1iterator_1_1base.html" title="A template for implementing iterators.">fcppt::iterator::base</a>.  <a href="../../d5/ddc/structfcppt_1_1iterator_1_1types.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga28c9938ef8cf0a4097ccbaaae9ce8ac4" id="r_ga28c9938ef8cf0a4097ccbaaae9ce8ac4"><td class="memTemplParams" colspan="2">template&lt;typename Category, typename CategoryRef&gt; </td></tr>
<tr class="memitem:ga28c9938ef8cf0a4097ccbaaae9ce8ac4 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga28c9938ef8cf0a4097ccbaaae9ce8ac4">fcppt::iterator::category_at_least</a> = std::is_base_of&lt;CategoryRef, Category&gt;</td></tr>
<tr class="memdesc:ga28c9938ef8cf0a4097ccbaaae9ce8ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator category includes another.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga28c9938ef8cf0a4097ccbaaae9ce8ac4" name="ga28c9938ef8cf0a4097ccbaaae9ce8ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28c9938ef8cf0a4097ccbaaae9ce8ac4">&#9670;&#160;</a></span>category_at_least</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Category, typename CategoryRef&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga28c9938ef8cf0a4097ccbaaae9ce8ac4">fcppt::iterator::category_at_least</a> = std::is_base_of&lt;CategoryRef, Category&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator category includes another. </p>
<p>Checks if <em class="arg">Category</em> models <em class="arg">CategoryRef</em>. For example, if <em class="arg">Category</em> is <code>std::bidirectional_iterator_category</code> and <em class="arg">CategoryRef</em> is <code>std::forward_iterator_category</code>, then the value is true.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Category</td><td>Must be one of the <code>std::</code> iterator category classes.</td></tr>
    <tr><td class="paramname">CategoryRef</td><td>Must be one of the <code>std::</code> iterator category classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for fcppt by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</body>
</html>
