<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fcppt: fcppt.mpl</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname"><span id="projectnumber">&#160;5.1.0</span>
   </div>
   <div id="projectbrief">Freundlich&#39;s C++ toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">fcppt.mpl <div class="ingroups"><a class="el" href="../../df/df4/group__fcpptmain.html">fcppt</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Description</h2>
<p>A metaprogramming library. </p>
<ul>
<li>
<a class="el" href="#fcpptmpl_introduction">Introduction</a> </li>
<li>
<a class="el" href="#fcpptmpl_lambdas">Lambdas</a> </li>
</ul>
<h1 class="doxsection"><a class="anchor" id="fcpptmpl_introduction"></a>
Introduction</h1>
<p>MPL stands for meta programming library and refers to the fact that you can write "programs" using C++ templates. As an example, consider the following variant type:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt; <span class="keyword">class </span>variant</div>
<div class="line">{</div>
</div><!-- fragment --><p>First of all, an implementation would have to check if <code>Types...</code> are disjoint. Second of all, it would have to gather the sizes of all the types. This can all be written by hand, often using recursion on a template parameter pack, or it can be done using a MP library:</p>
<div class="fragment"><div class="line">  <span class="keyword">using </span>type_list = fcppt::mpl::list::object&lt;Types...&gt;;</div>
<div class="line">  <span class="keyword">static_assert</span>(fcppt::mpl::list::distinct&lt;type_list&gt;::value);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">using </span>sizeof_ = <a class="code hl_typedef" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type</a>&lt;<span class="keyword">sizeof</span>(T)&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span>sizes = <a class="code hl_typedef" href="#ga4400e3ec8ea647995287182f7561073c" title="Applies a lambda to every element of a list.If List=list::object&lt;L_1,...,L_n&gt; and L holds a function ...">fcppt::mpl::list::map&lt;type_list,fcppt::mpl::lambda&lt;sizeof_&gt;</a>&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>There are two key concepts here:</p>
<ul>
<li>
<p class="startli">Instead of using a template parameter pack <code>Types...</code> directly, we use <code><a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html">fcppt::mpl::list::object&lt;Types...&gt;</a></code>. This way, the parameter pack becomes a single type and can be handled more easily. </p>
<p class="endli"></p>
</li>
<li>
Instead of using a template-template parameter <code>template&lt;typename...&gt; class F</code> directly, we use <code><a class="el" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;F&gt;</a></code>. Again, this way, we turn <code>F</code> into a single template parameter.  </li>
</ul>
<p><a class="el" href="#gaa37dfe05e98e3818c75be090f7e7989a" title="Checks if all elements of a list are pairwise disjoint.Let List = list::object&lt;L_1,...">fcppt::mpl::list::distinct</a> expects an <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object</a> and returns <code>std::true_type</code> if all types in the list are distinct and <code>std::false_type</code> otherwise.</p>
<p><a class="el" href="#ga4400e3ec8ea647995287182f7561073c" title="Applies a lambda to every element of a list.If List=list::object&lt;L_1,...,L_n&gt; and L holds a function ...">fcppt::mpl::list::map</a> applies an <a class="el" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda</a> to every element of a list. For example, if <code>type_list = fcppt::mpl::object::list&lt;int, float&gt;</code>, then <code>sizes = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object</a>&lt;sizeof_&lt;int&gt;,sizeof_&lt;float&gt;&gt;</code>.</p>
<h1 class="doxsection"><a class="anchor" id="fcpptmpl_lambdas"></a>
Lambdas</h1>
<p>To understand how to write MP algorithms, it is important to understand lambdas and how they can be combined. The definition of <a class="el" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda</a> is </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class </span>F&gt; <span class="keyword">struct </span>lambda;</div>
</div><!-- fragment --><p> This way, it can take any template of arbitrary arity:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>add_pointer = <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;std::add_pointer_t&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>common_type = <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;std::common_type_t&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>make_list = <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::list::object&gt;</a>;</div>
</div><!-- fragment --><p>Here, <code>add_pointer</code> is a unary lambda and <code>common_type</code> is a binary lambda. Since <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object</a> is a variadic template, <code>make_list</code> is a variadic lambda.</p>
<p>To actually call a lambda, we use <a class="el" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>r1 = <a class="code hl_typedef" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply&lt;add_pointer,int&gt;</a>;</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;r1,int *&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>r2 = <a class="code hl_typedef" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply&lt;common_type,char,int&gt;</a>;</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;r2,int&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>r3 = <a class="code hl_typedef" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply&lt;make_list,int,float&gt;</a>;</div>
<div class="line"><span class="keyword">static_assert</span>(std::is_same_v&lt;r3,fcppt::mpl::list::object&lt;int,float&gt;&gt;);</div>
</div><!-- fragment --><p>Note that providing the wrong number of template parameters will lead to a compile error, for example <code><a class="el" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply&lt;add_pointer,int,float&gt;</a></code> will not compile.</p>
<p>As terminology, we say that a lambda <code>L</code> <em>holds</em> a function F of arity <code>n</code>, if <code>L = <a class="el" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;F&gt;</a></code> and <code>F</code> is either an n-ary template or a variadic template.</p>
<p>Now consider the following example: We would like to create a lambda that evaluates to true if and only if the first parameter is <code>int</code>. We can implement this writing an explicit function: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using </span>is_int_impl = std::is_same&lt;T,int&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>is_int = <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;is_int_impl&gt;</a>;</div>
</div><!-- fragment --><p> To do this more directly, we can also write the following code: </p><div class="fragment"><div class="line"><span class="keyword">using </span>is_int2 = <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind&lt;fcppt::mpl::lambda&lt;std::is_same&gt;</a>, <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>, <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;int&gt;</a>&gt;;</div>
</div><!-- fragment --><p> To understand why these are equivalent, we have to understand what <code><a class="el" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg</a></code>, <code><a class="el" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant</a></code> and <code><a class="el" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a></code> do.</p>
<ul>
<li>
<p class="startli"><code><a class="el" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg</a><span class="tt">&lt;i&gt;</span></code> is the i'th projection function. Formally, for every integer <code>m &gt;= i</code> it is a lambda that holds a function <code>F_m</code> of arity <code>m</code>, such that <code>F_m&lt;T_1,...,T_m&gt; = T_i</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;C&gt;</a></code> is the constant function. Formally, for every integer <code>m</code> it holds a function <code>F_m</code> of arity <code>m</code>, such that <code>F_m&lt;T_1,...,T_m&gt; = C</code>.</p>
<p class="endli"></p>
</li>
<li>
<code><a class="el" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a></code> is function composition. Let <code>L</code> be a lambda that holds a function <code>G</code> of arity <code>k</code> and let <code>L_1, ..., L_k</code> be lambdas that hold functions <code>G_1, ..., G_k</code> of arity <code>m</code>. Then <code><a class="el" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind&lt;L,L_1,...,L_k&gt;</a></code> holds a function <code>F</code> of arity <code>m</code>, such that <code>F&lt;T_1,...,T_m&gt; = G&lt;G_1&lt;T_1,...,T_m&gt;,...,G_k&lt;T_1,...,T_m&gt;&gt;</code>. </li>
</ul>
<p>In our example, <code><a class="el" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;std::is_same&gt;</a></code> holds a function or arity 2, and both <code><a class="el" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a></code> and <code><a class="el" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;int&gt;</a></code> hold functions or arity 1. Therefore, we have <code>k=2</code> and <code>m=1</code> and <code>is_int2</code> holds a function of arity 1. We have </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply&lt;is_int2,T&gt;</a></div>
<div class="line">= std::is_same&lt;fcppt::mpl::apply&lt;fcppt::mpl::arg&lt;1&gt;,T&gt;,<a class="code hl_typedef" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply&lt;fcppt::mpl::constant&lt;int&gt;</a>,T&gt;&gt;</div>
<div class="line">= std::is_same&lt;T,int&gt;</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:fcppt_3A_3Ampl_3A_3Alambda_3C_20F_20_3E" id="r_fcppt_3A_3Ampl_3A_3Alambda_3C_20F_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html">fcppt::mpl::lambda&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lambda type.  <a href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Ampl_3A_3Alist_3A_3Aobject_3C_20Args_20_3E" id="r_fcppt_3A_3Ampl_3A_3Alist_3A_3Aobject_3C_20Args_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html">fcppt::mpl::list::object&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list type used by this library.  <a href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Ampl_3A_3Amap_3A_3Aelement_3C_20Key_2C_20Value_20_3E" id="r_fcppt_3A_3Ampl_3A_3Amap_3A_3Aelement_3C_20Key_2C_20Value_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html">fcppt::mpl::map::element&lt; Key, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The element type of a map.An element of a map is a key-value pair.  <a href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Ampl_3A_3Amap_3A_3Aobject_3C_20Args_20_3E" id="r_fcppt_3A_3Ampl_3A_3Amap_3A_3Aobject_3C_20Args_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html">fcppt::mpl::map::object&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map type used by this library.  <a href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html#details">More...</a><br /></td></tr>
<tr class="memitem:fcppt_3A_3Ampl_3A_3Aset_3A_3Aobject_3C_20Args_20_3E" id="r_fcppt_3A_3Ampl_3A_3Aset_3A_3Aobject_3C_20Args_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html">fcppt::mpl::set::object&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set type used by this library.A map is constructed from a variadic list of types, which must be pairwise disjoint.  <a href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga015afd69383d8726187fdf09f3999e55" id="r_ga015afd69383d8726187fdf09f3999e55"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T1, <a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T2&gt; </td></tr>
<tr class="memitem:ga015afd69383d8726187fdf09f3999e55 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga015afd69383d8726187fdf09f3999e55">fcppt::mpl::add</a> = typename fcppt::mpl::detail::add&lt;T1,T2&gt;::type</td></tr>
<tr class="memdesc:ga015afd69383d8726187fdf09f3999e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two integral constants.Let <code>T1 = std::integral_constant&lt;T,V_1&gt;</code> and <code>T2 = std::integral_constant&lt;T,V_2&gt;</code>. Then the result is <code>std::integral_constant&lt;T,V_1 + V_2&gt;</code>.  <br /></td></tr>
<tr class="memitem:ga470122143165d1d2f2037b7122760ef6" id="r_ga470122143165d1d2f2037b7122760ef6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, typename... Args&gt; </td></tr>
<tr class="memitem:ga470122143165d1d2f2037b7122760ef6 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga470122143165d1d2f2037b7122760ef6">fcppt::mpl::apply</a> = typename fcppt::mpl::detail::apply&lt;L,Args...&gt;::type</td></tr>
<tr class="memdesc:ga470122143165d1d2f2037b7122760ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a lambda.  <br /></td></tr>
<tr class="memitem:ga9244a4b57516f164aec17b763fa5fc32" id="r_ga9244a4b57516f164aec17b763fa5fc32"><td class="memTemplParams" colspan="2">template&lt;std::size_t Arg&gt; </td></tr>
<tr class="memitem:ga9244a4b57516f164aec17b763fa5fc32 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9244a4b57516f164aec17b763fa5fc32">fcppt::mpl::arg</a> = typename fcppt::mpl::detail::arg&lt;Arg - 1U&gt;::type</td></tr>
<tr class="memdesc:ga9244a4b57516f164aec17b763fa5fc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lambda that returns an argument in a specific position.  <br /></td></tr>
<tr class="memitem:ga1ec959d9b6cde6e4a75722c8995b2c6d" id="r_ga1ec959d9b6cde6e4a75722c8995b2c6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> ... Ls&gt; </td></tr>
<tr class="memitem:ga1ec959d9b6cde6e4a75722c8995b2c6d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d">fcppt::mpl::bind</a> = typename fcppt::mpl::detail::bind&lt;L,Ls...&gt;::type</td></tr>
<tr class="memdesc:ga1ec959d9b6cde6e4a75722c8995b2c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function composition on multiple lambdas.  <br /></td></tr>
<tr class="memitem:ga9035314fa94a8a0d789b3c8bc32337a1" id="r_ga9035314fa94a8a0d789b3c8bc32337a1"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga9035314fa94a8a0d789b3c8bc32337a1 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9035314fa94a8a0d789b3c8bc32337a1">fcppt::mpl::constant</a> = typename fcppt::mpl::detail::constant&lt;T&gt;::type</td></tr>
<tr class="memdesc:ga9035314fa94a8a0d789b3c8bc32337a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant lambda.  <br /></td></tr>
<tr class="memitem:ga43de01e17953b583ab7447679154ee3d" id="r_ga43de01e17953b583ab7447679154ee3d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T&gt; </td></tr>
<tr class="memitem:ga43de01e17953b583ab7447679154ee3d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga43de01e17953b583ab7447679154ee3d">fcppt::mpl::dec</a> = typename fcppt::mpl::detail::dec&lt;T&gt;::type</td></tr>
<tr class="memdesc:ga43de01e17953b583ab7447679154ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts one from an integral constant.Let <code>T = std::integral_constant&lt;U,V&gt;</code>. Then the result is <code>std::integral_constant&lt;U,V--&gt;</code>.  <br /></td></tr>
<tr class="memitem:gab410a41074c2b7142d5af3a1210901c4" id="r_gab410a41074c2b7142d5af3a1210901c4"><td class="memTemplParams" colspan="2">template&lt;typename Function&gt; </td></tr>
<tr class="memitem:gab410a41074c2b7142d5af3a1210901c4 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab410a41074c2b7142d5af3a1210901c4">fcppt::mpl::function_args</a> = typename fcppt::mpl::detail::function_args&lt;Function&gt;::type</td></tr>
<tr class="memdesc:gab410a41074c2b7142d5af3a1210901c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The argument types of a function as a list.  <br /></td></tr>
<tr class="memitem:gab7eab87e3c553876869958966dd65fc9" id="r_gab7eab87e3c553876869958966dd65fc9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T1, <a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T2&gt; </td></tr>
<tr class="memitem:gab7eab87e3c553876869958966dd65fc9 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab7eab87e3c553876869958966dd65fc9">fcppt::mpl::greater</a> = typename fcppt::mpl::detail::greater&lt;T1,T2&gt;::type</td></tr>
<tr class="memdesc:gab7eab87e3c553876869958966dd65fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if one integral constant is greater than another.Let <code>T1 = std::integral_constant&lt;T,V_1&gt;</code> and <code>T2 = std::integral_constant&lt;T,V_2&gt;</code>. Then the result is <code>std::bool_constant&lt;(V1 &gt; V2)&gt;</code>.  <br /></td></tr>
<tr class="memitem:ga8e5a6472377cd4fa26ad68736309705c" id="r_ga8e5a6472377cd4fa26ad68736309705c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d9/de9/conceptfcppt_1_1mpl_1_1bool__concept.html">fcppt::mpl::bool_concept</a> B, typename T, typename F&gt; </td></tr>
<tr class="memitem:ga8e5a6472377cd4fa26ad68736309705c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e5a6472377cd4fa26ad68736309705c">fcppt::mpl::if_</a> = std::conditional_t&lt;B::value, T, F&gt;</td></tr>
<tr class="memdesc:ga8e5a6472377cd4fa26ad68736309705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The if-then-else function.Similar to <code>std::conditional_t</code> but takes a <code><a class="el" href="../../d9/de9/conceptfcppt_1_1mpl_1_1bool__concept.html" title="Concept for boolean constants.">bool_concept</a></code>, i.e., a <code>std::bool_constant&lt;V&gt;</code> for any <code>bool V</code> instead of <code>V</code> directly.  <br /></td></tr>
<tr class="memitem:ga796e2d02b2681f585321721af80f1f07" id="r_ga796e2d02b2681f585321721af80f1f07"><td class="memTemplParams" colspan="2">template&lt;typename F, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> L&gt; </td></tr>
<tr class="memitem:ga796e2d02b2681f585321721af80f1f07 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga796e2d02b2681f585321721af80f1f07">fcppt::mpl::is_invocable</a></td></tr>
<tr class="memdesc:ga796e2d02b2681f585321721af80f1f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a function can be invoked with a given argument list.Checks if function <code>F</code> can be invoked with the types in <code>L</code>, i.e. if <code>L = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, then the result is.  <br /></td></tr>
<tr class="memitem:ga95a010389d298e3c7d3416dd68fe3c2d" id="r_ga95a010389d298e3c7d3416dd68fe3c2d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga95a010389d298e3c7d3416dd68fe3c2d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga95a010389d298e3c7d3416dd68fe3c2d">fcppt::mpl::is_lambda</a> = typename fcppt::mpl::detail::is_lambda&lt;T&gt;::type</td></tr>
<tr class="memdesc:ga95a010389d298e3c7d3416dd68fe3c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is a lambda.  <br /></td></tr>
<tr class="memitem:ga1f1e48b7a2643560d0754414b84c68c5" id="r_ga1f1e48b7a2643560d0754414b84c68c5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga1f1e48b7a2643560d0754414b84c68c5 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f1e48b7a2643560d0754414b84c68c5">fcppt::mpl::is_size_type</a> = typename fcppt::mpl::detail::is_size_type&lt;T&gt;::type</td></tr>
<tr class="memdesc:ga1f1e48b7a2643560d0754414b84c68c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is a <a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">size_type</a>.<code>T</code> is a size type if and only if it is of the form <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;N&gt;</a></code> for some <code>std::size_t N</code>.  <br /></td></tr>
<tr class="memitem:ga8ce5b4df7e5740c778c61d2c36385967" id="r_ga8ce5b4df7e5740c778c61d2c36385967"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T1, <a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T2&gt; </td></tr>
<tr class="memitem:ga8ce5b4df7e5740c778c61d2c36385967 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8ce5b4df7e5740c778c61d2c36385967">fcppt::mpl::less</a> = typename fcppt::mpl::detail::less&lt;T1, T2&gt;::type</td></tr>
<tr class="memdesc:ga8ce5b4df7e5740c778c61d2c36385967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if one integral constant is less than another.Let <code>T1 = std::integral_constant&lt;T,V_1&gt;</code> and <code>T2 = std::integral_constant&lt;T,V_2&gt;</code>. Then the result is <code>std::bool_constant&lt;(V1 &lt; V2)&gt;</code>.  <br /></td></tr>
<tr class="memitem:ga267a7faf7e25557be2ba8587acfc9748" id="r_ga267a7faf7e25557be2ba8587acfc9748"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </td></tr>
<tr class="memitem:ga267a7faf7e25557be2ba8587acfc9748 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga267a7faf7e25557be2ba8587acfc9748">fcppt::mpl::list::all_of</a></td></tr>
<tr class="memdesc:ga267a7faf7e25557be2ba8587acfc9748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a predicate holds for all types of a list.If <code>List=<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L</code> holds a function <code>F</code> of arity <code>1</code>, then the result is.  <br /></td></tr>
<tr class="memitem:ga166a33fe4d091a231ecba33d84f5f37e" id="r_ga166a33fe4d091a231ecba33d84f5f37e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </td></tr>
<tr class="memitem:ga166a33fe4d091a231ecba33d84f5f37e template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga166a33fe4d091a231ecba33d84f5f37e">fcppt::mpl::list::any_of</a></td></tr>
<tr class="memdesc:ga166a33fe4d091a231ecba33d84f5f37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a predicate holds for any type of a list.If <code>List=<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L</code> holds a function <code>F</code> of arity <code>1</code>, then the result is.  <br /></td></tr>
<tr class="memitem:ga6cc13ef9375ae14104cde0769a8c4401" id="r_ga6cc13ef9375ae14104cde0769a8c4401"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List1, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List2&gt; </td></tr>
<tr class="memitem:ga6cc13ef9375ae14104cde0769a8c4401 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cc13ef9375ae14104cde0769a8c4401">fcppt::mpl::list::append</a> = typename fcppt::mpl::list::detail::append&lt;List1,List2&gt;::type</td></tr>
<tr class="memdesc:ga6cc13ef9375ae14104cde0769a8c4401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends two lists.If <code>List1 = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>List2 = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;R_1,...,R_m&gt;</a></code> then the result is.  <br /></td></tr>
<tr class="memitem:ga0b3918537ebf5d2caa2b8f2a65de24da" id="r_ga0b3918537ebf5d2caa2b8f2a65de24da"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> Args&gt; </td></tr>
<tr class="memitem:ga0b3918537ebf5d2caa2b8f2a65de24da template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0b3918537ebf5d2caa2b8f2a65de24da">fcppt::mpl::list::apply</a> = typename fcppt::mpl::list::detail::apply&lt;L,Args&gt;::type</td></tr>
<tr class="memdesc:ga0b3918537ebf5d2caa2b8f2a65de24da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a lambda using a list of arguments.  <br /></td></tr>
<tr class="memitem:ga31cf28041093cda43d6cdf722dc2ad54" id="r_ga31cf28041093cda43d6cdf722dc2ad54"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../de/d0f/conceptfcppt_1_1mpl_1_1size__type__concept.html">fcppt::mpl::size_type_concept</a> Index&gt; </td></tr>
<tr class="memitem:ga31cf28041093cda43d6cdf722dc2ad54 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga31cf28041093cda43d6cdf722dc2ad54">fcppt::mpl::list::at</a> = typename fcppt::mpl::list::detail::at&lt;List,Index&gt;::type</td></tr>
<tr class="memdesc:ga31cf28041093cda43d6cdf722dc2ad54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The element of a list at a given position.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>Index = <a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;j&gt;</a></code> with <code>0 &lt;= j &lt; n</code> then the result is <code>L_{j-1}</code>.  <br /></td></tr>
<tr class="memitem:ga7866870faf1a6d781fdaed62816fb686" id="r_ga7866870faf1a6d781fdaed62816fb686"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:ga7866870faf1a6d781fdaed62816fb686 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7866870faf1a6d781fdaed62816fb686">fcppt::mpl::list::back</a> = <a class="el" href="#ga31cf28041093cda43d6cdf722dc2ad54">fcppt::mpl::list::at</a>&lt;List,<a class="el" href="#ga43de01e17953b583ab7447679154ee3d">fcppt::mpl::dec</a>&lt;<a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a>&lt;List&gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga7866870faf1a6d781fdaed62816fb686"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last element of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is <code>L_n</code>.  <br /></td></tr>
<tr class="memitem:gaa037212eb460efe98af4f31a7a9abe81" id="r_gaa037212eb460efe98af4f31a7a9abe81"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename E&gt; </td></tr>
<tr class="memitem:gaa037212eb460efe98af4f31a7a9abe81 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa037212eb460efe98af4f31a7a9abe81">fcppt::mpl::list::contains</a></td></tr>
<tr class="memdesc:gaa037212eb460efe98af4f31a7a9abe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a list contains an element.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. The result is <code>std::true_type</code> if <code>E = L_i</code> for some <code>1 &lt;= i &lt;= n</code>. Otherwise, it is <code>std::false_type</code>.  <br /></td></tr>
<tr class="memitem:gaa37dfe05e98e3818c75be090f7e7989a" id="r_gaa37dfe05e98e3818c75be090f7e7989a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gaa37dfe05e98e3818c75be090f7e7989a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa37dfe05e98e3818c75be090f7e7989a">fcppt::mpl::list::distinct</a> = typename fcppt::mpl::list::detail::distinct&lt;List&gt;::type</td></tr>
<tr class="memdesc:gaa37dfe05e98e3818c75be090f7e7989a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all elements of a list are pairwise disjoint.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. If <code>L_i != L_j</code> for all <code>1 &lt;= i != j &lt;= n</code> then the result is <code>std::true_type</code>. Otherwise, it is <code>std::false_type</code>.  <br /></td></tr>
<tr class="memitem:ga6c0159536abc5eebf9365da5bdb17697" id="r_ga6c0159536abc5eebf9365da5bdb17697"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../de/d0f/conceptfcppt_1_1mpl_1_1size__type__concept.html">fcppt::mpl::size_type_concept</a> S&gt; </td></tr>
<tr class="memitem:ga6c0159536abc5eebf9365da5bdb17697 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6c0159536abc5eebf9365da5bdb17697">fcppt::mpl::list::drop</a></td></tr>
<tr class="memdesc:ga6c0159536abc5eebf9365da5bdb17697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes some elements of a list from the beginning.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is.  <br /></td></tr>
<tr class="memitem:gab8f9810134bbeceb5dfeb17554925200" id="r_gab8f9810134bbeceb5dfeb17554925200"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gab8f9810134bbeceb5dfeb17554925200 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab8f9810134bbeceb5dfeb17554925200">fcppt::mpl::list::empty</a> = std::is_same&lt;<a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a>&lt;List&gt;,<a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311">fcppt::mpl::size_type</a>&lt;0U&gt;&gt;</td></tr>
<tr class="memdesc:gab8f9810134bbeceb5dfeb17554925200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a list is empty.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. If <code>n = 0</code> then <code>std::true_type</code> is returned. Otherwise, <code>std::false_type</code>is returned.  <br /></td></tr>
<tr class="memitem:ga830ecf262cc8fc591e0dc72ba403ecca" id="r_ga830ecf262cc8fc591e0dc72ba403ecca"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, typename V&gt; </td></tr>
<tr class="memitem:ga830ecf262cc8fc591e0dc72ba403ecca template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga830ecf262cc8fc591e0dc72ba403ecca">fcppt::mpl::list::fold</a> = typename fcppt::mpl::list::detail::fold&lt;List,L,V&gt;::type</td></tr>
<tr class="memdesc:ga830ecf262cc8fc591e0dc72ba403ecca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds a list.  <br /></td></tr>
<tr class="memitem:ga6ec74f79aebe29ed119706f65fe60775" id="r_ga6ec74f79aebe29ed119706f65fe60775"><td class="memTemplParams" colspan="2">template&lt;typename Type&gt; </td></tr>
<tr class="memitem:ga6ec74f79aebe29ed119706f65fe60775 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6ec74f79aebe29ed119706f65fe60775">fcppt::mpl::list::from</a> = typename fcppt::mpl::list::detail::from&lt;Type&gt;::type</td></tr>
<tr class="memdesc:ga6ec74f79aebe29ed119706f65fe60775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a template type to a list.If <code>Type = T&lt;L_1, ..., L_n&gt;</code> then the result is <code><a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>.  <br /></td></tr>
<tr class="memitem:gaa2c0eaa24d7a5d4547e1abcd36cb8e70" id="r_gaa2c0eaa24d7a5d4547e1abcd36cb8e70"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gaa2c0eaa24d7a5d4547e1abcd36cb8e70 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa2c0eaa24d7a5d4547e1abcd36cb8e70">fcppt::mpl::list::front</a> = typename fcppt::mpl::list::detail::front&lt;List&gt;::type</td></tr>
<tr class="memdesc:gaa2c0eaa24d7a5d4547e1abcd36cb8e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first element of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is <code>L_1</code>.  <br /></td></tr>
<tr class="memitem:ga2d8cf3988c705c90f6d0ce61188c2b76" id="r_ga2d8cf3988c705c90f6d0ce61188c2b76"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename E&gt; </td></tr>
<tr class="memitem:ga2d8cf3988c705c90f6d0ce61188c2b76 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d8cf3988c705c90f6d0ce61188c2b76">fcppt::mpl::list::index_of</a></td></tr>
<tr class="memdesc:ga2d8cf3988c705c90f6d0ce61188c2b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first index of a given element inside a list.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. Returns <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">size_type&lt;Index&gt;</a></code> where <code>Index</code> is the smallest number such that <code>L_{Index} = E</code>.  <br /></td></tr>
<tr class="memitem:gae0d49c6335f92caf6eff37c3bada9d2a" id="r_gae0d49c6335f92caf6eff37c3bada9d2a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </td></tr>
<tr class="memitem:gae0d49c6335f92caf6eff37c3bada9d2a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0d49c6335f92caf6eff37c3bada9d2a">fcppt::mpl::list::index_of_if</a> = typename fcppt::mpl::list::detail::index_of_if&lt;List,L,<a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311">fcppt::mpl::size_type</a>&lt;0U&gt;&gt;::type</td></tr>
<tr class="memdesc:gae0d49c6335f92caf6eff37c3bada9d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first index where an element matches a predicate inside a list.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and let <code>L</code> hold a function <code>F</code> of arity <code>1</code>. Returns <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">size_type&lt;Index&gt;</a></code> where <code>Index</code> is the smallest number such that <code>F&lt;L_{Index}&gt; = std::true_type</code>.  <br /></td></tr>
<tr class="memitem:gae3c04d65f53d1fb56bc7163925f3874f" id="r_gae3c04d65f53d1fb56bc7163925f3874f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gae3c04d65f53d1fb56bc7163925f3874f template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae3c04d65f53d1fb56bc7163925f3874f">fcppt::mpl::list::indices</a> = <a class="el" href="#ga73ddf174d757a7de05b3899f6758efb0">fcppt::mpl::list::interval</a>&lt;<a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311">fcppt::mpl::size_type</a>&lt;0U&gt;,<a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a>&lt;List&gt;&gt;</td></tr>
<tr class="memdesc:gae3c04d65f53d1fb56bc7163925f3874f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positions of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is.  <br /></td></tr>
<tr class="memitem:ga73ddf174d757a7de05b3899f6758efb0" id="r_ga73ddf174d757a7de05b3899f6758efb0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d1/d60/conceptfcppt_1_1type__traits_1_1integral__constant__concept.html">fcppt::type_traits::integral_constant_concept</a> Begin, <a class="el" href="../../d1/d60/conceptfcppt_1_1type__traits_1_1integral__constant__concept.html">fcppt::type_traits::integral_constant_concept</a> End&gt; </td></tr>
<tr class="memitem:ga73ddf174d757a7de05b3899f6758efb0 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga73ddf174d757a7de05b3899f6758efb0">fcppt::mpl::list::interval</a></td></tr>
<tr class="memdesc:ga73ddf174d757a7de05b3899f6758efb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interval between two numbers.If <code>Begin = std::integral_constant&lt;Type,B&gt;</code> and <code>End = std::integral_constant&lt;Type,E&gt;</code> then the result is.  <br /></td></tr>
<tr class="memitem:gaa618cda6942fa6b51e7ff59571ebe454" id="r_gaa618cda6942fa6b51e7ff59571ebe454"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaa618cda6942fa6b51e7ff59571ebe454 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa618cda6942fa6b51e7ff59571ebe454">fcppt::mpl::list::is_object</a> = typename fcppt::mpl::list::detail::is_object&lt;T&gt;::type</td></tr>
<tr class="memdesc:gaa618cda6942fa6b51e7ff59571ebe454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is a list.  <br /></td></tr>
<tr class="memitem:ga4078e0aeec043d7f455f3aeb0fa1a1f3" id="r_ga4078e0aeec043d7f455f3aeb0fa1a1f3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:ga4078e0aeec043d7f455f3aeb0fa1a1f3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4078e0aeec043d7f455f3aeb0fa1a1f3">fcppt::mpl::list::join</a></td></tr>
<tr class="memdesc:ga4078e0aeec043d7f455f3aeb0fa1a1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins a list of lists.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L_1, ..., L_n</code> are lists, then the result is.  <br /></td></tr>
<tr class="memitem:gab8444e3fb192826357f3311f2fee149d" id="r_gab8444e3fb192826357f3311f2fee149d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> Pred&gt; </td></tr>
<tr class="memitem:gab8444e3fb192826357f3311f2fee149d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab8444e3fb192826357f3311f2fee149d">fcppt::mpl::list::keep_if</a></td></tr>
<tr class="memdesc:gab8444e3fb192826357f3311f2fee149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only keeps elements that satisfy a predicate.Keeps the elements of <em class="arg">List</em> for which <em class="arg">Pred</em> is <code>std::true_type</code>. The order of the elements stays the same.  <br /></td></tr>
<tr class="memitem:ga4400e3ec8ea647995287182f7561073c" id="r_ga4400e3ec8ea647995287182f7561073c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> F&gt; </td></tr>
<tr class="memitem:ga4400e3ec8ea647995287182f7561073c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4400e3ec8ea647995287182f7561073c">fcppt::mpl::list::map</a> = typename fcppt::mpl::list::detail::map&lt;List,F&gt;::type</td></tr>
<tr class="memdesc:ga4400e3ec8ea647995287182f7561073c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a lambda to every element of a list.If <code>List=<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L</code> holds a function <code>F</code> of arity <code>1</code>, then the result is.  <br /></td></tr>
<tr class="memitem:gad15a3cf85bc12f76ed0d03592794c635" id="r_gad15a3cf85bc12f76ed0d03592794c635"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> F, fcppt::mpl::list::object_concept... Lists&gt; </td></tr>
<tr class="memitem:gad15a3cf85bc12f76ed0d03592794c635 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad15a3cf85bc12f76ed0d03592794c635">fcppt::mpl::list::map_multi</a></td></tr>
<tr class="memdesc:gad15a3cf85bc12f76ed0d03592794c635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an n-ary lambda to every element-tuple of n lists.If <code>Lists=<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_{1,1},...,L_{1,k}&gt;, ... <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_{1,n},...,L_{n,k}&gt;</code> and <code>L</code> holds a function <code>F</code> of arity <code>n</code>, then the result is.  <br /></td></tr>
<tr class="memitem:ga0e1733665bfae3f2d0c1ac3147931808" id="r_ga0e1733665bfae3f2d0c1ac3147931808"><td class="memTemplParams" colspan="2">template&lt;typename Sequence&gt; </td></tr>
<tr class="memitem:ga0e1733665bfae3f2d0c1ac3147931808 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0e1733665bfae3f2d0c1ac3147931808">fcppt::mpl::list::maximum</a></td></tr>
<tr class="memdesc:ga0e1733665bfae3f2d0c1ac3147931808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum value of a list.  <br /></td></tr>
<tr class="memitem:ga7a8ad112555323f1961b7eb33ec3dec3" id="r_ga7a8ad112555323f1961b7eb33ec3dec3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:ga7a8ad112555323f1961b7eb33ec3dec3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a8ad112555323f1961b7eb33ec3dec3">fcppt::mpl::list::pop_back</a> = typename fcppt::mpl::list::detail::pop_back&lt;<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html">fcppt::mpl::list::object</a>&lt;&gt;,List&gt;::type</td></tr>
<tr class="memdesc:ga7a8ad112555323f1961b7eb33ec3dec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, where <code>n &gt;= 1</code>, then the result is.  <br /></td></tr>
<tr class="memitem:gaf7e02c8fb85c75f26300e71871145ab9" id="r_gaf7e02c8fb85c75f26300e71871145ab9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename T&gt; </td></tr>
<tr class="memitem:gaf7e02c8fb85c75f26300e71871145ab9 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7e02c8fb85c75f26300e71871145ab9">fcppt::mpl::list::push_back</a> = typename fcppt::mpl::list::detail::push_back&lt;List,T&gt;::type</td></tr>
<tr class="memdesc:gaf7e02c8fb85c75f26300e71871145ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to the back of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, then the result is.  <br /></td></tr>
<tr class="memitem:gaadac5729724bda255877ce68f4222ec6" id="r_gaadac5729724bda255877ce68f4222ec6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename T&gt; </td></tr>
<tr class="memitem:gaadac5729724bda255877ce68f4222ec6 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaadac5729724bda255877ce68f4222ec6">fcppt::mpl::list::push_front</a> = typename fcppt::mpl::list::detail::push_front&lt;List,T&gt;::type</td></tr>
<tr class="memdesc:gaadac5729724bda255877ce68f4222ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to the front of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, then the result is.  <br /></td></tr>
<tr class="memitem:ga9b8d63ef1a311fc83d921fc682c0ae8d" id="r_ga9b8d63ef1a311fc83d921fc682c0ae8d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename T&gt; </td></tr>
<tr class="memitem:ga9b8d63ef1a311fc83d921fc682c0ae8d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9b8d63ef1a311fc83d921fc682c0ae8d">fcppt::mpl::list::remove</a></td></tr>
<tr class="memdesc:ga9b8d63ef1a311fc83d921fc682c0ae8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a specific type from a list.Removes every occurrence of <em class="arg">T</em> from <em class="arg">List</em>. The order of the remaining elements stays the same.  <br /></td></tr>
<tr class="memitem:ga7c80156725be82a99e22a11d50c0fc85" id="r_ga7c80156725be82a99e22a11d50c0fc85"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> Pred&gt; </td></tr>
<tr class="memitem:ga7c80156725be82a99e22a11d50c0fc85 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c80156725be82a99e22a11d50c0fc85">fcppt::mpl::list::remove_if</a></td></tr>
<tr class="memdesc:ga7c80156725be82a99e22a11d50c0fc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements that satisfy a predicate.Removes the elements of <em class="arg">List</em> for which <em class="arg">Pred</em> is <code>std::true_type</code>. The order of the remaining elements stays the same.  <br /></td></tr>
<tr class="memitem:gabdd46e13671bd02c96315a47bd4d4db3" id="r_gabdd46e13671bd02c96315a47bd4d4db3"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="../../de/d0f/conceptfcppt_1_1mpl_1_1size__type__concept.html">fcppt::mpl::size_type_concept</a> S&gt; </td></tr>
<tr class="memitem:gabdd46e13671bd02c96315a47bd4d4db3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabdd46e13671bd02c96315a47bd4d4db3">fcppt::mpl::list::repeat</a></td></tr>
<tr class="memdesc:gabdd46e13671bd02c96315a47bd4d4db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a list that consists of n elements that are all the same.Let <code>S = <a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;n&gt;</a></code>. Then the result is.  <br /></td></tr>
<tr class="memitem:ga30e44f6808b0f17a24c9967f16737016" id="r_ga30e44f6808b0f17a24c9967f16737016"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:ga30e44f6808b0f17a24c9967f16737016 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a> = typename fcppt::mpl::list::detail::size&lt;List&gt;::type</td></tr>
<tr class="memdesc:ga30e44f6808b0f17a24c9967f16737016"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;n&gt;</a></code>.  <br /></td></tr>
<tr class="memitem:ga43682df371ecd2e3016a47586f850aa6" id="r_ga43682df371ecd2e3016a47586f850aa6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:ga43682df371ecd2e3016a47586f850aa6 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga43682df371ecd2e3016a47586f850aa6">fcppt::mpl::list::tail</a> = typename fcppt::mpl::list::detail::tail&lt;List&gt;::type</td></tr>
<tr class="memdesc:ga43682df371ecd2e3016a47586f850aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, where <code>n &gt;= 1</code>, then the result is.  <br /></td></tr>
<tr class="memitem:ga35ce42ba0668433b9ed2b0bc3fc2d21c" id="r_ga35ce42ba0668433b9ed2b0bc3fc2d21c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../de/d0f/conceptfcppt_1_1mpl_1_1size__type__concept.html">fcppt::mpl::size_type_concept</a> S&gt; </td></tr>
<tr class="memitem:ga35ce42ba0668433b9ed2b0bc3fc2d21c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga35ce42ba0668433b9ed2b0bc3fc2d21c">fcppt::mpl::list::take</a> = typename fcppt::mpl::list::detail::take&lt;List,std::make_index_sequence&lt;S::value&gt;&gt;::type</td></tr>
<tr class="memdesc:ga35ce42ba0668433b9ed2b0bc3fc2d21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps some elements of a list from the beginning.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is.  <br /></td></tr>
<tr class="memitem:gaf4ad8740aaca88e6b60402b9ae53aa0e" id="r_gaf4ad8740aaca88e6b60402b9ae53aa0e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gaf4ad8740aaca88e6b60402b9ae53aa0e template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf4ad8740aaca88e6b60402b9ae53aa0e">fcppt::mpl::list::transpose</a> = typename fcppt::mpl::list::detail::transpose&lt;List&gt;::type</td></tr>
<tr class="memdesc:gaf4ad8740aaca88e6b60402b9ae53aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes n lists of length k into k lists of length n.If.  <br /></td></tr>
<tr class="memitem:ga872e46bbeac6fcdb59aae336c4a9b638" id="r_ga872e46bbeac6fcdb59aae336c4a9b638"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map, typename Key&gt; </td></tr>
<tr class="memitem:ga872e46bbeac6fcdb59aae336c4a9b638 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga872e46bbeac6fcdb59aae336c4a9b638">fcppt::mpl::map::at</a> = typename fcppt::mpl::map::detail::at&lt;Map,Key&gt;::type</td></tr>
<tr class="memdesc:ga872e46bbeac6fcdb59aae336c4a9b638"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type associated with a key in a map.Let <code>Map = <a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>, where <code>Key = K_i</code> for some <code>1 &lt;= i &lt;= n</code>. Then the result is <code>V_i</code>.  <br /></td></tr>
<tr class="memitem:gaaffe72f476e1f693149292beb88a9277" id="r_gaaffe72f476e1f693149292beb88a9277"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d49/conceptfcppt_1_1mpl_1_1map_1_1element__concept.html">fcppt::mpl::map::element_concept</a> Element&gt; </td></tr>
<tr class="memitem:gaaffe72f476e1f693149292beb88a9277 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaffe72f476e1f693149292beb88a9277">fcppt::mpl::map::element_key</a> = typename fcppt::mpl::map::detail::element_key&lt;Element&gt;::type</td></tr>
<tr class="memdesc:gaaffe72f476e1f693149292beb88a9277"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key type of an element.Returns <code>K</code> if <code>Element=<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">map::element&lt;K,V&gt;</a></code>.  <br /></td></tr>
<tr class="memitem:ga74699351d171cbe0d9753a5d4eb97644" id="r_ga74699351d171cbe0d9753a5d4eb97644"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d49/conceptfcppt_1_1mpl_1_1map_1_1element__concept.html">fcppt::mpl::map::element_concept</a> Element&gt; </td></tr>
<tr class="memitem:ga74699351d171cbe0d9753a5d4eb97644 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga74699351d171cbe0d9753a5d4eb97644">fcppt::mpl::map::element_value</a> = typename fcppt::mpl::map::detail::element_value&lt;Element&gt;::type</td></tr>
<tr class="memdesc:ga74699351d171cbe0d9753a5d4eb97644"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of an element.Returns <code>V</code> if <code>Element=<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">map::element&lt;K,V&gt;</a></code>.  <br /></td></tr>
<tr class="memitem:ga2a8b4a0040e97a4dd995b50adb28a1ec" id="r_ga2a8b4a0040e97a4dd995b50adb28a1ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map1, <a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map2&gt; </td></tr>
<tr class="memitem:ga2a8b4a0040e97a4dd995b50adb28a1ec template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2a8b4a0040e97a4dd995b50adb28a1ec">fcppt::mpl::map::equal</a></td></tr>
<tr class="memdesc:ga2a8b4a0040e97a4dd995b50adb28a1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two maps are equal.  <br /></td></tr>
<tr class="memitem:ga7aadb398b13e514320787c7ed0e89c9b" id="r_ga7aadb398b13e514320787c7ed0e89c9b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map&gt; </td></tr>
<tr class="memitem:ga7aadb398b13e514320787c7ed0e89c9b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7aadb398b13e514320787c7ed0e89c9b">fcppt::mpl::map::flip</a> = typename fcppt::mpl::map::detail::flip&lt;Map&gt;::type</td></tr>
<tr class="memdesc:ga7aadb398b13e514320787c7ed0e89c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the key-value pairs inside a map.Let <code>Map=<a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>. Then the result is.  <br /></td></tr>
<tr class="memitem:gafaa4e8d151c964812081344fafc7a89d" id="r_gafaa4e8d151c964812081344fafc7a89d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map, typename Key&gt; </td></tr>
<tr class="memitem:gafaa4e8d151c964812081344fafc7a89d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafaa4e8d151c964812081344fafc7a89d">fcppt::mpl::map::has_key</a> = typename fcppt::mpl::map::detail::has_key&lt;Map,Key&gt;::type</td></tr>
<tr class="memdesc:gafaa4e8d151c964812081344fafc7a89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a map contains a key.Let <code>Map = <a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>. If <code>Key = K_i</code> for some <code>1 &lt;= i &lt;= n</code>, then the result is <code>std::true_type</code>. Otherwise, it is <code>std::false_type</code>.  <br /></td></tr>
<tr class="memitem:ga5c946d8c9e44ea86f9a176c277fab97c" id="r_ga5c946d8c9e44ea86f9a176c277fab97c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map, typename Key, typename Value&gt; </td></tr>
<tr class="memitem:ga5c946d8c9e44ea86f9a176c277fab97c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c946d8c9e44ea86f9a176c277fab97c">fcppt::mpl::map::insert</a> = typename fcppt::mpl::map::detail::insert&lt;Map,Key,Value&gt;::type</td></tr>
<tr class="memdesc:ga5c946d8c9e44ea86f9a176c277fab97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into a map.Let <code>Map = <a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>. Then the result is.  <br /></td></tr>
<tr class="memitem:gaf5cfd150e6c5299b96d4e59c214c76f5" id="r_gaf5cfd150e6c5299b96d4e59c214c76f5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaf5cfd150e6c5299b96d4e59c214c76f5 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5cfd150e6c5299b96d4e59c214c76f5">fcppt::mpl::map::is_element</a> = typename fcppt::mpl::map::detail::is_element&lt;T&gt;::type</td></tr>
<tr class="memdesc:gaf5cfd150e6c5299b96d4e59c214c76f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is a map element.<code>T</code> is a map element if an only if it is of the form <code><a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">fcppt::mpl::map::element&lt;K,V&gt;</a></code> for some types <code>K, V</code>.  <br /></td></tr>
<tr class="memitem:ga6aaa60647cf96d086bddf9bba8795544" id="r_ga6aaa60647cf96d086bddf9bba8795544"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga6aaa60647cf96d086bddf9bba8795544 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6aaa60647cf96d086bddf9bba8795544">fcppt::mpl::map::is_object</a> = typename fcppt::mpl::map::detail::is_object&lt;T&gt;::type</td></tr>
<tr class="memdesc:ga6aaa60647cf96d086bddf9bba8795544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is a map.  <br /></td></tr>
<tr class="memitem:ga4354f9021dd54910dfde704bcff3756a" id="r_ga4354f9021dd54910dfde704bcff3756a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map&gt; </td></tr>
<tr class="memitem:ga4354f9021dd54910dfde704bcff3756a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4354f9021dd54910dfde704bcff3756a">fcppt::mpl::map::keys</a> = typename fcppt::mpl::map::detail::keys&lt;Map&gt;::type</td></tr>
<tr class="memdesc:ga4354f9021dd54910dfde704bcff3756a"><td class="mdescLeft">&#160;</td><td class="mdescRight">They keys of a map as a set.Let <code>Map = <a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>. Then the result is.  <br /></td></tr>
<tr class="memitem:gac67934c2623c0d3ffb71f4e258945062" id="r_gac67934c2623c0d3ffb71f4e258945062"><td class="memTemplParams" colspan="2">template&lt;fcppt::mpl::map::element_concept... Args&gt; </td></tr>
<tr class="memitem:gac67934c2623c0d3ffb71f4e258945062 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac67934c2623c0d3ffb71f4e258945062">fcppt::mpl::map::keys_unique</a></td></tr>
<tr class="memdesc:gac67934c2623c0d3ffb71f4e258945062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the keys of elements are pairwise disjoint.Let <code>Args=<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a></code>. The result is <code>std::true_type</code> if all the keys <code>K_1,...,K_n</code> are pairwise disjoint. Otherwise, it is <code>std::false_type</code>.  <br /></td></tr>
<tr class="memitem:gad1811c0335d2816826f388cd88f498d8" id="r_gad1811c0335d2816826f388cd88f498d8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T1, <a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T2&gt; </td></tr>
<tr class="memitem:gad1811c0335d2816826f388cd88f498d8 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1811c0335d2816826f388cd88f498d8">fcppt::mpl::mul</a> = typename fcppt::mpl::detail::mul&lt;T1,T2&gt;::type</td></tr>
<tr class="memdesc:gad1811c0335d2816826f388cd88f498d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two integral constants.Let <code>T1 = std::integral_constant&lt;T,V_1&gt;</code> and <code>T2 = std::integral_constant&lt;T,V_2&gt;</code>. Then the result is <code>std::integral_constant&lt;T,V_1 * V_2&gt;</code>.  <br /></td></tr>
<tr class="memitem:ga8ddf7b2c44ebb60b9a03f73af0b1c307" id="r_ga8ddf7b2c44ebb60b9a03f73af0b1c307"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set, typename Key&gt; </td></tr>
<tr class="memitem:ga8ddf7b2c44ebb60b9a03f73af0b1c307 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8ddf7b2c44ebb60b9a03f73af0b1c307">fcppt::mpl::set::contains</a> = typename fcppt::mpl::set::detail::contains&lt;Set,Key&gt;::type</td></tr>
<tr class="memdesc:ga8ddf7b2c44ebb60b9a03f73af0b1c307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a set contains an element.Let <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code>. The result is <code>std::true_type</code> if <code>Key = E_i</code> for some <code>1 &lt;= i &lt;= n</code>. Otherwise, it is <code>std::false_type</code>.  <br /></td></tr>
<tr class="memitem:ga6bc5e6e2f69f5192193304e1548b8e12" id="r_ga6bc5e6e2f69f5192193304e1548b8e12"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </td></tr>
<tr class="memitem:ga6bc5e6e2f69f5192193304e1548b8e12 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6bc5e6e2f69f5192193304e1548b8e12">fcppt::mpl::set::difference</a></td></tr>
<tr class="memdesc:ga6bc5e6e2f69f5192193304e1548b8e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference of two sets.The result contains every element that is in <em class="arg">Set1</em>, but not in <em class="arg">Set2</em>.  <br /></td></tr>
<tr class="memitem:ga1a75321f031545baf4f310b1cbf8bffb" id="r_ga1a75321f031545baf4f310b1cbf8bffb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </td></tr>
<tr class="memitem:ga1a75321f031545baf4f310b1cbf8bffb template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a75321f031545baf4f310b1cbf8bffb">fcppt::mpl::set::equal</a></td></tr>
<tr class="memdesc:ga1a75321f031545baf4f310b1cbf8bffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two sets are equal.  <br /></td></tr>
<tr class="memitem:gaaf7c32d88bf11f03d0d1c3a595398f94" id="r_gaaf7c32d88bf11f03d0d1c3a595398f94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gaaf7c32d88bf11f03d0d1c3a595398f94 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf7c32d88bf11f03d0d1c3a595398f94">fcppt::mpl::set::from_list</a> = typename fcppt::mpl::set::detail::from_list&lt;List&gt;::type</td></tr>
<tr class="memdesc:gaaf7c32d88bf11f03d0d1c3a595398f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a list with no duplicates into a set.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, where <code>L_1,...,L_n</code> are pairwise disjoint. The result is.  <br /></td></tr>
<tr class="memitem:gae6b761c6955b62972326aa16b41cbb1e" id="r_gae6b761c6955b62972326aa16b41cbb1e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gae6b761c6955b62972326aa16b41cbb1e template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6b761c6955b62972326aa16b41cbb1e">fcppt::mpl::set::from_list_relaxed</a></td></tr>
<tr class="memdesc:gae6b761c6955b62972326aa16b41cbb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a list with into a set, removing duplicates.Unlike <a class="el" href="#gaaf7c32d88bf11f03d0d1c3a595398f94" title="Converts a list with no duplicates into a set.Let List = list::object&lt;L_1,...,L_n&gt;,...">fcppt::mpl::set::from_list</a>, this function allows duplicate elements.  <br /></td></tr>
<tr class="memitem:ga94421f4de5f2b6643268c2498f954208" id="r_ga94421f4de5f2b6643268c2498f954208"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set, typename E&gt; </td></tr>
<tr class="memitem:ga94421f4de5f2b6643268c2498f954208 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga94421f4de5f2b6643268c2498f954208">fcppt::mpl::set::insert</a> = typename fcppt::mpl::set::detail::insert&lt;Set,E&gt;::type</td></tr>
<tr class="memdesc:ga94421f4de5f2b6643268c2498f954208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into a set.Let <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code>. Then the result is.  <br /></td></tr>
<tr class="memitem:ga5b45dcda8cc01059c7bac7882d10dea6" id="r_ga5b45dcda8cc01059c7bac7882d10dea6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set, typename Value&gt; </td></tr>
<tr class="memitem:ga5b45dcda8cc01059c7bac7882d10dea6 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b45dcda8cc01059c7bac7882d10dea6">fcppt::mpl::set::insert_relaxed</a></td></tr>
<tr class="memdesc:ga5b45dcda8cc01059c7bac7882d10dea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into a set.Let <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code>. If <code>E</code> is not equal to any of the <code>E_1,...,E_n</code>, then the result is.  <br /></td></tr>
<tr class="memitem:ga51ea9c58078878d13b947155c24bcad0" id="r_ga51ea9c58078878d13b947155c24bcad0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </td></tr>
<tr class="memitem:ga51ea9c58078878d13b947155c24bcad0 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51ea9c58078878d13b947155c24bcad0">fcppt::mpl::set::intersection</a></td></tr>
<tr class="memdesc:ga51ea9c58078878d13b947155c24bcad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intersection of two sets.The result contains every element that is both in <em class="arg">Set1</em> and <em class="arg">Set2</em>.  <br /></td></tr>
<tr class="memitem:gaed1ed7291180e5f604755bdc953e7b2a" id="r_gaed1ed7291180e5f604755bdc953e7b2a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaed1ed7291180e5f604755bdc953e7b2a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaed1ed7291180e5f604755bdc953e7b2a">fcppt::mpl::set::is_object</a> = typename fcppt::mpl::set::detail::is_object&lt;T&gt;::type</td></tr>
<tr class="memdesc:gaed1ed7291180e5f604755bdc953e7b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is a set.  <br /></td></tr>
<tr class="memitem:ga7ac03d63785fcdd1aa9fd5fd8444849b" id="r_ga7ac03d63785fcdd1aa9fd5fd8444849b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set&gt; </td></tr>
<tr class="memitem:ga7ac03d63785fcdd1aa9fd5fd8444849b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7ac03d63785fcdd1aa9fd5fd8444849b">fcppt::mpl::set::size</a> = <a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a>&lt;<a class="el" href="#ga9c0a24255b0b9e64998c5c639bd82c44">fcppt::mpl::set::to_list</a>&lt;Set&gt;&gt;</td></tr>
<tr class="memdesc:ga7ac03d63785fcdd1aa9fd5fd8444849b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of a set.If <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;L_1,...,L_n&gt;</a></code> then the result is <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;n&gt;</a></code>.  <br /></td></tr>
<tr class="memitem:gac0646c9c4da0c606ac7b51131af6abd3" id="r_gac0646c9c4da0c606ac7b51131af6abd3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </td></tr>
<tr class="memitem:gac0646c9c4da0c606ac7b51131af6abd3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0646c9c4da0c606ac7b51131af6abd3">fcppt::mpl::set::symmetric_difference</a></td></tr>
<tr class="memdesc:gac0646c9c4da0c606ac7b51131af6abd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symmetric difference of two sets.The result contains every element that is either in <em class="arg">Set1</em> or in <em class="arg">Set2</em>, but not in both.  <br /></td></tr>
<tr class="memitem:ga9c0a24255b0b9e64998c5c639bd82c44" id="r_ga9c0a24255b0b9e64998c5c639bd82c44"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set&gt; </td></tr>
<tr class="memitem:ga9c0a24255b0b9e64998c5c639bd82c44 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9c0a24255b0b9e64998c5c639bd82c44">fcppt::mpl::set::to_list</a> = typename fcppt::mpl::set::detail::to_list&lt;Set&gt;::type</td></tr>
<tr class="memdesc:ga9c0a24255b0b9e64998c5c639bd82c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a set to a list.Let <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code>. The result is.  <br /></td></tr>
<tr class="memitem:gab7c4ad28707cc64f11e031a2ec9c4baa" id="r_gab7c4ad28707cc64f11e031a2ec9c4baa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </td></tr>
<tr class="memitem:gab7c4ad28707cc64f11e031a2ec9c4baa template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab7c4ad28707cc64f11e031a2ec9c4baa">fcppt::mpl::set::union_</a></td></tr>
<tr class="memdesc:gab7c4ad28707cc64f11e031a2ec9c4baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of two sets.The result contains every element that is in <em class="arg">Set1</em> or in <em class="arg">Set2</em>.  <br /></td></tr>
<tr class="memitem:ga1d799162e695237dba186603d07f5f93" id="r_ga1d799162e695237dba186603d07f5f93"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga1d799162e695237dba186603d07f5f93 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1d799162e695237dba186603d07f5f93">fcppt::mpl::set::unique</a> = <a class="el" href="#gaa37dfe05e98e3818c75be090f7e7989a">fcppt::mpl::list::distinct</a>&lt;<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html">fcppt::mpl::list::object</a>&lt;Args...&gt;&gt;</td></tr>
<tr class="memdesc:ga1d799162e695237dba186603d07f5f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a variadic list is pairwise disjoint.  <br /></td></tr>
<tr class="memitem:gad40f7a5c07fd369b2a1f77bb271f4311" id="r_gad40f7a5c07fd369b2a1f77bb271f4311"><td class="memTemplParams" colspan="2">template&lt;std::size_t I&gt; </td></tr>
<tr class="memitem:gad40f7a5c07fd369b2a1f77bb271f4311 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311">fcppt::mpl::size_type</a> = std::integral_constant&lt;std::size_t,I&gt;</td></tr>
<tr class="memdesc:gad40f7a5c07fd369b2a1f77bb271f4311"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size type used by this library.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9b0282cd1b5c26873d39482668ddc195" id="r_ga9b0282cd1b5c26873d39482668ddc195"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename Function&gt; </td></tr>
<tr class="memitem:ga9b0282cd1b5c26873d39482668ddc195 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9b0282cd1b5c26873d39482668ddc195">fcppt::mpl::list::for_each_break</a> (Function const &amp;_function)</td></tr>
<tr class="memdesc:ga9b0282cd1b5c26873d39482668ddc195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a runtime function for each element of a listing, possibly breaking out early.  <br /></td></tr>
<tr class="memitem:ga1dedc98380769ab17722724d80bb1692" id="r_ga1dedc98380769ab17722724d80bb1692"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename Function, typename FailFunction&gt; </td></tr>
<tr class="memitem:ga1dedc98380769ab17722724d80bb1692 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/group__fcpptpreprocessor.html#gad35104ba14597a60d244959d84fb1b65">FCPPT_PP_PUSH_WARNING</a> std::invoke_result_t&lt; FailFunction &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1dedc98380769ab17722724d80bb1692">fcppt::mpl::list::invoke_on</a> (std::size_t const _index, Function const &amp;_function, FailFunction const &amp;_fail_function)</td></tr>
<tr class="memdesc:ga1dedc98380769ab17722724d80bb1692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to the nth element of an <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">mpl::list::object</a> with a runtime index.  <br /></td></tr>
<tr class="memitem:gacded41ae90b7b03c036bc68adb25772b" id="r_gacded41ae90b7b03c036bc68adb25772b"><td class="memTemplParams" colspan="2">template&lt;typename Ch, typename Traits, typename... Types&gt; </td></tr>
<tr class="memitem:gacded41ae90b7b03c036bc68adb25772b template"><td class="memItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Traits &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacded41ae90b7b03c036bc68adb25772b">fcppt::mpl::list::operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Traits &gt; &amp;_stream, <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html">fcppt::mpl::list::object</a>&lt; Types... &gt; const &amp;)</td></tr>
<tr class="memdesc:gacded41ae90b7b03c036bc68adb25772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a list.Prints <em class="arg">List</em> to <em class="arg">_stream</em>. Every type in <em class="arg">List</em> will be converted to a string using <a class="el" href="../../d7/d50/group__fcpptvarious.html#ga0461779d96d1904bfe1b052b76876ed7" title="Returns a demangled type name if possible.">fcppt::type_name</a>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga012a6bfae1a0009e9a01bb29e8713ba3" id="r_ga012a6bfae1a0009e9a01bb29e8713ba3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, typename... Args&gt; </td></tr>
<tr class="memitem:ga012a6bfae1a0009e9a01bb29e8713ba3 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga012a6bfae1a0009e9a01bb29e8713ba3">fcppt::mpl::apply_v</a> = <a class="el" href="#ga470122143165d1d2f2037b7122760ef6">fcppt::mpl::apply</a>&lt;L,Args...&gt;::value</td></tr>
<tr class="memdesc:ga012a6bfae1a0009e9a01bb29e8713ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a lambda.  <br /></td></tr>
<tr class="memitem:ga21595c89fbabd14efc471802ae71cbe2" id="r_ga21595c89fbabd14efc471802ae71cbe2"><td class="memTemplParams" colspan="2">template&lt;typename F, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> L&gt; </td></tr>
<tr class="memitem:ga21595c89fbabd14efc471802ae71cbe2 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga21595c89fbabd14efc471802ae71cbe2">fcppt::mpl::is_invocable_v</a> = <a class="el" href="#ga796e2d02b2681f585321721af80f1f07">fcppt::mpl::is_invocable</a>&lt;F,L&gt;::value</td></tr>
<tr class="memdesc:ga21595c89fbabd14efc471802ae71cbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a function can be invoked with a given argument list.  <br /></td></tr>
<tr class="memitem:ga7c2e3c6df914c43d03c4e941607b2d21" id="r_ga7c2e3c6df914c43d03c4e941607b2d21"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </td></tr>
<tr class="memitem:ga7c2e3c6df914c43d03c4e941607b2d21 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c2e3c6df914c43d03c4e941607b2d21">fcppt::mpl::list::all_of_v</a> = <a class="el" href="#ga267a7faf7e25557be2ba8587acfc9748">fcppt::mpl::list::all_of</a>&lt;List,L&gt;::value</td></tr>
<tr class="memdesc:ga7c2e3c6df914c43d03c4e941607b2d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a predicate holds for all types of a list.  <br /></td></tr>
<tr class="memitem:gac4bdfaa39d441ab933942f06281e3b45" id="r_gac4bdfaa39d441ab933942f06281e3b45"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </td></tr>
<tr class="memitem:gac4bdfaa39d441ab933942f06281e3b45 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac4bdfaa39d441ab933942f06281e3b45">fcppt::mpl::list::any_of_v</a> = <a class="el" href="#ga166a33fe4d091a231ecba33d84f5f37e">fcppt::mpl::list::any_of</a>&lt;List,L&gt;::value</td></tr>
<tr class="memdesc:gac4bdfaa39d441ab933942f06281e3b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a predicate holds for any type of a list.  <br /></td></tr>
<tr class="memitem:ga145ab069ed64d4f77ed055a4af85a1d9" id="r_ga145ab069ed64d4f77ed055a4af85a1d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> Args&gt; </td></tr>
<tr class="memitem:ga145ab069ed64d4f77ed055a4af85a1d9 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga145ab069ed64d4f77ed055a4af85a1d9">fcppt::mpl::list::apply_v</a> = <a class="el" href="#ga0b3918537ebf5d2caa2b8f2a65de24da">fcppt::mpl::list::apply</a>&lt;L,Args&gt;::value</td></tr>
<tr class="memdesc:ga145ab069ed64d4f77ed055a4af85a1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a lambda using a list of arguments.  <br /></td></tr>
<tr class="memitem:ga35975a8b2c5a4607a2ab94acbcaa5cea" id="r_ga35975a8b2c5a4607a2ab94acbcaa5cea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename E&gt; </td></tr>
<tr class="memitem:ga35975a8b2c5a4607a2ab94acbcaa5cea template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga35975a8b2c5a4607a2ab94acbcaa5cea">fcppt::mpl::list::contains_v</a> = <a class="el" href="#gaa037212eb460efe98af4f31a7a9abe81">fcppt::mpl::list::contains</a>&lt;List,E&gt;::value</td></tr>
<tr class="memdesc:ga35975a8b2c5a4607a2ab94acbcaa5cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a list contains an element.  <br /></td></tr>
<tr class="memitem:gae89e34d233175ff8e6029ef561bab55f" id="r_gae89e34d233175ff8e6029ef561bab55f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gae89e34d233175ff8e6029ef561bab55f template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae89e34d233175ff8e6029ef561bab55f">fcppt::mpl::list::distinct_v</a> = <a class="el" href="#gaa37dfe05e98e3818c75be090f7e7989a">fcppt::mpl::list::distinct</a>&lt;List&gt;::value</td></tr>
<tr class="memdesc:gae89e34d233175ff8e6029ef561bab55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all elements of a list are pairwise disjoint.  <br /></td></tr>
<tr class="memitem:gae4cf65b217db3efbd6d22516bff728fe" id="r_gae4cf65b217db3efbd6d22516bff728fe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </td></tr>
<tr class="memitem:gae4cf65b217db3efbd6d22516bff728fe template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae4cf65b217db3efbd6d22516bff728fe">fcppt::mpl::list::empty_v</a> = <a class="el" href="#gab8f9810134bbeceb5dfeb17554925200">fcppt::mpl::list::empty</a>&lt;List&gt;::value</td></tr>
<tr class="memdesc:gae4cf65b217db3efbd6d22516bff728fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a list is empty.  <br /></td></tr>
<tr class="memitem:gad9bf1a3782c85503456be6475f7a173c" id="r_gad9bf1a3782c85503456be6475f7a173c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map1, <a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map2&gt; </td></tr>
<tr class="memitem:gad9bf1a3782c85503456be6475f7a173c template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad9bf1a3782c85503456be6475f7a173c">fcppt::mpl::map::equal_v</a> = <a class="el" href="#ga2a8b4a0040e97a4dd995b50adb28a1ec">fcppt::mpl::map::equal</a>&lt;Map1,Map2&gt;::value</td></tr>
<tr class="memdesc:gad9bf1a3782c85503456be6475f7a173c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two maps are equal.  <br /></td></tr>
<tr class="memitem:ga24d023a34ce70ea230371b874a09a6e7" id="r_ga24d023a34ce70ea230371b874a09a6e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map, typename Key&gt; </td></tr>
<tr class="memitem:ga24d023a34ce70ea230371b874a09a6e7 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga24d023a34ce70ea230371b874a09a6e7">fcppt::mpl::map::has_key_v</a> = <a class="el" href="#gafaa4e8d151c964812081344fafc7a89d">fcppt::mpl::map::has_key</a>&lt;Map,Key&gt;::value</td></tr>
<tr class="memdesc:ga24d023a34ce70ea230371b874a09a6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a map contains a key.  <br /></td></tr>
<tr class="memitem:gab7bf20471211bf2afad2082882a17d47" id="r_gab7bf20471211bf2afad2082882a17d47"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set, typename Key&gt; </td></tr>
<tr class="memitem:gab7bf20471211bf2afad2082882a17d47 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab7bf20471211bf2afad2082882a17d47">fcppt::mpl::set::contains_v</a> = <a class="el" href="#ga8ddf7b2c44ebb60b9a03f73af0b1c307">fcppt::mpl::set::contains</a>&lt;Set,Key&gt;::value</td></tr>
<tr class="memdesc:gab7bf20471211bf2afad2082882a17d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a set contains an element.  <br /></td></tr>
<tr class="memitem:ga262d22b27825b4653d681b176806464f" id="r_ga262d22b27825b4653d681b176806464f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </td></tr>
<tr class="memitem:ga262d22b27825b4653d681b176806464f template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga262d22b27825b4653d681b176806464f">fcppt::mpl::set::equal_v</a> = <a class="el" href="#ga1a75321f031545baf4f310b1cbf8bffb">fcppt::mpl::set::equal</a>&lt;Set1,Set2&gt;::value</td></tr>
<tr class="memdesc:ga262d22b27825b4653d681b176806464f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two sets are equal.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga015afd69383d8726187fdf09f3999e55" name="ga015afd69383d8726187fdf09f3999e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga015afd69383d8726187fdf09f3999e55">&#9670;&#160;</a></span>add</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T1, <a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga015afd69383d8726187fdf09f3999e55">fcppt::mpl::add</a> = typename fcppt::mpl::detail::add&lt;T1,T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two integral constants.Let <code>T1 = std::integral_constant&lt;T,V_1&gt;</code> and <code>T2 = std::integral_constant&lt;T,V_2&gt;</code>. Then the result is <code>std::integral_constant&lt;T,V_1 + V_2&gt;</code>. </p>

</div>
</div>
<a id="ga267a7faf7e25557be2ba8587acfc9748" name="ga267a7faf7e25557be2ba8587acfc9748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267a7faf7e25557be2ba8587acfc9748">&#9670;&#160;</a></span>all_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga267a7faf7e25557be2ba8587acfc9748">fcppt::mpl::list::all_of</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    List,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;std::conjunction&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind&lt;L, fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>&gt;,</div>
<div class="line">    std::true_type&gt;</div>
</div><!-- fragment -->
<p>Checks if a predicate holds for all types of a list.If <code>List=<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L</code> holds a function <code>F</code> of arity <code>1</code>, then the result is. </p>
<div class="fragment"><div class="line">std::bool_constant&lt;std::conjunction_v&lt;F&lt;L_1&gt;, ..., F&lt;L_n&gt;&gt;&gt;</div>
</div><!-- fragment --><p>TODO(concepts) </p>

</div>
</div>
<a id="ga166a33fe4d091a231ecba33d84f5f37e" name="ga166a33fe4d091a231ecba33d84f5f37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166a33fe4d091a231ecba33d84f5f37e">&#9670;&#160;</a></span>any_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga166a33fe4d091a231ecba33d84f5f37e">fcppt::mpl::list::any_of</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    List,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;std::disjunction&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind&lt;L, fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>&gt;,</div>
<div class="line">    std::false_type&gt;</div>
</div><!-- fragment -->
<p>Checks if a predicate holds for any type of a list.If <code>List=<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L</code> holds a function <code>F</code> of arity <code>1</code>, then the result is. </p>
<div class="fragment"><div class="line">std::bool_constant&lt;std::disjunction_v&lt;F&lt;L_1&gt;, ..., F&lt;L_n&gt;&gt;&gt;</div>
</div><!-- fragment --><p>TODO(concepts) </p>

</div>
</div>
<a id="ga6cc13ef9375ae14104cde0769a8c4401" name="ga6cc13ef9375ae14104cde0769a8c4401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc13ef9375ae14104cde0769a8c4401">&#9670;&#160;</a></span>append</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List1, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga6cc13ef9375ae14104cde0769a8c4401">fcppt::mpl::list::append</a> = typename fcppt::mpl::list::detail::append&lt;List1,List2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends two lists.If <code>List1 = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>List2 = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;R_1,...,R_m&gt;</a></code> then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_1,...,L_n,R_1,...,R_m&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga470122143165d1d2f2037b7122760ef6" name="ga470122143165d1d2f2037b7122760ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga470122143165d1d2f2037b7122760ef6">&#9670;&#160;</a></span>apply <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga470122143165d1d2f2037b7122760ef6">fcppt::mpl::apply</a> = typename fcppt::mpl::detail::apply&lt;L,Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a lambda. </p>
<p>If <code>L</code> holds a function <code>F</code> of arity n and <code>Args = A_1,...,A_n</code>, then <code>F&lt;A_1,...,A_n&gt;</code> is returned. </p>

</div>
</div>
<a id="ga0b3918537ebf5d2caa2b8f2a65de24da" name="ga0b3918537ebf5d2caa2b8f2a65de24da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b3918537ebf5d2caa2b8f2a65de24da">&#9670;&#160;</a></span>apply <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga0b3918537ebf5d2caa2b8f2a65de24da">fcppt::mpl::list::apply</a> = typename fcppt::mpl::list::detail::apply&lt;L,Args&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a lambda using a list of arguments. </p>
<p>If <code>L</code> holds a function <code>F</code> of arity n and <code>Args = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;A_1,...,A_n&gt;</a></code>, then <code>F&lt;A_1,...,A_n&gt;</code> is returned. </p>

</div>
</div>
<a id="ga9244a4b57516f164aec17b763fa5fc32" name="ga9244a4b57516f164aec17b763fa5fc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9244a4b57516f164aec17b763fa5fc32">&#9670;&#160;</a></span>arg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga9244a4b57516f164aec17b763fa5fc32">fcppt::mpl::arg</a> = typename fcppt::mpl::detail::arg&lt;Arg - 1U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A lambda that returns an argument in a specific position. </p>
<p>A lambda that returns the argument in position <code>Arg</code>. Formally, for every integer <code>m &gt;= Arg</code> it is a lambda that holds a function <code>F_m</code> of arity <code>m</code>, such that <code>F_m&lt;T_1,...,T_m&gt; = T_Arg</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Argument counting starts at <code>1</code> instead of <code>0</code>. </dd></dl>

</div>
</div>
<a id="ga31cf28041093cda43d6cdf722dc2ad54" name="ga31cf28041093cda43d6cdf722dc2ad54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31cf28041093cda43d6cdf722dc2ad54">&#9670;&#160;</a></span>at <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../de/d0f/conceptfcppt_1_1mpl_1_1size__type__concept.html">fcppt::mpl::size_type_concept</a> Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga31cf28041093cda43d6cdf722dc2ad54">fcppt::mpl::list::at</a> = typename fcppt::mpl::list::detail::at&lt;List,Index&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The element of a list at a given position.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>Index = <a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;j&gt;</a></code> with <code>0 &lt;= j &lt; n</code> then the result is <code>L_{j-1}</code>. </p>

</div>
</div>
<a id="ga872e46bbeac6fcdb59aae336c4a9b638" name="ga872e46bbeac6fcdb59aae336c4a9b638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga872e46bbeac6fcdb59aae336c4a9b638">&#9670;&#160;</a></span>at <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map, typename Key&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga872e46bbeac6fcdb59aae336c4a9b638">fcppt::mpl::map::at</a> = typename fcppt::mpl::map::detail::at&lt;Map,Key&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value type associated with a key in a map.Let <code>Map = <a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>, where <code>Key = K_i</code> for some <code>1 &lt;= i &lt;= n</code>. Then the result is <code>V_i</code>. </p>

</div>
</div>
<a id="ga7866870faf1a6d781fdaed62816fb686" name="ga7866870faf1a6d781fdaed62816fb686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7866870faf1a6d781fdaed62816fb686">&#9670;&#160;</a></span>back</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7866870faf1a6d781fdaed62816fb686">fcppt::mpl::list::back</a> = <a class="el" href="#ga31cf28041093cda43d6cdf722dc2ad54">fcppt::mpl::list::at</a>&lt;List,<a class="el" href="#ga43de01e17953b583ab7447679154ee3d">fcppt::mpl::dec</a>&lt;<a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a>&lt;List&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The last element of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is <code>L_n</code>. </p>

</div>
</div>
<a id="ga1ec959d9b6cde6e4a75722c8995b2c6d" name="ga1ec959d9b6cde6e4a75722c8995b2c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ec959d9b6cde6e4a75722c8995b2c6d">&#9670;&#160;</a></span>bind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> ... Ls&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d">fcppt::mpl::bind</a> = typename fcppt::mpl::detail::bind&lt;L,Ls...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function composition on multiple lambdas. </p>
<p>Suppose that <code>L</code> holds a function <code>G</code> and <code>Ls...</code> hold functions <code>Gs...</code>, then <code><a class="el" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">bind&lt;L,Ls...&gt;</a></code> is a lambda that when called with arguments <code>Args...</code> it returns </p><div class="fragment"><div class="line">G&lt;Gs&lt;Args...&gt;...&gt;</div>
</div><!-- fragment --><p> Formally, let <code>G</code> be of arity <code>k</code> and <code>Gs... = G_1, ..., G_k</code> be of arity <code>m</code>. Then <code><a class="el" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind&lt;L,L_1,...,L_k&gt;</a></code> holds a function <code>F</code> of arity <code>m</code>, such that <code>F&lt;T_1,...,T_m&gt; = G&lt;G_1&lt;T_1,...,T_m&gt;,...,G_k&lt;T_1,...,T_m&gt;&gt;</code>. </p>

</div>
</div>
<a id="ga9035314fa94a8a0d789b3c8bc32337a1" name="ga9035314fa94a8a0d789b3c8bc32337a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9035314fa94a8a0d789b3c8bc32337a1">&#9670;&#160;</a></span>constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga9035314fa94a8a0d789b3c8bc32337a1">fcppt::mpl::constant</a> = typename fcppt::mpl::detail::constant&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constant lambda. </p>
<p>This is a lambda that returns <code>T</code>.</p>
<p>Formally, for every integer <code>m</code> it holds a function <code>F_m</code> of arity <code>m</code>, such that <code>F_m&lt;T_1,...,T_m&gt; = C</code>. </p>

</div>
</div>
<a id="gaa037212eb460efe98af4f31a7a9abe81" name="gaa037212eb460efe98af4f31a7a9abe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa037212eb460efe98af4f31a7a9abe81">&#9670;&#160;</a></span>contains <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaa037212eb460efe98af4f31a7a9abe81">fcppt::mpl::list::contains</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga166a33fe4d091a231ecba33d84f5f37e" title="Checks if a predicate holds for any type of a list.If List=list::object&lt;L_1,...,L_n&gt; and L holds a fu...">fcppt::mpl::list::any_of</a>&lt;</div>
<div class="line">    List,</div>
<div class="line">    fcppt::mpl::</div>
<div class="line">        bind&lt;fcppt::mpl::lambda&lt;std::is_same&gt;, <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>, <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;E&gt;</a>&gt;&gt;</div>
</div><!-- fragment -->
<p>Checks if a list contains an element.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. The result is <code>std::true_type</code> if <code>E = L_i</code> for some <code>1 &lt;= i &lt;= n</code>. Otherwise, it is <code>std::false_type</code>. </p>

</div>
</div>
<a id="ga8ddf7b2c44ebb60b9a03f73af0b1c307" name="ga8ddf7b2c44ebb60b9a03f73af0b1c307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ddf7b2c44ebb60b9a03f73af0b1c307">&#9670;&#160;</a></span>contains <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set, typename Key&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga8ddf7b2c44ebb60b9a03f73af0b1c307">fcppt::mpl::set::contains</a> = typename fcppt::mpl::set::detail::contains&lt;Set,Key&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a set contains an element.Let <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code>. The result is <code>std::true_type</code> if <code>Key = E_i</code> for some <code>1 &lt;= i &lt;= n</code>. Otherwise, it is <code>std::false_type</code>. </p>

</div>
</div>
<a id="ga43de01e17953b583ab7447679154ee3d" name="ga43de01e17953b583ab7447679154ee3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43de01e17953b583ab7447679154ee3d">&#9670;&#160;</a></span>dec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga43de01e17953b583ab7447679154ee3d">fcppt::mpl::dec</a> = typename fcppt::mpl::detail::dec&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts one from an integral constant.Let <code>T = std::integral_constant&lt;U,V&gt;</code>. Then the result is <code>std::integral_constant&lt;U,V--&gt;</code>. </p>

</div>
</div>
<a id="ga6bc5e6e2f69f5192193304e1548b8e12" name="ga6bc5e6e2f69f5192193304e1548b8e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc5e6e2f69f5192193304e1548b8e12">&#9670;&#160;</a></span>difference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga6bc5e6e2f69f5192193304e1548b8e12">fcppt::mpl::set::difference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="#ga9c0a24255b0b9e64998c5c639bd82c44" title="Converts a set to a list.Let Set = set::object&lt;E_1,...,E_n&gt;. The result is.">fcppt::mpl::set::to_list&lt;Set1&gt;</a>,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::if_&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">            <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::set::contains&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;Set2&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">            <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::set::insert&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;&gt;,</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">fcppt::mpl::set::object&lt;&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>The difference of two sets.The result contains every element that is in <em class="arg">Set1</em>, but not in <em class="arg">Set2</em>. </p>

</div>
</div>
<a id="gaa37dfe05e98e3818c75be090f7e7989a" name="gaa37dfe05e98e3818c75be090f7e7989a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37dfe05e98e3818c75be090f7e7989a">&#9670;&#160;</a></span>distinct</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaa37dfe05e98e3818c75be090f7e7989a">fcppt::mpl::list::distinct</a> = typename fcppt::mpl::list::detail::distinct&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all elements of a list are pairwise disjoint.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. If <code>L_i != L_j</code> for all <code>1 &lt;= i != j &lt;= n</code> then the result is <code>std::true_type</code>. Otherwise, it is <code>std::false_type</code>. </p>

</div>
</div>
<a id="ga6c0159536abc5eebf9365da5bdb17697" name="ga6c0159536abc5eebf9365da5bdb17697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c0159536abc5eebf9365da5bdb17697">&#9670;&#160;</a></span>drop</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../de/d0f/conceptfcppt_1_1mpl_1_1size__type__concept.html">fcppt::mpl::size_type_concept</a> S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga6c0159536abc5eebf9365da5bdb17697">fcppt::mpl::list::drop</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga4400e3ec8ea647995287182f7561073c" title="Applies a lambda to every element of a list.If List=list::object&lt;L_1,...,L_n&gt; and L holds a function ...">fcppt::mpl::list::map</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="#ga73ddf174d757a7de05b3899f6758efb0" title="Return the interval between two numbers.If Begin = std::integral_constant&lt;Type,B&gt; and End = std::inte...">fcppt::mpl::list::interval&lt;S, fcppt::mpl::list::size&lt;List&gt;</a>&gt;,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::list::at&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;List&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;&gt;</div>
</div><!-- fragment -->
<p>Removes some elements of a list from the beginning.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_{S+1},...,L_n&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaaffe72f476e1f693149292beb88a9277" name="gaaffe72f476e1f693149292beb88a9277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaffe72f476e1f693149292beb88a9277">&#9670;&#160;</a></span>element_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d49/conceptfcppt_1_1mpl_1_1map_1_1element__concept.html">fcppt::mpl::map::element_concept</a> Element&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaaffe72f476e1f693149292beb88a9277">fcppt::mpl::map::element_key</a> = typename fcppt::mpl::map::detail::element_key&lt;Element&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The key type of an element.Returns <code>K</code> if <code>Element=<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">map::element&lt;K,V&gt;</a></code>. </p>

</div>
</div>
<a id="ga74699351d171cbe0d9753a5d4eb97644" name="ga74699351d171cbe0d9753a5d4eb97644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74699351d171cbe0d9753a5d4eb97644">&#9670;&#160;</a></span>element_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d49/conceptfcppt_1_1mpl_1_1map_1_1element__concept.html">fcppt::mpl::map::element_concept</a> Element&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga74699351d171cbe0d9753a5d4eb97644">fcppt::mpl::map::element_value</a> = typename fcppt::mpl::map::detail::element_value&lt;Element&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value type of an element.Returns <code>V</code> if <code>Element=<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">map::element&lt;K,V&gt;</a></code>. </p>

</div>
</div>
<a id="gab8f9810134bbeceb5dfeb17554925200" name="gab8f9810134bbeceb5dfeb17554925200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8f9810134bbeceb5dfeb17554925200">&#9670;&#160;</a></span>empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gab8f9810134bbeceb5dfeb17554925200">fcppt::mpl::list::empty</a> = std::is_same&lt;<a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a>&lt;List&gt;,<a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311">fcppt::mpl::size_type</a>&lt;0U&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a list is empty.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. If <code>n = 0</code> then <code>std::true_type</code> is returned. Otherwise, <code>std::false_type</code>is returned. </p>

</div>
</div>
<a id="ga2a8b4a0040e97a4dd995b50adb28a1ec" name="ga2a8b4a0040e97a4dd995b50adb28a1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a8b4a0040e97a4dd995b50adb28a1ec">&#9670;&#160;</a></span>equal <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map1, <a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga2a8b4a0040e97a4dd995b50adb28a1ec">fcppt::mpl::map::equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply</a>&lt;<a class="code hl_typedef" href="#ga8e5a6472377cd4fa26ad68736309705c" title="The if-then-else function.Similar to std::conditional_t but takes a bool_concept, i....">fcppt::mpl::if_</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="#ga1a75321f031545baf4f310b1cbf8bffb" title="Checks if two sets are equal.">fcppt::mpl::set::equal&lt;fcppt::mpl::map::keys&lt;Map1&gt;</a>, <a class="code hl_typedef" href="#ga4354f9021dd54910dfde704bcff3756a" title="They keys of a map as a set.Let Map = map::object&lt;element&lt;K_1,V_1&gt;,...,element&lt;K_n,...">fcppt::mpl::map::keys&lt;Map2&gt;</a>&gt;,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::map::detail::equal_impl::map_same_values&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;Map1&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;Map2&gt;</a>&gt;,</div>
<div class="line">    <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;std::false_type&gt;</a>&gt;&gt;</div>
</div><!-- fragment -->
<p>Checks if two maps are equal. </p>
<p>Two maps are equal if and only if they contain the same key-value pairs. Let <code>Map1=<a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code> and <code>Map2=<a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;element&lt;K_1',V_1'&gt;,...,element&lt;K_m',V_m'&gt;&gt;</code>. Then the result is <code>std::true_type</code> if </p><div class="fragment"><div class="line">{(K_1,V_1),...,(K_n,V_n)} = {(K_1<span class="stringliteral">&#39;,V_1&#39;</span>),...,(K_m<span class="stringliteral">&#39;,V_m&#39;</span>)}</div>
</div><!-- fragment --><p> Otherwise, the result is <code>std::false_type</code>. </p>

</div>
</div>
<a id="ga1a75321f031545baf4f310b1cbf8bffb" name="ga1a75321f031545baf4f310b1cbf8bffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a75321f031545baf4f310b1cbf8bffb">&#9670;&#160;</a></span>equal <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga1a75321f031545baf4f310b1cbf8bffb">fcppt::mpl::set::equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::is_same&lt;fcppt::mpl::set::symmetric_difference&lt;Set1, Set2&gt;, <a class="code hl_struct" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">fcppt::mpl::set::object&lt;&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Checks if two sets are equal. </p>
<p>Two sets are equal if and only if they contain the same elements. Let <code>Set1=<a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code> and <code>Set2=<a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object</a>&lt;E_1',...,E_m'&gt;&gt;</code>. Then the result is <code>std::true_type</code> if </p><div class="fragment"><div class="line">{E_1,...,E_n} = {E_1<span class="stringliteral">&#39;,...,E_m&#39;</span>}</div>
</div><!-- fragment --><p> Otherwise, the result is <code>std::false_type</code>. </p>

</div>
</div>
<a id="ga7aadb398b13e514320787c7ed0e89c9b" name="ga7aadb398b13e514320787c7ed0e89c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aadb398b13e514320787c7ed0e89c9b">&#9670;&#160;</a></span>flip</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7aadb398b13e514320787c7ed0e89c9b">fcppt::mpl::map::flip</a> = typename fcppt::mpl::map::detail::flip&lt;Map&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips the key-value pairs inside a map.Let <code>Map=<a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>. Then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object&lt;element&lt;V_1,K_1&gt;</a>,...,<a class="code hl_struct" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;V_n,K_n&gt;</a>&gt;</div>
</div><!-- fragment --><p> This only works if all the values <code>V_1,...,V_n</code> are pairwise disjoint. </p>

</div>
</div>
<a id="ga830ecf262cc8fc591e0dc72ba403ecca" name="ga830ecf262cc8fc591e0dc72ba403ecca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga830ecf262cc8fc591e0dc72ba403ecca">&#9670;&#160;</a></span>fold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, typename V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga830ecf262cc8fc591e0dc72ba403ecca">fcppt::mpl::list::fold</a> = typename fcppt::mpl::list::detail::fold&lt;List,L,V&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds a list. </p>
<p>Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L</code> hold a function <code>F</code> of arity <code>2</code>. Let <code>V_i = F&lt;L_{i+1},V_{i+1}&gt;</code> for <code>0 &lt;= i &lt; n</code> and <code>V_n = V</code>. Then the result is <code>V_0</code>. The calculations are </p><div class="fragment"><div class="line">V_0 = F&lt;L_1,V_1&gt;</div>
<div class="line">V_1 = F&lt;L_2,V_2&gt;</div>
<div class="line">...</div>
<div class="line">V_{n-1} = F&lt;L_n,V_n&gt;</div>
<div class="line">V_n = V</div>
</div><!-- fragment --><p> Notice that if <code>n=0</code> then V_0 = V. </p>

</div>
</div>
<a id="ga6ec74f79aebe29ed119706f65fe60775" name="ga6ec74f79aebe29ed119706f65fe60775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec74f79aebe29ed119706f65fe60775">&#9670;&#160;</a></span>from</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga6ec74f79aebe29ed119706f65fe60775">fcppt::mpl::list::from</a> = typename fcppt::mpl::list::detail::from&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a template type to a list.If <code>Type = T&lt;L_1, ..., L_n&gt;</code> then the result is <code><a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. </p>

</div>
</div>
<a id="gaaf7c32d88bf11f03d0d1c3a595398f94" name="gaaf7c32d88bf11f03d0d1c3a595398f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf7c32d88bf11f03d0d1c3a595398f94">&#9670;&#160;</a></span>from_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaaf7c32d88bf11f03d0d1c3a595398f94">fcppt::mpl::set::from_list</a> = typename fcppt::mpl::set::detail::from_list&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a list with no duplicates into a set.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, where <code>L_1,...,L_n</code> are pairwise disjoint. The result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object</a>&lt;L_1,...,L_n&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gae6b761c6955b62972326aa16b41cbb1e" name="gae6b761c6955b62972326aa16b41cbb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b761c6955b62972326aa16b41cbb1e">&#9670;&#160;</a></span>from_list_relaxed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gae6b761c6955b62972326aa16b41cbb1e">fcppt::mpl::set::from_list_relaxed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    List,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::set::insert_relaxed&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">fcppt::mpl::set::object&lt;&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Converts a list with into a set, removing duplicates.Unlike <a class="el" href="#gaaf7c32d88bf11f03d0d1c3a595398f94" title="Converts a list with no duplicates into a set.Let List = list::object&lt;L_1,...,L_n&gt;,...">fcppt::mpl::set::from_list</a>, this function allows duplicate elements. </p>

</div>
</div>
<a id="gaa2c0eaa24d7a5d4547e1abcd36cb8e70" name="gaa2c0eaa24d7a5d4547e1abcd36cb8e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2c0eaa24d7a5d4547e1abcd36cb8e70">&#9670;&#160;</a></span>front</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaa2c0eaa24d7a5d4547e1abcd36cb8e70">fcppt::mpl::list::front</a> = typename fcppt::mpl::list::detail::front&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first element of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is <code>L_1</code>. </p>

</div>
</div>
<a id="gab410a41074c2b7142d5af3a1210901c4" name="gab410a41074c2b7142d5af3a1210901c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab410a41074c2b7142d5af3a1210901c4">&#9670;&#160;</a></span>function_args</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gab410a41074c2b7142d5af3a1210901c4">fcppt::mpl::function_args</a> = typename fcppt::mpl::detail::function_args&lt;Function&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The argument types of a function as a list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>Must be a function type.</td></tr>
  </table>
  </dd>
</dl>
<p>TODO(concepts) </p>

</div>
</div>
<a id="gab7eab87e3c553876869958966dd65fc9" name="gab7eab87e3c553876869958966dd65fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7eab87e3c553876869958966dd65fc9">&#9670;&#160;</a></span>greater</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T1, <a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gab7eab87e3c553876869958966dd65fc9">fcppt::mpl::greater</a> = typename fcppt::mpl::detail::greater&lt;T1,T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if one integral constant is greater than another.Let <code>T1 = std::integral_constant&lt;T,V_1&gt;</code> and <code>T2 = std::integral_constant&lt;T,V_2&gt;</code>. Then the result is <code>std::bool_constant&lt;(V1 &gt; V2)&gt;</code>. </p>

</div>
</div>
<a id="gafaa4e8d151c964812081344fafc7a89d" name="gafaa4e8d151c964812081344fafc7a89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaa4e8d151c964812081344fafc7a89d">&#9670;&#160;</a></span>has_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map, typename Key&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gafaa4e8d151c964812081344fafc7a89d">fcppt::mpl::map::has_key</a> = typename fcppt::mpl::map::detail::has_key&lt;Map,Key&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a map contains a key.Let <code>Map = <a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>. If <code>Key = K_i</code> for some <code>1 &lt;= i &lt;= n</code>, then the result is <code>std::true_type</code>. Otherwise, it is <code>std::false_type</code>. </p>

</div>
</div>
<a id="ga8e5a6472377cd4fa26ad68736309705c" name="ga8e5a6472377cd4fa26ad68736309705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e5a6472377cd4fa26ad68736309705c">&#9670;&#160;</a></span>if_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d9/de9/conceptfcppt_1_1mpl_1_1bool__concept.html">fcppt::mpl::bool_concept</a> B, typename T, typename F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga8e5a6472377cd4fa26ad68736309705c">fcppt::mpl::if_</a> = std::conditional_t&lt;B::value, T, F&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The if-then-else function.Similar to <code>std::conditional_t</code> but takes a <code><a class="el" href="../../d9/de9/conceptfcppt_1_1mpl_1_1bool__concept.html" title="Concept for boolean constants.">bool_concept</a></code>, i.e., a <code>std::bool_constant&lt;V&gt;</code> for any <code>bool V</code> instead of <code>V</code> directly. </p>

</div>
</div>
<a id="ga2d8cf3988c705c90f6d0ce61188c2b76" name="ga2d8cf3988c705c90f6d0ce61188c2b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d8cf3988c705c90f6d0ce61188c2b76">&#9670;&#160;</a></span>index_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga2d8cf3988c705c90f6d0ce61188c2b76">fcppt::mpl::list::index_of</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#gae0d49c6335f92caf6eff37c3bada9d2a" title="The first index where an element matches a predicate inside a list.Let List = list::object&lt;L_1,...">fcppt::mpl::list::index_of_if</a>&lt;</div>
<div class="line">    List,</div>
<div class="line">    fcppt::mpl::</div>
<div class="line">        bind&lt;fcppt::mpl::lambda&lt;std::is_same&gt;, <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;E&gt;</a>, <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;&gt;</div>
</div><!-- fragment -->
<p>The first index of a given element inside a list.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. Returns <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">size_type&lt;Index&gt;</a></code> where <code>Index</code> is the smallest number such that <code>L_{Index} = E</code>. </p>

</div>
</div>
<a id="gae0d49c6335f92caf6eff37c3bada9d2a" name="gae0d49c6335f92caf6eff37c3bada9d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d49c6335f92caf6eff37c3bada9d2a">&#9670;&#160;</a></span>index_of_if</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gae0d49c6335f92caf6eff37c3bada9d2a">fcppt::mpl::list::index_of_if</a> = typename fcppt::mpl::list::detail::index_of_if&lt;List,L,<a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311">fcppt::mpl::size_type</a>&lt;0U&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first index where an element matches a predicate inside a list.Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and let <code>L</code> hold a function <code>F</code> of arity <code>1</code>. Returns <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">size_type&lt;Index&gt;</a></code> where <code>Index</code> is the smallest number such that <code>F&lt;L_{Index}&gt; = std::true_type</code>. </p>

</div>
</div>
<a id="gae3c04d65f53d1fb56bc7163925f3874f" name="gae3c04d65f53d1fb56bc7163925f3874f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c04d65f53d1fb56bc7163925f3874f">&#9670;&#160;</a></span>indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gae3c04d65f53d1fb56bc7163925f3874f">fcppt::mpl::list::indices</a> = <a class="el" href="#ga73ddf174d757a7de05b3899f6758efb0">fcppt::mpl::list::interval</a>&lt;<a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311">fcppt::mpl::size_type</a>&lt;0U&gt;,<a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a>&lt;List&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the positions of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;size_type&lt;0&gt;</a>,...,<a class="code hl_typedef" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">size_type</a>&lt;n-1&gt;&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga5c946d8c9e44ea86f9a176c277fab97c" name="ga5c946d8c9e44ea86f9a176c277fab97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c946d8c9e44ea86f9a176c277fab97c">&#9670;&#160;</a></span>insert <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map, typename Key, typename Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga5c946d8c9e44ea86f9a176c277fab97c">fcppt::mpl::map::insert</a> = typename fcppt::mpl::map::detail::insert&lt;Map,Key,Value&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into a map.Let <code>Map = <a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>. Then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object&lt;element&lt;K_1,V_1&gt;</a>,...,<a class="code hl_struct" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>,<a class="code hl_struct" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;Key,Value&gt;</a>&gt;</div>
</div><!-- fragment --><p> This only works if <code>Key</code> is not equal to any of the <code>K_1,...,K_n</code>. </p>

</div>
</div>
<a id="ga94421f4de5f2b6643268c2498f954208" name="ga94421f4de5f2b6643268c2498f954208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94421f4de5f2b6643268c2498f954208">&#9670;&#160;</a></span>insert <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga94421f4de5f2b6643268c2498f954208">fcppt::mpl::set::insert</a> = typename fcppt::mpl::set::detail::insert&lt;Set,E&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into a set.Let <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code>. Then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object</a>&lt;E_1,...,E_n,E&gt;</div>
</div><!-- fragment --><p> This only works if <code>E</code> is not equal to any of the <code>E_1,...,E_n</code>. </p>

</div>
</div>
<a id="ga5b45dcda8cc01059c7bac7882d10dea6" name="ga5b45dcda8cc01059c7bac7882d10dea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b45dcda8cc01059c7bac7882d10dea6">&#9670;&#160;</a></span>insert_relaxed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set, typename Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga5b45dcda8cc01059c7bac7882d10dea6">fcppt::mpl::set::insert_relaxed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply</a>&lt;<a class="code hl_typedef" href="#ga8e5a6472377cd4fa26ad68736309705c" title="The if-then-else function.Similar to std::conditional_t but takes a bool_concept, i....">fcppt::mpl::if_</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="#ga8ddf7b2c44ebb60b9a03f73af0b1c307" title="Checks if a set contains an element.Let Set = set::object&lt;E_1,...,E_n&gt;. The result is std::true_type ...">fcppt::mpl::set::contains&lt;Set, Value&gt;</a>,</div>
<div class="line">    <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;Set&gt;</a>,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::set::insert&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;Set&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;Value&gt;</a>&gt;&gt;&gt;</div>
</div><!-- fragment -->
<p>Inserts an element into a set.Let <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code>. If <code>E</code> is not equal to any of the <code>E_1,...,E_n</code>, then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object</a>&lt;E_1,...,E_n,E&gt;</div>
</div><!-- fragment --><p> Otherwise, the result is <code>Set</code>. </p>

</div>
</div>
<a id="ga51ea9c58078878d13b947155c24bcad0" name="ga51ea9c58078878d13b947155c24bcad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ea9c58078878d13b947155c24bcad0">&#9670;&#160;</a></span>intersection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga51ea9c58078878d13b947155c24bcad0">fcppt::mpl::set::intersection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="#ga9c0a24255b0b9e64998c5c639bd82c44" title="Converts a set to a list.Let Set = set::object&lt;E_1,...,E_n&gt;. The result is.">fcppt::mpl::set::to_list&lt;Set1&gt;</a>,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::if_&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">            <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::set::contains&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;Set2&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">        <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">            <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::set::insert_relaxed&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>&gt;,</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">fcppt::mpl::set::object&lt;&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>The intersection of two sets.The result contains every element that is both in <em class="arg">Set1</em> and <em class="arg">Set2</em>. </p>

</div>
</div>
<a id="ga73ddf174d757a7de05b3899f6758efb0" name="ga73ddf174d757a7de05b3899f6758efb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73ddf174d757a7de05b3899f6758efb0">&#9670;&#160;</a></span>interval</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d1/d60/conceptfcppt_1_1type__traits_1_1integral__constant__concept.html">fcppt::type_traits::integral_constant_concept</a> Begin, <a class="el" href="../../d1/d60/conceptfcppt_1_1type__traits_1_1integral__constant__concept.html">fcppt::type_traits::integral_constant_concept</a> End&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga73ddf174d757a7de05b3899f6758efb0">fcppt::mpl::list::interval</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <span class="keyword">typename</span> fcppt::mpl::list::detail::interval&lt;</div>
<div class="line">        std::make_integer_sequence&lt;fcppt::type_traits::value_type&lt;Begin&gt;, End::value - Begin::value&gt;,</div>
<div class="line">        Begin&gt;::type</div>
</div><!-- fragment -->
<p>Return the interval between two numbers.If <code>Begin = std::integral_constant&lt;Type,B&gt;</code> and <code>End = std::integral_constant&lt;Type,E&gt;</code> then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;std::integral_constant&lt;Type,B&gt;</a>, std::integral_constant&lt;Type,B+1&gt;,...,std::integral_constant&lt;Type,E-1&gt;&gt;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><code>End</code> is not included in the range but <code>Begin</code> is. </dd></dl>

</div>
</div>
<a id="gaf5cfd150e6c5299b96d4e59c214c76f5" name="gaf5cfd150e6c5299b96d4e59c214c76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5cfd150e6c5299b96d4e59c214c76f5">&#9670;&#160;</a></span>is_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaf5cfd150e6c5299b96d4e59c214c76f5">fcppt::mpl::map::is_element</a> = typename fcppt::mpl::map::detail::is_element&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a type is a map element.<code>T</code> is a map element if an only if it is of the form <code><a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">fcppt::mpl::map::element&lt;K,V&gt;</a></code> for some types <code>K, V</code>. </p>

</div>
</div>
<a id="ga796e2d02b2681f585321721af80f1f07" name="ga796e2d02b2681f585321721af80f1f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga796e2d02b2681f585321721af80f1f07">&#9670;&#160;</a></span>is_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga796e2d02b2681f585321721af80f1f07">fcppt::mpl::is_invocable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> fcppt::mpl::list::</div>
<div class="line">    apply&lt;fcppt::mpl::lambda&lt;std::is_invocable&gt;, <a class="code hl_typedef" href="#gaadac5729724bda255877ce68f4222ec6" title="Adds an element to the front of a list.If List = list::object&lt;L_1,...,L_n&gt;, then the result is.">fcppt::mpl::list::push_front&lt;L, F&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Checks if a function can be invoked with a given argument list.Checks if function <code>F</code> can be invoked with the types in <code>L</code>, i.e. if <code>L = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, then the result is. </p>
<div class="fragment"><div class="line">std::is_invocable&lt;F,L_1,...,L_n&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga95a010389d298e3c7d3416dd68fe3c2d" name="ga95a010389d298e3c7d3416dd68fe3c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95a010389d298e3c7d3416dd68fe3c2d">&#9670;&#160;</a></span>is_lambda</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga95a010389d298e3c7d3416dd68fe3c2d">fcppt::mpl::is_lambda</a> = typename fcppt::mpl::detail::is_lambda&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a type is a lambda. </p>
<p><code>T</code> is a lambda if an only if it is of the form <code><a class="el" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;F&gt;</a></code> for some type <code>F</code>. </p>

</div>
</div>
<a id="gaa618cda6942fa6b51e7ff59571ebe454" name="gaa618cda6942fa6b51e7ff59571ebe454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa618cda6942fa6b51e7ff59571ebe454">&#9670;&#160;</a></span>is_object <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaa618cda6942fa6b51e7ff59571ebe454">fcppt::mpl::list::is_object</a> = typename fcppt::mpl::list::detail::is_object&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a type is a list. </p>
<p><code>T</code> is a list if an only if it is of the form <code><a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object&lt;T_1, ..., T_n&gt;</a></code> for some types <code>T_1, ..., T_n</code>. </p>

</div>
</div>
<a id="ga6aaa60647cf96d086bddf9bba8795544" name="ga6aaa60647cf96d086bddf9bba8795544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aaa60647cf96d086bddf9bba8795544">&#9670;&#160;</a></span>is_object <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga6aaa60647cf96d086bddf9bba8795544">fcppt::mpl::map::is_object</a> = typename fcppt::mpl::map::detail::is_object&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a type is a map. </p>
<p><code>T</code> is a map if an only if it is of the form <code><a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">fcppt::mpl::map::object&lt;E_1, ..., E_n&gt;</a></code> for some elements <code>E_1, ..., E_n</code>. </p>

</div>
</div>
<a id="gaed1ed7291180e5f604755bdc953e7b2a" name="gaed1ed7291180e5f604755bdc953e7b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed1ed7291180e5f604755bdc953e7b2a">&#9670;&#160;</a></span>is_object <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaed1ed7291180e5f604755bdc953e7b2a">fcppt::mpl::set::is_object</a> = typename fcppt::mpl::set::detail::is_object&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a type is a set. </p>
<p><code>T</code> is a set if an only if it is of the form <code><a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">fcppt::mpl::set::object&lt;T_1, ..., T_n&gt;</a></code> for some types <code>T_1, ..., T_n</code>. </p>

</div>
</div>
<a id="ga1f1e48b7a2643560d0754414b84c68c5" name="ga1f1e48b7a2643560d0754414b84c68c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1e48b7a2643560d0754414b84c68c5">&#9670;&#160;</a></span>is_size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga1f1e48b7a2643560d0754414b84c68c5">fcppt::mpl::is_size_type</a> = typename fcppt::mpl::detail::is_size_type&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a type is a <a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">size_type</a>.<code>T</code> is a size type if and only if it is of the form <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;N&gt;</a></code> for some <code>std::size_t N</code>. </p>

</div>
</div>
<a id="ga4078e0aeec043d7f455f3aeb0fa1a1f3" name="ga4078e0aeec043d7f455f3aeb0fa1a1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4078e0aeec043d7f455f3aeb0fa1a1f3">&#9670;&#160;</a></span>join</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga4078e0aeec043d7f455f3aeb0fa1a1f3">fcppt::mpl::list::join</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    List,</div>
<div class="line">    fcppt::mpl::</div>
<div class="line">        bind&lt;fcppt::mpl::lambda&lt;fcppt::mpl::list::append&gt;, <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>, <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object&lt;&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Joins a list of lists.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L_1, ..., L_n</code> are lists, then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#ga6cc13ef9375ae14104cde0769a8c4401" title="Appends two lists.If List1 = list::object&lt;L_1,...,L_n&gt; and List2 = list::object&lt;R_1,...">append</a>&lt;L_1,<a class="code hl_typedef" href="#ga6cc13ef9375ae14104cde0769a8c4401" title="Appends two lists.If List1 = list::object&lt;L_1,...,L_n&gt; and List2 = list::object&lt;R_1,...">append</a>&lt;L_2,...,<a class="code hl_typedef" href="#ga6cc13ef9375ae14104cde0769a8c4401" title="Appends two lists.If List1 = list::object&lt;L_1,...,L_n&gt; and List2 = list::object&lt;R_1,...">append</a>&lt;L_{n-1},L_n&gt; ...&gt;&gt;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Must be a list of lists. TODO(concepts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab8444e3fb192826357f3311f2fee149d" name="gab8444e3fb192826357f3311f2fee149d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8444e3fb192826357f3311f2fee149d">&#9670;&#160;</a></span>keep_if</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> Pred&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gab8444e3fb192826357f3311f2fee149d">fcppt::mpl::list::keep_if</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#ga7c80156725be82a99e22a11d50c0fc85" title="Removes the elements that satisfy a predicate.Removes the elements of List for which Pred is std::tru...">fcppt::mpl::list::remove_if&lt;List, fcppt::mpl::bind&lt;fcppt::mpl::lambda&lt;std::negation&gt;</a>, Pred&gt;&gt;</div>
</div><!-- fragment -->
<p>Only keeps elements that satisfy a predicate.Keeps the elements of <em class="arg">List</em> for which <em class="arg">Pred</em> is <code>std::true_type</code>. The order of the elements stays the same. </p>

</div>
</div>
<a id="ga4354f9021dd54910dfde704bcff3756a" name="ga4354f9021dd54910dfde704bcff3756a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4354f9021dd54910dfde704bcff3756a">&#9670;&#160;</a></span>keys</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga4354f9021dd54910dfde704bcff3756a">fcppt::mpl::map::keys</a> = typename fcppt::mpl::map::detail::keys&lt;Map&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>They keys of a map as a set.Let <code>Map = <a class="el" href="../../da/df7/structfcppt_1_1mpl_1_1map_1_1object.html" title="The map type used by this library.">map::object</a>&lt;<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a>&gt;</code>. Then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object</a>&lt;K_1,...,K_n&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gac67934c2623c0d3ffb71f4e258945062" name="gac67934c2623c0d3ffb71f4e258945062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac67934c2623c0d3ffb71f4e258945062">&#9670;&#160;</a></span>keys_unique</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fcppt::mpl::map::element_concept... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gac67934c2623c0d3ffb71f4e258945062">fcppt::mpl::map::keys_unique</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#gaa37dfe05e98e3818c75be090f7e7989a" title="Checks if all elements of a list are pairwise disjoint.Let List = list::object&lt;L_1,...">fcppt::mpl::list::distinct&lt;fcppt::mpl::list::object&lt;fcppt::mpl::map::element_key&lt;Args&gt;</a>...&gt;&gt;</div>
</div><!-- fragment -->
<p>Checks if the keys of elements are pairwise disjoint.Let <code>Args=<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_1,V_1&gt;</a>,...,<a class="el" href="../../d2/de9/structfcppt_1_1mpl_1_1map_1_1element.html" title="The element type of a map.An element of a map is a key-value pair.">element&lt;K_n,V_n&gt;</a></code>. The result is <code>std::true_type</code> if all the keys <code>K_1,...,K_n</code> are pairwise disjoint. Otherwise, it is <code>std::false_type</code>. </p>

</div>
</div>
<a id="ga8ce5b4df7e5740c778c61d2c36385967" name="ga8ce5b4df7e5740c778c61d2c36385967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce5b4df7e5740c778c61d2c36385967">&#9670;&#160;</a></span>less</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T1, <a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga8ce5b4df7e5740c778c61d2c36385967">fcppt::mpl::less</a> = typename fcppt::mpl::detail::less&lt;T1, T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if one integral constant is less than another.Let <code>T1 = std::integral_constant&lt;T,V_1&gt;</code> and <code>T2 = std::integral_constant&lt;T,V_2&gt;</code>. Then the result is <code>std::bool_constant&lt;(V1 &lt; V2)&gt;</code>. </p>

</div>
</div>
<a id="ga4400e3ec8ea647995287182f7561073c" name="ga4400e3ec8ea647995287182f7561073c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4400e3ec8ea647995287182f7561073c">&#9670;&#160;</a></span>map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga4400e3ec8ea647995287182f7561073c">fcppt::mpl::list::map</a> = typename fcppt::mpl::list::detail::map&lt;List,F&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a lambda to every element of a list.If <code>List=<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> and <code>L</code> holds a function <code>F</code> of arity <code>1</code>, then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;F&lt;L_1&gt;</a>,...,F&lt;L_n&gt;&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gad15a3cf85bc12f76ed0d03592794c635" name="gad15a3cf85bc12f76ed0d03592794c635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad15a3cf85bc12f76ed0d03592794c635">&#9670;&#160;</a></span>map_multi</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> F, fcppt::mpl::list::object_concept... Lists&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gad15a3cf85bc12f76ed0d03592794c635">fcppt::mpl::list::map_multi</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga4400e3ec8ea647995287182f7561073c" title="Applies a lambda to every element of a list.If List=list::object&lt;L_1,...,L_n&gt; and L holds a function ...">fcppt::mpl::list::map</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="#gaf4ad8740aaca88e6b60402b9ae53aa0e" title="Transposes n lists of length k into k lists of length n.If.">fcppt::mpl::list::transpose</a>&lt;<a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object</a>&lt;Lists...&gt;&gt;,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::list::apply&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;F&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;&gt;</div>
</div><!-- fragment -->
<p>Applies an n-ary lambda to every element-tuple of n lists.If <code>Lists=<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_{1,1},...,L_{1,k}&gt;, ... <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_{1,n},...,L_{n,k}&gt;</code> and <code>L</code> holds a function <code>F</code> of arity <code>n</code>, then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;F&lt;L_{1,1},...,L_{1,n}&gt;,...,F&lt;L_{1,k},...,L_{n,k}&gt;&gt;</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lists</td><td>Must all have the same size. TODO(concepts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e1733665bfae3f2d0c1ac3147931808" name="ga0e1733665bfae3f2d0c1ac3147931808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e1733665bfae3f2d0c1ac3147931808">&#9670;&#160;</a></span>maximum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga0e1733665bfae3f2d0c1ac3147931808">fcppt::mpl::list::maximum</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    Sequence,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::if_&gt;</a>,</div>
<div class="line">        fcppt::mpl::</div>
<div class="line">            bind&lt;fcppt::mpl::lambda&lt;fcppt::mpl::greater&gt;, <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>, <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>&gt;,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>&gt;,</div>
<div class="line">    <a class="code hl_typedef" href="#gaa2c0eaa24d7a5d4547e1abcd36cb8e70" title="The first element of a list.If List = list::object&lt;L_1,...,L_n&gt; then the result is L_1.">fcppt::mpl::list::front&lt;Sequence&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Calculates the maximum value of a list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sequence</td><td>A non empty <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">mpl::list::object</a> of std::integral_constants. TODO(concepts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1811c0335d2816826f388cd88f498d8" name="gad1811c0335d2816826f388cd88f498d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1811c0335d2816826f388cd88f498d8">&#9670;&#160;</a></span>mul</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T1, <a class="el" href="../../d5/d07/conceptfcppt_1_1mpl_1_1integral__concept.html">fcppt::mpl::integral_concept</a> T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gad1811c0335d2816826f388cd88f498d8">fcppt::mpl::mul</a> = typename fcppt::mpl::detail::mul&lt;T1,T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies two integral constants.Let <code>T1 = std::integral_constant&lt;T,V_1&gt;</code> and <code>T2 = std::integral_constant&lt;T,V_2&gt;</code>. Then the result is <code>std::integral_constant&lt;T,V_1 * V_2&gt;</code>. </p>

</div>
</div>
<a id="ga7a8ad112555323f1961b7eb33ec3dec3" name="ga7a8ad112555323f1961b7eb33ec3dec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a8ad112555323f1961b7eb33ec3dec3">&#9670;&#160;</a></span>pop_back</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7a8ad112555323f1961b7eb33ec3dec3">fcppt::mpl::list::pop_back</a> = typename fcppt::mpl::list::detail::pop_back&lt;<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html">fcppt::mpl::list::object</a>&lt;&gt;,List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last element of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, where <code>n &gt;= 1</code>, then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_1,...,L_{n-1}&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf7e02c8fb85c75f26300e71871145ab9" name="gaf7e02c8fb85c75f26300e71871145ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7e02c8fb85c75f26300e71871145ab9">&#9670;&#160;</a></span>push_back</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaf7e02c8fb85c75f26300e71871145ab9">fcppt::mpl::list::push_back</a> = typename fcppt::mpl::list::detail::push_back&lt;List,T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to the back of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_1,...,L_n,T&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaadac5729724bda255877ce68f4222ec6" name="gaadac5729724bda255877ce68f4222ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadac5729724bda255877ce68f4222ec6">&#9670;&#160;</a></span>push_front</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaadac5729724bda255877ce68f4222ec6">fcppt::mpl::list::push_front</a> = typename fcppt::mpl::list::detail::push_front&lt;List,T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to the front of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;T,L_1,...,L_n&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9b8d63ef1a311fc83d921fc682c0ae8d" name="ga9b8d63ef1a311fc83d921fc682c0ae8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b8d63ef1a311fc83d921fc682c0ae8d">&#9670;&#160;</a></span>remove</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga9b8d63ef1a311fc83d921fc682c0ae8d">fcppt::mpl::list::remove</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga7c80156725be82a99e22a11d50c0fc85" title="Removes the elements that satisfy a predicate.Removes the elements of List for which Pred is std::tru...">fcppt::mpl::list::remove_if</a>&lt;</div>
<div class="line">    List,</div>
<div class="line">    fcppt::mpl::</div>
<div class="line">        bind&lt;fcppt::mpl::lambda&lt;std::is_same&gt;, <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;T&gt;</a>, <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;&gt;</div>
</div><!-- fragment -->
<p>Removes a specific type from a list.Removes every occurrence of <em class="arg">T</em> from <em class="arg">List</em>. The order of the remaining elements stays the same. </p>

</div>
</div>
<a id="ga7c80156725be82a99e22a11d50c0fc85" name="ga7c80156725be82a99e22a11d50c0fc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c80156725be82a99e22a11d50c0fc85">&#9670;&#160;</a></span>remove_if</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> Pred&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7c80156725be82a99e22a11d50c0fc85">fcppt::mpl::list::remove_if</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    List,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::if_&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind&lt;Pred, fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">            <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::list::push_back&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>,</div>
<div class="line">            <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;&gt;,</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object&lt;&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Removes the elements that satisfy a predicate.Removes the elements of <em class="arg">List</em> for which <em class="arg">Pred</em> is <code>std::true_type</code>. The order of the remaining elements stays the same. </p>

</div>
</div>
<a id="gabdd46e13671bd02c96315a47bd4d4db3" name="gabdd46e13671bd02c96315a47bd4d4db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdd46e13671bd02c96315a47bd4d4db3">&#9670;&#160;</a></span>repeat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, <a class="el" href="../../de/d0f/conceptfcppt_1_1mpl_1_1size__type__concept.html">fcppt::mpl::size_type_concept</a> S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gabdd46e13671bd02c96315a47bd4d4db3">fcppt::mpl::list::repeat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> fcppt::mpl::list::</div>
<div class="line">    map&lt;fcppt::mpl::list::interval&lt;fcppt::mpl::size_type&lt;0U&gt;, S&gt;, <a class="code hl_typedef" href="#ga9035314fa94a8a0d789b3c8bc32337a1" title="The constant lambda.">fcppt::mpl::constant&lt;T&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Creates a list that consists of n elements that are all the same.Let <code>S = <a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;n&gt;</a></code>. Then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;T_1,...,T_n&gt;</div>
</div><!-- fragment --><p> where <code>T_1 = ... = T_n = T</code>. </p>

</div>
</div>
<a id="ga30e44f6808b0f17a24c9967f16737016" name="ga30e44f6808b0f17a24c9967f16737016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30e44f6808b0f17a24c9967f16737016">&#9670;&#160;</a></span>size <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a> = typename fcppt::mpl::list::detail::size&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;n&gt;</a></code>. </p>

</div>
</div>
<a id="ga7ac03d63785fcdd1aa9fd5fd8444849b" name="ga7ac03d63785fcdd1aa9fd5fd8444849b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ac03d63785fcdd1aa9fd5fd8444849b">&#9670;&#160;</a></span>size <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7ac03d63785fcdd1aa9fd5fd8444849b">fcppt::mpl::set::size</a> = <a class="el" href="#ga30e44f6808b0f17a24c9967f16737016">fcppt::mpl::list::size</a>&lt;<a class="el" href="#ga9c0a24255b0b9e64998c5c639bd82c44">fcppt::mpl::set::to_list</a>&lt;Set&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of a set.If <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;L_1,...,L_n&gt;</a></code> then the result is <code><a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311" title="The size type used by this library.">fcppt::mpl::size_type&lt;n&gt;</a></code>. </p>

</div>
</div>
<a id="gad40f7a5c07fd369b2a1f77bb271f4311" name="gad40f7a5c07fd369b2a1f77bb271f4311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad40f7a5c07fd369b2a1f77bb271f4311">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gad40f7a5c07fd369b2a1f77bb271f4311">fcppt::mpl::size_type</a> = std::integral_constant&lt;std::size_t,I&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size type used by this library. </p>

</div>
</div>
<a id="gac0646c9c4da0c606ac7b51131af6abd3" name="gac0646c9c4da0c606ac7b51131af6abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0646c9c4da0c606ac7b51131af6abd3">&#9670;&#160;</a></span>symmetric_difference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gac0646c9c4da0c606ac7b51131af6abd3">fcppt::mpl::set::symmetric_difference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> fcppt::mpl::set::</div>
<div class="line">    union_&lt;fcppt::mpl::set::difference&lt;Set1, Set2&gt;, <a class="code hl_typedef" href="#ga6bc5e6e2f69f5192193304e1548b8e12" title="The difference of two sets.The result contains every element that is in Set1, but not in Set2.">fcppt::mpl::set::difference&lt;Set2, Set1&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>The symmetric difference of two sets.The result contains every element that is either in <em class="arg">Set1</em> or in <em class="arg">Set2</em>, but not in both. </p>

</div>
</div>
<a id="ga43682df371ecd2e3016a47586f850aa6" name="ga43682df371ecd2e3016a47586f850aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43682df371ecd2e3016a47586f850aa6">&#9670;&#160;</a></span>tail</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga43682df371ecd2e3016a47586f850aa6">fcppt::mpl::list::tail</a> = typename fcppt::mpl::list::detail::tail&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first element of a list.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>, where <code>n &gt;= 1</code>, then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_2,...,L_n&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga35ce42ba0668433b9ed2b0bc3fc2d21c" name="ga35ce42ba0668433b9ed2b0bc3fc2d21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35ce42ba0668433b9ed2b0bc3fc2d21c">&#9670;&#160;</a></span>take</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../de/d0f/conceptfcppt_1_1mpl_1_1size__type__concept.html">fcppt::mpl::size_type_concept</a> S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga35ce42ba0668433b9ed2b0bc3fc2d21c">fcppt::mpl::list::take</a> = typename fcppt::mpl::list::detail::take&lt;List,std::make_index_sequence&lt;S::value&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keeps some elements of a list from the beginning.If <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code> then the result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_1,...,L_S&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9c0a24255b0b9e64998c5c639bd82c44" name="ga9c0a24255b0b9e64998c5c639bd82c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c0a24255b0b9e64998c5c639bd82c44">&#9670;&#160;</a></span>to_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga9c0a24255b0b9e64998c5c639bd82c44">fcppt::mpl::set::to_list</a> = typename fcppt::mpl::set::detail::to_list&lt;Set&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a set to a list.Let <code>Set = <a class="el" href="../../d6/d46/structfcppt_1_1mpl_1_1set_1_1object.html" title="The set type used by this library.A map is constructed from a variadic list of types,...">set::object&lt;E_1,...,E_n&gt;</a></code>. The result is. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;E_1,...,E_n&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf4ad8740aaca88e6b60402b9ae53aa0e" name="gaf4ad8740aaca88e6b60402b9ae53aa0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4ad8740aaca88e6b60402b9ae53aa0e">&#9670;&#160;</a></span>transpose</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaf4ad8740aaca88e6b60402b9ae53aa0e">fcppt::mpl::list::transpose</a> = typename fcppt::mpl::list::detail::transpose&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposes n lists of length k into k lists of length n.If. </p>
<div class="fragment"><div class="line">List=<a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;<a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_{1,1},...,L_{1,k}&gt;, ... list::object&lt;L_{1,n},...,L_{n,k}&gt;&gt;</div>
</div><!-- fragment --><p> then the result is </p><div class="fragment"><div class="line"><a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;<a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object</a>&lt;L_{1,1},...,L_{1,n}&gt;,...,list::object&lt;L_{1,k},...,L_{n,k}&gt;&gt;</div>
</div><!-- fragment --><p> TODO(concepts) </p>

</div>
</div>
<a id="gab7c4ad28707cc64f11e031a2ec9c4baa" name="gab7c4ad28707cc64f11e031a2ec9c4baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c4ad28707cc64f11e031a2ec9c4baa">&#9670;&#160;</a></span>union_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gab7c4ad28707cc64f11e031a2ec9c4baa">fcppt::mpl::set::union_</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="#ga830ecf262cc8fc591e0dc72ba403ecca" title="Folds a list.">fcppt::mpl::list::fold</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="#ga9c0a24255b0b9e64998c5c639bd82c44" title="Converts a set to a list.Let Set = set::object&lt;E_1,...,E_n&gt;. The result is.">fcppt::mpl::set::to_list&lt;Set1&gt;</a>,</div>
<div class="line">    <a class="code hl_typedef" href="#ga1ec959d9b6cde6e4a75722c8995b2c6d" title="Function composition on multiple lambdas.">fcppt::mpl::bind</a>&lt;</div>
<div class="line">        <a class="code hl_struct" href="../../d5/d01/structfcppt_1_1mpl_1_1lambda.html" title="The lambda type.">fcppt::mpl::lambda&lt;fcppt::mpl::set::insert_relaxed&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;2&gt;</a>,</div>
<div class="line">        <a class="code hl_typedef" href="#ga9244a4b57516f164aec17b763fa5fc32" title="A lambda that returns an argument in a specific position.">fcppt::mpl::arg&lt;1&gt;</a>&gt;,</div>
<div class="line">    Set2&gt;</div>
</div><!-- fragment -->
<p>The union of two sets.The result contains every element that is in <em class="arg">Set1</em> or in <em class="arg">Set2</em>. </p>

</div>
</div>
<a id="ga1d799162e695237dba186603d07f5f93" name="ga1d799162e695237dba186603d07f5f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d799162e695237dba186603d07f5f93">&#9670;&#160;</a></span>unique</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga1d799162e695237dba186603d07f5f93">fcppt::mpl::set::unique</a> = <a class="el" href="#gaa37dfe05e98e3818c75be090f7e7989a">fcppt::mpl::list::distinct</a>&lt;<a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html">fcppt::mpl::list::object</a>&lt;Args...&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a variadic list is pairwise disjoint. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga9b0282cd1b5c26873d39482668ddc195" name="ga9b0282cd1b5c26873d39482668ddc195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b0282cd1b5c26873d39482668ddc195">&#9670;&#160;</a></span>for_each_break()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fcppt::mpl::list::for_each_break </td>
          <td>(</td>
          <td class="paramtype">Function const &amp;</td>          <td class="paramname"><span class="paramname"><em>_function</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a runtime function for each element of a listing, possibly breaking out early. </p>
<p>Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. Calls <code>r_1 = _function(<a class="el" href="../../d6/d43/structfcppt_1_1tag.html" title="A value for a type name.">fcppt::tag&lt;L_1&gt;</a>{})</code>. If <code>r_1 == <a class="el" href="../../d7/d50/group__fcpptvarious.html#ggad862c66baf3fe8aa882a155299887504ae52dc13f7b21f3f18ea924113efd4679">fcppt::loop::break_</a></code>, the algorithm stops. If <code>r_1 == <a class="el" href="../../d7/d50/group__fcpptvarious.html#ggad862c66baf3fe8aa882a155299887504a5b4404524e842940120cc65b3214d40b">fcppt::loop::continue_</a></code>, then <code>r_2 = _function(<a class="el" href="../../d6/d43/structfcppt_1_1tag.html" title="A value for a type name.">fcppt::tag&lt;L_2&gt;</a>{})</code> and so on, up to <code>r_n = _function(<a class="el" href="../../d6/d43/structfcppt_1_1tag.html" title="A value for a type name.">fcppt::tag&lt;L_n&gt;</a>{})</code>.</p>
<p>TODO(concepts) </p>

</div>
</div>
<a id="ga1dedc98380769ab17722724d80bb1692" name="ga1dedc98380769ab17722724d80bb1692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dedc98380769ab17722724d80bb1692">&#9670;&#160;</a></span>invoke_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename Function, typename FailFunction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/group__fcpptpreprocessor.html#gad35104ba14597a60d244959d84fb1b65">FCPPT_PP_PUSH_WARNING</a> std::invoke_result_t&lt; FailFunction &gt; fcppt::mpl::list::invoke_on </td>
          <td>(</td>
          <td class="paramtype">std::size_t const</td>          <td class="paramname"><span class="paramname"><em>_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function const &amp;</td>          <td class="paramname"><span class="paramname"><em>_function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FailFunction const &amp;</td>          <td class="paramname"><span class="paramname"><em>_fail_function</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a function to the nth element of an <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">mpl::list::object</a> with a runtime index. </p>
<p>Let <code>List = <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">list::object&lt;L_1,...,L_n&gt;</a></code>. If <code>_index &lt; n</code> the result is <code>_function(<a class="el" href="../../d6/d43/structfcppt_1_1tag.html" title="A value for a type name.">fcppt::tag&lt;L_i&gt;</a>{})</code>. Otherwise, the result is <code>_fail_function()</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// In the following example, we are going to create a function that can</span></div>
<div class="line"><span class="comment">// transform a color type given at runtime (defined via an enum) into a static</span></div>
<div class="line"><span class="comment">// color type (represented by variant over static color types).</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcppt/tag.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcppt/cast/enum_to_underlying.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcppt/mpl/list/invoke_on.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcppt/mpl/list/object.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcppt/variant/from_list.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcppt/variant/holds_type.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcppt/config/external_begin.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;exception&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcppt/config/external_end.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"><span class="comment">// Our color enum</span></div>
<div class="line"><span class="keyword">enum class</span> color_enum : std::uint8_t</div>
<div class="line">{</div>
<div class="line">  bgr,</div>
<div class="line">  rgb</div>
<div class="line">  <span class="comment">// + more color types</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Our static color types</span></div>
<div class="line"><span class="keyword">struct </span>bgr</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>rgb</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedef the available static color types</span></div>
<div class="line"><span class="keyword">using </span>static_color_types = <a class="code hl_struct" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object&lt;bgr, rgb&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The variant type that can hold any of the static color types</span></div>
<div class="line"><span class="keyword">using </span>color_variant = <a class="code hl_typedef" href="../../d0/d82/group__fcpptvariant.html#ga826ad84520a0e627300c49169611912c" title="Declares a variant using an mpl::list.">fcppt::variant::from_list&lt;static_color_types&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Transforms a concrete color type into a color_variant. This function will be</span></div>
<div class="line"><span class="comment">// used with invoke_on.</span></div>
<div class="line"><span class="keyword">struct </span>create_function</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConcreteColor&gt;</div>
<div class="line">  color_variant operator()(fcppt::tag&lt;ConcreteColor&gt;)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> color_variant(ConcreteColor());</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Transforms a color enum into a static color type using invoke_on</span></div>
<div class="line">color_variant make_color_variant(color_enum <span class="keyword">const</span> _value)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="#ga1dedc98380769ab17722724d80bb1692" title="Applies a function to the nth element of an mpl::list::object with a runtime index.">fcppt::mpl::list::invoke_on&lt;static_color_types&gt;</a>(</div>
<div class="line">      <a class="code hl_function" href="../../d6/dff/group__fcpptcasts.html#ga845df078ee1cd481ffa6cb852cd22934" title="Converts an enum to its underlying type.">fcppt::cast::enum_to_underlying</a>(_value),</div>
<div class="line">      create_function(),</div>
<div class="line">      []() -&gt; color_variant { std::terminate(); });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  color_variant <span class="keyword">const</span> variant(make_color_variant(color_enum::rgb));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// variant now holds the type rgb</span></div>
<div class="line">  std::cout &lt;&lt; fcppt::variant::holds_type&lt;rgb&gt;(variant) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>Must be callable as <code>R fcppt::tag&lt;T&gt;()</code> for every T in <em class="arg">List</em> , where R is the result type.</td></tr>
    <tr><td class="paramname">FailFunction</td><td>Must be a callable as <code>R ()</code>, where R is the result tye.</td></tr>
  </table>
  </dd>
</dl>
<p>TODO(concepts) </p>

</div>
</div>
<a id="gacded41ae90b7b03c036bc68adb25772b" name="gacded41ae90b7b03c036bc68adb25772b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacded41ae90b7b03c036bc68adb25772b">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ch, typename Traits, typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Traits &gt; &amp; fcppt::mpl::list::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Traits &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html">fcppt::mpl::list::object</a>&lt; Types... &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a list.Prints <em class="arg">List</em> to <em class="arg">_stream</em>. Every type in <em class="arg">List</em> will be converted to a string using <a class="el" href="../../d7/d50/group__fcpptvarious.html#ga0461779d96d1904bfe1b052b76876ed7" title="Returns a demangled type name if possible.">fcppt::type_name</a>. </p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ga7c2e3c6df914c43d03c4e941607b2d21" name="ga7c2e3c6df914c43d03c4e941607b2d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c2e3c6df914c43d03c4e941607b2d21">&#9670;&#160;</a></span>all_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::list::all_of_v = <a class="el" href="#ga267a7faf7e25557be2ba8587acfc9748">fcppt::mpl::list::all_of</a>&lt;List,L&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a predicate holds for all types of a list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga267a7faf7e25557be2ba8587acfc9748" title="Checks if a predicate holds for all types of a list.If List=list::object&lt;L_1,...,L_n&gt; and L holds a f...">fcppt::mpl::list::all_of</a> </dd></dl>

</div>
</div>
<a id="gac4bdfaa39d441ab933942f06281e3b45" name="gac4bdfaa39d441ab933942f06281e3b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4bdfaa39d441ab933942f06281e3b45">&#9670;&#160;</a></span>any_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, <a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::list::any_of_v = <a class="el" href="#ga166a33fe4d091a231ecba33d84f5f37e">fcppt::mpl::list::any_of</a>&lt;List,L&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a predicate holds for any type of a list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga166a33fe4d091a231ecba33d84f5f37e" title="Checks if a predicate holds for any type of a list.If List=list::object&lt;L_1,...,L_n&gt; and L holds a fu...">fcppt::mpl::list::any_of</a> </dd></dl>

</div>
</div>
<a id="ga012a6bfae1a0009e9a01bb29e8713ba3" name="ga012a6bfae1a0009e9a01bb29e8713ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga012a6bfae1a0009e9a01bb29e8713ba3">&#9670;&#160;</a></span>apply_v <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::apply_v = <a class="el" href="#ga470122143165d1d2f2037b7122760ef6">fcppt::mpl::apply</a>&lt;L,Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a lambda. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga470122143165d1d2f2037b7122760ef6" title="Calls a lambda.">fcppt::mpl::apply</a> </dd></dl>

</div>
</div>
<a id="ga145ab069ed64d4f77ed055a4af85a1d9" name="ga145ab069ed64d4f77ed055a4af85a1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga145ab069ed64d4f77ed055a4af85a1d9">&#9670;&#160;</a></span>apply_v <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d4/de1/conceptfcppt_1_1mpl_1_1lambda__concept.html">fcppt::mpl::lambda_concept</a> L, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::list::apply_v = <a class="el" href="#ga0b3918537ebf5d2caa2b8f2a65de24da">fcppt::mpl::list::apply</a>&lt;L,Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a lambda using a list of arguments. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0b3918537ebf5d2caa2b8f2a65de24da" title="Calls a lambda using a list of arguments.">fcppt::mpl::list::apply</a> </dd></dl>

</div>
</div>
<a id="ga35975a8b2c5a4607a2ab94acbcaa5cea" name="ga35975a8b2c5a4607a2ab94acbcaa5cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35975a8b2c5a4607a2ab94acbcaa5cea">&#9670;&#160;</a></span>contains_v <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::list::contains_v = <a class="el" href="#gaa037212eb460efe98af4f31a7a9abe81">fcppt::mpl::list::contains</a>&lt;List,E&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a list contains an element. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa037212eb460efe98af4f31a7a9abe81" title="Checks if a list contains an element.Let List = list::object&lt;L_1,...,L_n&gt;. The result is std::true_ty...">fcppt::mpl::list::contains</a> </dd></dl>

</div>
</div>
<a id="gab7bf20471211bf2afad2082882a17d47" name="gab7bf20471211bf2afad2082882a17d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7bf20471211bf2afad2082882a17d47">&#9670;&#160;</a></span>contains_v <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::set::contains_v = <a class="el" href="#ga8ddf7b2c44ebb60b9a03f73af0b1c307">fcppt::mpl::set::contains</a>&lt;Set,Key&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a set contains an element. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8ddf7b2c44ebb60b9a03f73af0b1c307" title="Checks if a set contains an element.Let Set = set::object&lt;E_1,...,E_n&gt;. The result is std::true_type ...">fcppt::mpl::set::contains</a> </dd></dl>

</div>
</div>
<a id="gae89e34d233175ff8e6029ef561bab55f" name="gae89e34d233175ff8e6029ef561bab55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae89e34d233175ff8e6029ef561bab55f">&#9670;&#160;</a></span>distinct_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::list::distinct_v = <a class="el" href="#gaa37dfe05e98e3818c75be090f7e7989a">fcppt::mpl::list::distinct</a>&lt;List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all elements of a list are pairwise disjoint. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa37dfe05e98e3818c75be090f7e7989a" title="Checks if all elements of a list are pairwise disjoint.Let List = list::object&lt;L_1,...">fcppt::mpl::list::distinct</a> </dd></dl>

</div>
</div>
<a id="gae4cf65b217db3efbd6d22516bff728fe" name="gae4cf65b217db3efbd6d22516bff728fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4cf65b217db3efbd6d22516bff728fe">&#9670;&#160;</a></span>empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::list::empty_v = <a class="el" href="#gab8f9810134bbeceb5dfeb17554925200">fcppt::mpl::list::empty</a>&lt;List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a list is empty. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab8f9810134bbeceb5dfeb17554925200" title="Checks if a list is empty.Let List = list::object&lt;L_1,...,L_n&gt;. If n = 0 then std::true_type is retur...">fcppt::mpl::list::empty</a> </dd></dl>

</div>
</div>
<a id="gad9bf1a3782c85503456be6475f7a173c" name="gad9bf1a3782c85503456be6475f7a173c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9bf1a3782c85503456be6475f7a173c">&#9670;&#160;</a></span>equal_v <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map1, <a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::map::equal_v = <a class="el" href="#ga2a8b4a0040e97a4dd995b50adb28a1ec">fcppt::mpl::map::equal</a>&lt;Map1,Map2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two maps are equal. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2a8b4a0040e97a4dd995b50adb28a1ec" title="Checks if two maps are equal.">fcppt::mpl::map::equal</a> </dd></dl>

</div>
</div>
<a id="ga262d22b27825b4653d681b176806464f" name="ga262d22b27825b4653d681b176806464f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga262d22b27825b4653d681b176806464f">&#9670;&#160;</a></span>equal_v <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set1, <a class="el" href="../../d2/dbe/conceptfcppt_1_1mpl_1_1set_1_1object__concept.html">fcppt::mpl::set::object_concept</a> Set2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::set::equal_v = <a class="el" href="#ga1a75321f031545baf4f310b1cbf8bffb">fcppt::mpl::set::equal</a>&lt;Set1,Set2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two sets are equal. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1a75321f031545baf4f310b1cbf8bffb" title="Checks if two sets are equal.">fcppt::mpl::set::equal</a> </dd></dl>

</div>
</div>
<a id="ga24d023a34ce70ea230371b874a09a6e7" name="ga24d023a34ce70ea230371b874a09a6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24d023a34ce70ea230371b874a09a6e7">&#9670;&#160;</a></span>has_key_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d8/d39/conceptfcppt_1_1mpl_1_1map_1_1object__concept.html">fcppt::mpl::map::object_concept</a> Map, typename Key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::map::has_key_v = <a class="el" href="#gafaa4e8d151c964812081344fafc7a89d">fcppt::mpl::map::has_key</a>&lt;Map,Key&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a map contains a key. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafaa4e8d151c964812081344fafc7a89d" title="Checks if a map contains a key.Let Map = map::object&lt;element&lt;K_1,V_1&gt;,...,element&lt;K_n,...">fcppt::mpl::map::has_key</a> </dd></dl>

</div>
</div>
<a id="ga21595c89fbabd14efc471802ae71cbe2" name="ga21595c89fbabd14efc471802ae71cbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21595c89fbabd14efc471802ae71cbe2">&#9670;&#160;</a></span>is_invocable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F, <a class="el" href="../../d3/dff/conceptfcppt_1_1mpl_1_1list_1_1object__concept.html">fcppt::mpl::list::object_concept</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fcppt::mpl::is_invocable_v = <a class="el" href="#ga796e2d02b2681f585321721af80f1f07">fcppt::mpl::is_invocable</a>&lt;F,L&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a function can be invoked with a given argument list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga796e2d02b2681f585321721af80f1f07" title="Checks if a function can be invoked with a given argument list.Checks if function F can be invoked wi...">fcppt::mpl::is_invocable</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for fcppt by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</body>
</html>
