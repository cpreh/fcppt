<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fcppt: Coding style</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname"><span id="projectnumber">&#160;5.0.0</span>
   </div>
   <div id="projectbrief">Freundlich&#39;s C++ toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="../../index.html">Overview</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Coding style </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table id="toc">
<tr>
<td><p class="starttd"></p>
<ul>
<li>
<a class="el" href="#coding_ownership">Ownership</a> </li>
<li>
<a class="el" href="#coding_classes">Classes</a> </li>
<li>
<a class="el" href="#coding_functions">Functions</a> </li>
<li>
<a class="el" href="#coding_loops">Loops</a> </li>
<li>
<a class="el" href="#coding_initialization">Initialization</a> </li>
</ul>
<p class="endtd"></p>
</td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="coding_ownership"></a>
Ownership</h1>
<p>When parameters are passed to functions, especially constructors, use one of the following cases to indicate ownership: </p><ul>
<li>
When a function takes a copy, use <code>T &amp;&amp;</code> for types that are expensive to copy. This forces callers to pass an rvalue reference and make it explicit if they need to provide a copy, e.g. <div class="fragment"><div class="line"><span class="keywordtype">void</span> f(std::string &amp;&amp;);</div>
<div class="line"><span class="keywordtype">void</span> g() { std::string test{<span class="stringliteral">&quot;hello&quot;</span>}; f(std::string(test)); }</div>
</div><!-- fragment --> In cases copies are not expensive, use <code>T</code>.  </li>
<li>
When a function only reads its parameter, use <code>T const &amp;</code>.  </li>
<li>
When a function takes ownership of a class that cannot be copied, use <code><a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr&lt;T&gt;</a> &amp;&amp;</code>.  </li>
<li>
When a function keeps a reference, use <code><a class="el" href="../../db/d57/classfcppt_1_1reference.html" title="A simple reference wrapper that supports incomplete types.">fcppt::reference&lt;T&gt;</a></code>. In this case, it makes it clear to the caller that he has to keep the object alive.  </li>
<li>
When a function needs shared ownership, use <code><a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr&lt;T&gt;</a></code>. This case should be considered last.  </li>
<li>
Avoid regular pointers, especially <code>nullptr</code>.  </li>
</ul>
<h1 class="doxsection"><a class="anchor" id="coding_classes"></a>
Classes</h1>
<p>Following are various points on how to design the interface of a class: </p><ul>
<li>
<p class="startli">Avoid default constructors! Default constructors are usually a sign of bad design, e.g. some code wants to assign to an object but does not need its value. Instead of using a default constructor, simply pass the desired values, e.g. <code>int i{0};</code> instead of <code>int i{};</code>. If you do not have a value for the object yet, do not create it in the first place!</p>
<p class="endli">There are several types which replace standard types with the explicit intend not to be default-constructible, e.g. <a class="el" href="../../df/d96/classfcppt_1_1function.html">fcppt::function</a>, <a class="el" href="../../d3/dc8/classfcppt_1_1unique__ptr.html" title="A simpler unique_ptr that shouldn&#39;t be used as a null pointer.">fcppt::unique_ptr</a>, <a class="el" href="../../d2/d6b/classfcppt_1_1shared__ptr.html" title="A shared pointer class that gets the deleter as a template parameter.">fcppt::shared_ptr</a> and <a class="el" href="../../d8/d29/classfcppt_1_1variant_1_1object.html" title="A class that can hold any object from a fixed set of types.">fcppt::variant::object</a>.  </p>
</li>
<li>
Give every class a (non default) constructor. This ties in with <a class="el" href="#coding_ownership">Ownership</a>. Another point is that the initialization syntax for structs and classes allows for partial initialization, e.g. <div class="fragment"><div class="line"><span class="keyword">struct </span>S { <span class="keywordtype">int</span> i; <span class="keywordtype">int</span> j; }; S x{42};</div>
</div><!-- fragment --> However, most compilers issue a warning for this.  </li>
<li>
Make classes explicitly noncopyable using <a class="el" href="../../d7/d50/group__fcpptvarious.html#ga364a4c4031f2c9e2f0c802cd103074a3" title="Makes a class noncopyable.">FCPPT_NONCOPYABLE</a> in case their copy constructors / assignment operators that are generated by default should not be used, or in case they can not be generated because a member is not copyable. If a class should be movable but not copyable, explicitly provide a move constructor and move assignment operator. Most of the time, the implementation obtained by using <code>= default</code> can be used.  </li>
<li>
Do not use regular references as members. They make a class non assignable. Instead, use <a class="el" href="../../db/d57/classfcppt_1_1reference.html" title="A simple reference wrapper that supports incomplete types.">fcppt::reference</a>.  </li>
</ul>
<h1 class="doxsection"><a class="anchor" id="coding_functions"></a>
Functions</h1>
<p>Following are various points about functions: </p><ul>
<li>
Make functions total! In case they can return nothing, use <a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::object</a>. In case they can return an error, use <a class="el" href="../../de/d54/classfcppt_1_1either_1_1object.html" title="A class that either holds a success or an error value.">fcppt::either::object</a>.  </li>
<li>
Avoid cases where certain combinations of parameters are invalid. These cases can usually be avoided by using <a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::object</a>, <a class="el" href="../../d8/d29/classfcppt_1_1variant_1_1object.html" title="A class that can hold any object from a fixed set of types.">fcppt::variant::object</a>, and so on. If it is very difficult to avoid this, it is best to throw an exception.  </li>
<li>
Do not use default parameters and do not use function overloading. It is better to provide a function with a different name or to change the typing of parameters, e.g. by using <a class="el" href="../../da/d72/classfcppt_1_1optional_1_1object.html" title="A class that makes values optional.">fcppt::optional::object</a>.  </li>
<li>
Avoid functions that get multiple parameters of the same type. Use <a class="el" href="../../df/d7e/classfcppt_1_1strong__typedef.html" title="Used to create strong typedefs.">fcppt::strong_typedef</a> to disambiguate which parameter is used for which purpose. For example, instead of <code>void f(std::string const &amp;name, std::string const &amp;email);</code> use <div class="fragment"><div class="line"><a class="code hl_define" href="../../da/d0b/group__fcpptstrongtypedef.html#ga1f82fc70fe467d70c01a134c2ebf94b3" title="Creates a new strong typedef using fcppt::strong_typedef.">FCPPT_DECLARE_STRONG_TYPEDEF</a>(std::string, name);</div>
<div class="line"><a class="code hl_define" href="../../da/d0b/group__fcpptstrongtypedef.html#ga1f82fc70fe467d70c01a134c2ebf94b3" title="Creates a new strong typedef using fcppt::strong_typedef.">FCPPT_DECLARE_STRONG_TYPEDEF</a>(std::string, email);</div>
<div class="line"><span class="keywordtype">void</span> f(name <span class="keyword">const</span> &amp;, email <span class="keyword">const</span> &amp;);</div>
</div><!-- fragment --> In some cases, merging multiple parameters into one can also help, e.g. instead of <code>void f(int x, int y);</code>, use <code>void f(fcppt::math::vector::static_&lt;int,2&gt;);</code>.  </li>
<li>
Do not use return parameters! In case you need to return multiple objects, create a struct or class that encapsulates this.  </li>
</ul>
<h1 class="doxsection"><a class="anchor" id="coding_loops"></a>
Loops</h1>
<p>Avoid explicit loops if possible. There are many cases in which an algorithm can be used instead. For example, instead of </p><div class="fragment"><div class="line">  <span class="keywordtype">int</span> <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a>{0};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{1}; i &lt; n; ++i)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a> += i;</div>
<div class="line">  }</div>
</div><!-- fragment --><p> you can use <a class="el" href="../../de/d60/group__fcpptalgorithm.html#ga2badaec70ff770f2b896935dfa1d750f" title="Folds a range into a value.">fcppt::algorithm::fold</a> </p><div class="fragment"><div class="line">  <a class="code hl_function" href="../../de/d60/group__fcpptalgorithm.html#ga2badaec70ff770f2b896935dfa1d750f" title="Folds a range into a value.">fcppt::algorithm::fold</a>(</div>
<div class="line">      <a class="code hl_function" href="../../d7/d50/group__fcpptvarious.html#gafa4ef940b2c59323e5033e9c7fcabacf" title="Creates a forward integer range.">fcppt::make_int_range</a>(1, n), 0, [](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> result) { <span class="keywordflow">return</span> i + <a class="code hl_typedef" href="../../da/df4/group__fcpptoptions.html#ga43268a6477e039adb818aba8d0daf1d6" title="The result of a parse operation.">result</a>; })</div>
</div><!-- fragment --><p>Algorithms can only be used with ranges, not with iterators. In case you need to encapsulate iterators, use <code>std::ranges::subrange</code>. There are also special ranges like <a class="el" href="../../d9/d5f/classfcppt_1_1int__range.html" title="A forward range over integers.">fcppt::int_range</a> or <a class="el" href="../../da/d72/classfcppt_1_1enum___1_1range.html" title="A range over a contiguous enum.">fcppt::enum_::range</a>. Some algorithms also accept an <a class="el" href="../../d6/d7d/structfcppt_1_1mpl_1_1list_1_1object.html" title="The list type used by this library.">fcppt::mpl::list::object</a> as a range in case you need to iterate over types.</p>
<h1 class="doxsection"><a class="anchor" id="coding_initialization"></a>
Initialization</h1>
<p>Initialize all objects and make them const if possible, especially do not use default constructors.</p>
<p>Provide functions for cases in which initialization can not be expressed directly. Consider a function that initializes an array of arbitrary size: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><a class="code hl_class" href="../../db/d7f/classfcppt_1_1array_1_1object.html">fcppt::array::object&lt;T, N&gt;</a> make_array();</div>
</div><!-- fragment --><p> Say you have a function <code>T from_index(std::size_t)</code> that creates an array element given an index. You can then initialize the array using </p><div class="fragment"><div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="../../d6/df3/group__fcpptarray.html#gaa6c8f0cca81bbe922f6c431c054f9643" title="Constructs an array by calling a function with static indices.">fcppt::array::init&lt;fcppt::array::object&lt;T, N&gt;</a>&gt;(</div>
<div class="line">      [](std::size_t i) { <span class="keywordflow">return</span> from_index&lt;T&gt;(i); });</div>
</div><!-- fragment --><p>In case you really need uninitialized objects, create a constructor that takes <a class="el" href="../../d0/d71/structfcppt_1_1no__init.html" title="A dummy struct to use a constructor that does not initialize.">fcppt::no_init</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for fcppt by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</body>
</html>
